<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>PK Assistant ‚Äì RER A</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <!-- PWA Configuration -->
  <meta name="description" content="Assistant de calcul de PK pour la ligne RER A" />
  <meta name="theme-color" content="#3d7bff" />
  
  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="PK Assistant" />
  
  <!-- Manifest (charg√© uniquement si pas en file:// pour √©viter l'erreur CORS) -->
  <script>
    if (window.location.protocol !== 'file:') {
      const link = document.createElement('link');
      link.rel = 'manifest';
      link.href = 'manifest.json';
      document.head.appendChild(link);
    }
  </script>
  
  <!-- Ic√¥nes -->
  <link rel="icon" type="image/svg+xml" href="icon.svg" />
  <link rel="apple-touch-icon" href="icon.svg" />
  <!-- G√©n√©ration de l'ic√¥ne PNG pour iOS (ex√©cut√© imm√©diatement) -->
  <script>
    (function() {
      const canvas = document.createElement('canvas');
      canvas.width = 180;
      canvas.height = 180;
      const ctx = canvas.getContext('2d');
      
      // Cr√©er le gradient radial (m√™me que le titre)
      const gradient = ctx.createRadialGradient(0, 0, 0, 90, 90, 180);
      gradient.addColorStop(0, '#ff9f7b');
      gradient.addColorStop(0.24, '#ff4b6b');
      gradient.addColorStop(0.70, '#3d7bff');
      gradient.addColorStop(1, '#1a1b3a');
      
      // Dessiner le fond avec coins arrondis
      ctx.fillStyle = gradient;
      ctx.beginPath();
      const radius = 35;
      ctx.moveTo(radius, 0);
      ctx.lineTo(180 - radius, 0);
      ctx.quadraticCurveTo(180, 0, 180, radius);
      ctx.lineTo(180, 180 - radius);
      ctx.quadraticCurveTo(180, 180, 180 - radius, 180);
      ctx.lineTo(radius, 180);
      ctx.quadraticCurveTo(0, 180, 0, 180 - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      ctx.closePath();
      ctx.fill();
      
      // Dessiner l'emoji m√©tro/RER (utiliser une police syst√®me qui supporte les emojis)
      ctx.fillStyle = 'white';
      ctx.font = 'bold 175px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üöá', 90, 90);
      
      // Cr√©er le lien apple-touch-icon avec le data URI
      const dataUrl = canvas.toDataURL('image/png');
      const link = document.createElement('link');
      link.rel = 'apple-touch-icon';
      link.sizes = '180x180';
      link.href = dataUrl;
      document.head.appendChild(link);
    })();
  </script>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

  :root {
    color-scheme: dark;
    --bg: #0b101f;
    --bg-gradient: radial-gradient(circle at 0% -20%, rgba(117, 92, 255, 0.45), transparent 55%), radial-gradient(circle at 100% 0%, rgba(255, 108, 163, 0.35), transparent 60%), linear-gradient(180deg, #070913 0%, #02030a 100%);
    --card: rgba(19, 23, 36, 0.72);
    --card-soft: rgba(26, 30, 45, 0.76);
    --card-border: rgba(200, 206, 236, 0.14);
    --border: rgba(200, 206, 236, 0.14);
    --text: rgba(240, 244, 255, 0.94);
    --muted: rgba(198, 207, 246, 0.62);
    --muted-strong: rgba(214, 223, 255, 0.78);
    --accent: #63a9ff;
    --accent-strong: #9c8eff;
    --accent-soft: rgba(120, 168, 255, 0.18);
    --highlight: #cba5ff;
    --danger: #ff6f7a;
    --danger-soft: rgba(255, 111, 122, 0.18);
    --good: #9de2b0;
    --good-soft: rgba(157, 226, 176, 0.18);
    --warning: #ffd27f;
    --shadow-sm: 0 4px 14px rgba(6, 8, 18, 0.45);
    --shadow-md: 0 18px 38px rgba(6, 8, 18, 0.55);
    --shadow-lg: 0 30px 65px rgba(5, 7, 16, 0.65);
    --transition-fast: 0.15s ease;
    --transition-normal: 0.25s ease;
    --transition-slow: 0.4s ease;
  }

  * { box-sizing: border-box; }

  html, body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
  }

  body {
    position: relative;
    padding: 8px 0 20px;
    background: var(--bg-gradient);
    color: var(--text);
    overflow-x: hidden;
  }

  body::before {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: -1;
    background-image:
      radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,0.16), transparent 60%),
      radial-gradient(2px 2px at 80% 30%, rgba(255,255,255,0.10), transparent 60%),
      radial-gradient(1.5px 1.5px at 20% 80%, rgba(255,255,255,0.12), transparent 60%),
      radial-gradient(1.5px 1.5px at 70% 70%, rgba(255,255,255,0.08), transparent 60%);
    opacity: 0.35;
  }

  /* Arri√®re-plan √©toil√© avec motif r√©p√©t√© et anim√© - √©toiles lumineuses */
  body::after {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    background-image:
      /* √âtoiles moyennes lumineuses */
      radial-gradient(3px 3px at 10% 15%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 30% 25%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 50% 35%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 70% 45%, rgba(255,255,255,0.95), transparent 70%),
      radial-gradient(3px 3px at 90% 55%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 20% 65%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 40% 75%, rgba(255,255,255,0.95), transparent 70%),
      radial-gradient(3px 3px at 60% 85%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 80% 95%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 15% 5%, rgba(255,255,255,0.95), transparent 70%),
      radial-gradient(3px 3px at 35% 15%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 55% 25%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 75% 35%, rgba(255,255,255,0.95), transparent 70%),
      radial-gradient(3px 3px at 95% 45%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 25% 55%, rgba(255,255,255,1), transparent 70%),
      radial-gradient(3px 3px at 45% 65%, rgba(255,255,255,0.95), transparent 70%),
      radial-gradient(3px 3px at 65% 75%, rgba(255,255,255,0.9), transparent 70%),
      radial-gradient(3px 3px at 85% 85%, rgba(255,255,255,1), transparent 70%),
      /* √âtoiles grandes brillantes */
      radial-gradient(4px 4px at 5% 10%, rgba(255,255,255,0.8), transparent 60%),
      radial-gradient(4px 4px at 25% 20%, rgba(255,255,255,0.85), transparent 60%),
      radial-gradient(4px 4px at 45% 30%, rgba(255,255,255,0.8), transparent 60%),
      radial-gradient(4px 4px at 65% 40%, rgba(255,255,255,0.85), transparent 60%),
      radial-gradient(4px 4px at 85% 50%, rgba(255,255,255,0.8), transparent 60%),
      radial-gradient(4px 4px at 15% 60%, rgba(255,255,255,0.85), transparent 60%),
      radial-gradient(4px 4px at 35% 70%, rgba(255,255,255,0.8), transparent 60%),
      radial-gradient(4px 4px at 55% 80%, rgba(255,255,255,0.85), transparent 60%),
      radial-gradient(4px 4px at 75% 90%, rgba(255,255,255,0.8), transparent 60%),
      radial-gradient(4px 4px at 95% 100%, rgba(255,255,255,0.85), transparent 60%),
      /* √âtoiles tr√®s brillantes (points focaux) */
      radial-gradient(5px 5px at 20% 30%, rgba(255,255,255,0.7), transparent 50%),
      radial-gradient(5px 5px at 60% 50%, rgba(255,255,255,0.75), transparent 50%),
      radial-gradient(5px 5px at 80% 70%, rgba(255,255,255,0.7), transparent 50%),
      radial-gradient(5px 5px at 40% 80%, rgba(255,255,255,0.75), transparent 50%);
    background-size: 300px 300px;
    background-repeat: repeat;
    opacity: 1;
    animation: starsAnimated 15s linear infinite;
    /* Optimisation batterie : pause les animations quand la page n'est pas visible */
    animation-play-state: running;
  }

  /* Pause les animations quand la page n'est pas visible (√©conomie batterie) */
  body[data-page-hidden="true"]::after {
    animation-play-state: paused;
  }

  @keyframes starsAnimated {
    0% {
      background-position: 0% 0%;
      opacity: 0.9;
    }
    25% {
      opacity: 1;
    }
    50% {
      background-position: 100% 100%;
      opacity: 0.95;
    }
    75% {
      opacity: 1;
    }
    100% {
      background-position: 0% 0%;
      opacity: 0.9;
    }
  }

  .app {
    max-width: 1080px;
    margin: 0 auto;
    padding: 0 24px 220px;
    margin-top: 0;
  }

  .tabbar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 24px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 16px;
    padding: 14px 18px;
    width: calc(100% - 40px);
    max-width: 960px;
    background: linear-gradient(180deg, rgba(80, 100, 140, 0.25), rgba(100, 120, 160, 0.18));
    border-radius: 26px 26px 34px 34px;
    border: 1px solid rgba(150, 180, 220, 0.5);
    box-shadow: 0 20px 46px rgba(4, 8, 20, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.45);
    backdrop-filter: blur(10px) saturate(140%);
    z-index: 3500;
  }

  .tab-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    padding: 12px 10px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    color: rgba(12, 16, 30, 0.92);
    font-weight: 600;
    letter-spacing: 0.01em;
    transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.18s ease;
    box-shadow: 0 14px 26px rgba(12, 16, 30, 0.2), 0 0 14px rgba(255, 255, 255, 0.24);
    opacity: 0.96;
  }

  .tab-button .tab-icon {
    font-size: 1.24rem;
    line-height: 1;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.55), 0 0 6px rgba(255, 255, 255, 0.65), 0 0 12px rgba(130, 180, 255, 0.55);
  }

  .tab-button .tab-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    display: none;
  }

  .tab-button.is-active {
    transform: translateY(-4px);
    box-shadow: 0 12px 28px rgba(12, 16, 30, 0.28);
    opacity: 1;
    border: 1px solid rgba(15, 25, 60, 0.18);
  }

  .tab-button--status {
    background: linear-gradient(135deg, rgba(255, 156, 179, 0.95), rgba(255, 156, 179, 0.75));
    color: rgba(48, 12, 22, 0.85);
    box-shadow: inset 0 0 14px rgba(255, 156, 179, 0.45);
  }

  .tab-button--plan {
    background: linear-gradient(135deg, rgba(255, 143, 112, 0.95), rgba(255, 143, 112, 0.72));
    color: rgba(58, 20, 12, 0.85);
    box-shadow: inset 0 0 14px rgba(255, 143, 112, 0.4);
  }

  .tab-button--urgence {
    background: linear-gradient(135deg, rgba(255, 188, 134, 0.92), rgba(255, 188, 134, 0.7));
    color: rgba(58, 28, 10, 0.82);
    box-shadow: inset 0 0 14px rgba(255, 188, 134, 0.38);
  }

  .tab-button--recherche {
    background: linear-gradient(135deg, rgba(255, 200, 77, 0.9), rgba(255, 200, 77, 0.7));
    color: rgba(46, 28, 4, 0.84);
    box-shadow: inset 0 0 14px rgba(255, 200, 77, 0.36);
  }

  .tab-button--fermetures {
    background: linear-gradient(135deg, rgba(214, 240, 114, 0.9), rgba(214, 240, 114, 0.7));
    color: rgba(35, 48, 10, 0.82);
    box-shadow: inset 0 0 14px rgba(214, 240, 114, 0.34);
  }

  .tab-button--settings {
    background: linear-gradient(135deg, rgba(241, 166, 255, 0.92), rgba(241, 166, 255, 0.72));
    color: rgba(46, 16, 64, 0.82);
    box-shadow: inset 0 0 14px rgba(241, 166, 255, 0.36);
  }

  .tab-panels {
    margin-top: 6px;
    padding-bottom: 140px;
  }

  .plan-line-card .field {
    margin-bottom: 18px;
  }

  .plan-toggle label {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
    cursor: pointer;
    color: rgba(214, 223, 255, 0.85);
  }

  .plan-toggle input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--accent);
  }

  .plan-line-container {
    margin-top: 12px;
    border-radius: 18px;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    box-shadow: 0 14px 28px rgba(5, 7, 16, 0.32);
    touch-action: pan-y;
  }

  .pdf-navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 12px 16px;
    background: rgba(14, 18, 28, 0.6);
    border-bottom: 1px solid rgba(62, 80, 130, 0.3);
    border-radius: 18px 18px 0 0;
  }

  .pdf-nav-btn {
    background: linear-gradient(135deg, rgba(100, 140, 200, 0.8), rgba(80, 120, 180, 0.7));
    border: 1px solid rgba(120, 160, 220, 0.4);
    color: rgba(240, 245, 255, 0.95);
    border-radius: 10px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(20, 40, 80, 0.3);
  }

  .pdf-nav-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, rgba(120, 160, 220, 0.9), rgba(100, 140, 200, 0.8));
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(20, 40, 80, 0.4);
  }

  .pdf-nav-btn:active:not(:disabled) {
    transform: translateY(0);
  }

  .pdf-nav-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .pdf-page-info {
    display: flex;
    align-items: center;
    gap: 6px;
    color: rgba(230, 235, 255, 0.9);
    font-size: 0.9rem;
    font-weight: 500;
  }

  .pdf-page-input {
    width: 60px;
    padding: 8px 10px;
    background: rgba(20, 26, 40, 0.7);
    border: 1px solid rgba(100, 140, 200, 0.3);
    border-radius: 8px;
    color: rgba(240, 245, 255, 0.95);
    font-size: 0.9rem;
    font-weight: 600;
    text-align: center;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: textfield;
  }

  .pdf-page-input::-webkit-outer-spin-button,
  .pdf-page-input::-webkit-inner-spin-button {
    appearance: none;
    -webkit-appearance: none;
    margin: 0;
  }

  .pdf-page-input:focus {
    outline: none;
    border-color: rgba(120, 160, 220, 0.6);
    box-shadow: 0 0 0 2px rgba(100, 140, 200, 0.2);
  }

  .pdf-page-total {
    color: rgba(200, 210, 230, 0.7);
    font-size: 0.85rem;
  }

  .plan-line-iframe {
    width: 100%;
    height: 500px;
    border: none;
    background: #0a0c12;
    touch-action: pan-y pan-x;
    -webkit-overflow-scrolling: touch;
    pointer-events: auto;
  }

  @media (max-width: 640px) {
    .pdf-navigation {
      padding: 10px 12px;
      gap: 10px;
    }
    .pdf-nav-btn {
      width: 36px;
      height: 36px;
      font-size: 1.3rem;
    }
    .pdf-page-input {
      width: 50px;
      padding: 6px 8px;
      font-size: 0.85rem;
    }
    .pdf-page-info {
      font-size: 0.85rem;
    }
    .plan-line-container {
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
      max-height: 70vh;
    }
    .plan-line-iframe {
      height: 600px;
      min-height: 500px;
      touch-action: pan-y pan-x;
      -webkit-overflow-scrolling: touch;
      pointer-events: auto;
      display: block;
    }
  }
  .pk-lookup-input {
    display: flex;
    gap: 10px;
    align-items: stretch;
  }

  .pk-lookup-input input {
    flex: 1 1 auto;
    min-width: 0;
  }

  .pk-lookup-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .pk-lookup-actions .btn {
    flex: 1 1 150px;
  }

  .pk-lookup-choice {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    width: 100%;
    padding: 12px 14px;
    margin-top: 8px;
    border-radius: 14px;
    border: 1px solid rgba(200, 206, 236, 0.22);
    background: rgba(20, 26, 48, 0.65);
    color: var(--text);
    text-align: left;
    transition: transform var(--transition-fast), border var(--transition-fast), background var(--transition-fast);
  }

  .pk-lookup-choice:hover,
  .pk-lookup-choice:focus {
    outline: none;
    transform: translateY(-1px);
    border-color: rgba(238, 242, 255, 0.45);
    background: rgba(28, 34, 56, 0.75);
  }

  .pk-lookup-choice strong {
    font-weight: 600;
    font-size: 0.96rem;
  }

  .recal-preview {
    background: rgba(20, 24, 44, 0.65);
    border-radius: 14px;
    border: 1px solid rgba(200, 206, 236, 0.18);
    padding: 14px;
  }

  .recal-preview-content {
    margin-bottom: 12px;
    line-height: 1.5;
  }

  .recal-preview-content span {
    font-weight: 600;
    color: rgba(238, 242, 255, 0.92);
  }

  .recal-preview-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .recal-messages {
    min-height: 20px;
  }

  .recal-messages.is-error {
    color: #ff9393;
  }

  .recal-messages.is-success {
    color: #7bffce;
  }

  .recal-history-list {
    font-size: 0.88rem;
    line-height: 1.5;
  }

  .recal-history-item {
    margin-top: 6px;
  }

  .recal-history-list strong {
    color: rgba(238, 242, 255, 0.92);
  }

  .pk-lookup-choice .muted {
    color: rgba(216, 222, 255, 0.72);
  }

  .branch-choice-control {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 8px;
  }

  .branch-choice-label {
    font-size: 0.8rem;
    color: rgba(216, 222, 255, 0.72);
  }

  .branch-choice-wrapper {
    position: relative;
  }

  .branch-choice-menu-container {
    position: relative;
    display: inline-block;
  }

  .branch-choice-button {
    border: 1px solid rgba(200, 206, 236, 0.22);
    background: rgba(24, 30, 48, 0.6);
    color: rgba(236, 239, 255, 0.9);
    border-radius: 999px;
    padding: 6px 14px;
    font-size: 0.78rem;
    cursor: pointer;
    transition: background 0.2s ease, border 0.2s ease;
    position: relative;
  }

  .branch-choice-button:hover {
    background: rgba(46, 52, 70, 0.75);
    border-color: rgba(220, 228, 255, 0.35);
  }

  .branch-choice-button[aria-expanded="true"] {
    background: rgba(46, 52, 70, 0.9);
    border-color: rgba(220, 228, 255, 0.5);
  }

  .branch-choice-menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    z-index: 1000;
    background: rgba(24, 30, 48, 0.98);
    border: 1px solid rgba(200, 206, 236, 0.3);
    border-radius: 8px;
    padding: 4px;
    min-width: 160px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .branch-choice-menu[hidden] {
    display: none;
  }

  .branch-choice-menu button {
    background: transparent;
    border: none;
    color: rgba(236, 239, 255, 0.9);
    padding: 8px 12px;
    text-align: left;
    cursor: pointer;
    border-radius: 4px;
    font-size: 0.85rem;
    transition: background 0.15s ease;
  }

  .branch-choice-menu button:hover {
    background: rgba(46, 52, 70, 0.6);
  }

  .branch-choice-menu button:active {
    background: rgba(60, 70, 90, 0.8);
  }

  .orientation-branch-control {
    margin-top: 10px;
  }

  .tab-panel {
    display: none;
  }

  .tab-panel.is-active {
    display: block;
  }
  @media (max-width: 640px) {
    .tabbar {
      width: calc(100% - 18px);
      max-width: none;
      grid-template-columns: repeat(6, minmax(48px, 1fr));
      gap: 8px;
      padding: 10px 12px;
      bottom: 16px;
      border-radius: 20px;
    }
    .tab-button {
      padding: 9px 7px;
      border-radius: 13px;
      box-shadow: 0 12px 22px rgba(12, 16, 30, 0.18), 0 0 12px rgba(255, 255, 255, 0.22);
    }
    .tab-button .tab-icon {
      font-size: 1.08rem;
      text-shadow: 0 0 3px rgba(0, 0, 0, 0.55), 0 0 5px rgba(255, 255, 255, 0.6), 0 0 10px rgba(130, 180, 255, 0.5);
    }
  }

  .header {
    margin-bottom: 12px;
    margin-top: 0;
    text-align: center;
  }

  .title-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 8px 16px;
    margin: 0 auto 20px;
    width: fit-content;
    max-width: 100%;
    border-radius: 999px;
    background: radial-gradient(circle at 0% 0%, rgba(255, 159, 123, 0.96) 0%, rgba(255, 75, 107, 0.88) 25%, rgba(102, 125, 255, 0.82) 70%, rgba(24, 28, 60, 0.95) 100%);
    border: 1px solid rgba(255, 255, 255, 0.22);
    transition: all var(--transition-normal);
    position: relative;
    overflow: hidden;
    box-shadow: 0 16px 40px rgba(12, 12, 28, 0.58);
  }


  .hero-gyro {
    width: 52px;
    height: 52px;
    border-radius: 16px;
    background: radial-gradient(circle at 50% 35%, rgba(255, 233, 240, 0.95) 0%, rgba(255, 125, 158, 0.8) 55%, rgba(104, 140, 255, 0.75) 100%);
    box-shadow: 0 0 26px rgba(255, 120, 170, 0.55), 0 0 38px rgba(120, 160, 255, 0.4);
    position: relative;
    overflow: hidden;
  }

  .hero-gyro::before {
    content: "";
    position: absolute;
    inset: 10px 12px;
    border-radius: 10px;
    background: linear-gradient(180deg, rgba(28, 30, 48, 0.95), rgba(12, 14, 28, 0.98));
    box-shadow: inset 0 -5px 12px rgba(0, 0, 0, 0.45);
  }

  .hero-gyro::after {
    content: "";
    position: absolute;
    top: 8px;
    left: 50%;
    width: 13px;
    height: 22px;
    background: linear-gradient(180deg, rgba(255, 190, 210, 0.95), rgba(255, 110, 160, 0.35));
    border-radius: 50%;
    transform: translateX(-50%);
    box-shadow: 0 0 10px rgba(255, 150, 196, 0.48);
    animation: heroGyroPulse 3s ease-in-out infinite;
  }

  @keyframes heroGyroPulse {
    0%, 100% { transform: translateX(-50%) scale(0.9); opacity: 0.8; }
    50% { transform: translateX(-50%) scale(1.08); opacity: 1; }
  }

  .title-pill {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 12px 20px 10px;
    border-radius: 999px;
    background: radial-gradient(circle at 0% 0%, rgba(255, 159, 123, 0.96) 0%, rgba(255, 75, 107, 0.88) 25%, rgba(102, 125, 255, 0.82) 70%, rgba(24, 28, 60, 0.95) 100%);
    border: 1px solid rgba(255, 255, 255, 0.22);
    margin: 0;
    transition: all var(--transition-normal);
    position: relative;
    overflow: hidden;
    box-shadow: 0 16px 40px rgba(12, 12, 28, 0.58);
  }

  .title-pill::before {
    content: "";
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    animation: shimmer 3s ease-in-out infinite;
  }

  @keyframes shimmer {
    0%, 100% { transform: translate(-50%, -50%) rotate(0deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) rotate(180deg); opacity: 1; }
  }

  .title-main {
    font-size: 1.45rem;
    font-weight: 700;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: #fff;
    text-align: center;
  }

  .title-sub {
    font-size: 1.05rem;
    font-weight: 600;
    margin-top: 2px;
    color: #f3f2ff;
    text-align: center;
  }

  .subtitle {
    color: var(--muted-strong);
    font-size: 1rem;
    margin: 10px 0 6px;
    line-height: 1.6;
    font-weight: 500;
  }

  .note {
    font-size: 0.82rem;
    color: var(--muted);
    line-height: 1.6;
    margin-top: 6px;
    opacity: 0.92;
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
  }

  .section-title {
    font-size: 0.75rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: rgba(214, 223, 255, 0.48);
    margin: 42px 0 18px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .section-title::before,
  .section-title::after {
    content: "";
    flex: 1;
    height: 1px;
    background: rgba(200, 206, 236, 0.12);
  }

  .section-title::before { margin-right: 8px; }
  .section-title::after { margin-left: 8px; }

  .app-content {
    display: grid;
    gap: 24px;
    margin: 18px 0 8px;
  }

  @media (min-width: 1024px) {
    .app-content {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 28px;
    }
    .card.full-width {
      grid-column: 1 / -1;
    }
  }

  .card {
    background: var(--card);
    backdrop-filter: blur(12px);
    border-radius: 22px;
    padding: 24px 24px 20px;
    border: 1px solid var(--card-border);
    box-shadow: var(--shadow-md);
    transition: transform var(--transition-normal), box-shadow var(--transition-normal), border-color var(--transition-normal);
  }

  .card:hover {
    border-color: rgba(200, 206, 236, 0.24);
    box-shadow: var(--shadow-lg);
    transform: translateY(-2px);
  }

  .card-soft {
    background: var(--card-soft);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(200, 206, 236, 0.12);
  }

  .card-title {
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: rgba(214, 223, 255, 0.7);
    transition: color var(--transition-fast);
  }

  .card:hover .card-title {
    color: rgba(236, 239, 255, 0.88);
  }

  .big-value {
    font-size: 1.9rem;
    font-weight: 700;
    margin: 8px 0 6px;
    color: rgba(244, 247, 255, 0.96);
    line-height: 1.2;
    letter-spacing: -0.01em;
    text-shadow: 0 6px 18px rgba(7, 10, 20, 0.5);
  }

  .big-sub {
    font-size: 1rem;
    color: var(--muted-strong);
  }

  .muted {
    color: var(--muted);
    font-size: 0.88rem;
  }

  .badge {
    font-size: 0.78rem;
    padding: 5px 12px;
    border-radius: 12px;
    border: 1px solid rgba(200, 206, 236, 0.18);
    color: rgba(214, 223, 255, 0.75);
    background: rgba(26, 32, 48, 0.72);
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    transition: all var(--transition-fast);
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .badge::before {
    content: "";
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
    opacity: 0.6;
    display: inline-block;
  }

  .badge-good {
    color: var(--good);
    background: var(--good-soft);
  }

  .badge-danger {
    color: var(--danger);
    background: var(--danger-soft);
  }

  .badge-warn {
    color: var(--warning);
    background: rgba(255,184,77,0.12);
  }
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 22px;
    border-radius: 14px;
    border: 1px solid transparent;
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.01em;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    background: rgba(28, 32, 46, 0.82);
    color: var(--muted-strong);
    box-shadow: none;
    backdrop-filter: blur(4px);
  }
  .btn:hover {
    transform: translateY(-1px);
    border-color: rgba(200, 206, 236, 0.22);
  }

  .btn:active {
    transform: translateY(0);
    box-shadow: none;
  }

  .btn-primary {
    background: linear-gradient(135deg, var(--accent), var(--accent-strong));
    color: #070913;
    box-shadow: 0 10px 24px rgba(104, 147, 255, 0.35);
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, #77b4ff, #b19cff);
    border-color: transparent;
  }

  .btn-primary:active {
    background: linear-gradient(135deg, #5b9bff, #9984ff);
    box-shadow: 0 6px 18px rgba(104, 147, 255, 0.25);
  }
  .btn-secondary {
    background: rgba(26, 32, 46, 0.7);
    border-color: rgba(200, 206, 236, 0.18);
    color: rgba(236, 239, 255, 0.88);
  }
  .btn-secondary:hover {
    background: rgba(34, 40, 56, 0.82);
  }
  .btn-danger {
    background: linear-gradient(135deg, var(--danger), #ff8a96);
    color: #160610;
    box-shadow: 0 10px 24px rgba(255, 111, 122, 0.32);
  }
  .btn-danger:active {
    box-shadow: 0 6px 16px rgba(255, 111, 122, 0.25);
  }

  .btn-good {
    background: linear-gradient(135deg, rgba(70, 200, 180, 0.22), rgba(90, 210, 204, 0.34));
    border: 1px solid rgba(120, 220, 210, 0.35);
    color: rgba(210, 248, 242, 0.92);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.28);
  }

  .btn-warning {
    background: linear-gradient(135deg, #ffd27f, #ffb874);
    color: #341b08;
    box-shadow: 0 10px 24px rgba(255, 201, 120, 0.28);
  }

  .btn-warning:active {
    box-shadow: 0 6px 16px rgba(255, 201, 120, 0.22);
  }

  .btn-tertiary {
    background: transparent;
    border-color: rgba(200, 206, 236, 0.14);
    color: rgba(214, 223, 255, 0.72);
  }

  .btn-tertiary:hover {
    background: rgba(28, 32, 46, 0.55);
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
  }

  .btn-icon {
    display: inline-flex;
    align-items: center;
    gap: 10px;
  }

  .btn-icon span:first-child {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 34px;
    height: 34px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.14);
    color: inherit;
    font-size: 1.05rem;
    line-height: 1;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
  }

  .btn-primary.btn-icon span:first-child {
    background: rgba(15, 40, 90, 0.16);
    box-shadow: inset 0 0 0 1px rgba(109, 144, 255, 0.28);
  }

  .btn-secondary.btn-icon span:first-child {
    background: rgba(40, 46, 66, 0.55);
  }

  .btn-danger.btn-icon span:first-child {
    background: rgba(255, 138, 150, 0.22);
    box-shadow: inset 0 0 0 1px rgba(255, 120, 150, 0.32);
  }

  .btn-good.btn-icon span:first-child {
    background: rgba(157, 226, 176, 0.22);
    box-shadow: inset 0 0 0 1px rgba(157, 226, 176, 0.32);
  }

  .btn-warning.btn-icon span:first-child {
    background: rgba(255, 215, 145, 0.22);
    box-shadow: inset 0 0 0 1px rgba(255, 200, 120, 0.3);
  }

  .status-card {
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .status-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 16px;
  }
  .status-heading {
    font-size: 0.95rem;
    font-weight: 650;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(214, 223, 255, 0.78);
  }
  .status-helper {
    font-size: 0.82rem;
    color: var(--muted);
    margin-top: 4px;
  }
  .status-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 14px;
    border-radius: 999px;
    font-size: 0.78rem;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    background: rgba(28, 32, 46, 0.75);
    border: 1px solid rgba(200, 206, 236, 0.18);
    color: rgba(236, 239, 255, 0.92);
    min-width: 88px;
  }
  .status-badge--danger {
    background: rgba(255, 135, 160, 0.18);
    border-color: rgba(255, 135, 160, 0.38);
    color: #ff94aa;
  }
  .status-badge--warning {
    background: rgba(255, 215, 145, 0.18);
    border-color: rgba(255, 215, 145, 0.35);
    color: #ffd27f;
  }

  .status-badge--success {
    background: rgba(157, 226, 176, 0.18);
    border-color: rgba(157, 226, 176, 0.35);
    color: #b6f0c6;
  }

  .status-cta {
    width: 100%;
    justify-content: center;
    margin-top: -4px;
  }

  .status-list {
    display: flex;
    flex-direction: column;
    gap: 18px;
  }
  .status-line {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 16px;
  }
  .status-label {
    font-size: 0.82rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(198, 207, 246, 0.7);
    flex: 0 0 auto;
  }

  .status-values {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 2px;
    text-align: right;
    flex: 1 1 auto;
  }

  .status-value {
    font-size: 1.3rem;
    font-weight: 650;
    color: rgba(244, 247, 255, 0.96);
  }

  .status-detail {
    font-size: 0.78rem;
    color: var(--muted);
    max-width: 220px;
  }

  .status-detail:empty {
    display: none;
  }
  @media (max-width: 640px) {
    .app {
      padding: 0 12px 24px;
    }
    .card {
      padding: 16px 16px 14px;
      border-radius: 18px;
    }
    .big-value {
      font-size: 1.5rem;
    }
    .btn {
      width: 100%;
      border-radius: 14px;
      padding: 14px 20px;
    }
    .title-pill {
      padding: 10px 18px;
    }
    .card-header {
      margin-bottom: 10px;
      padding-bottom: 6px;
    }
    .section-title {
      margin: 34px 0 16px;
    }
    .app-content {
      grid-template-columns: 1fr;
      gap: 20px;
      margin: 16px 0;
    }
    #orientationMap {
      height: 180px;
      border-radius: 10px;
      margin-top: 6px;
    }
    .coverage-legend {
      padding: 8px;
      border-radius: 10px;
    }
    .coverage-legend-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .coverage-legend-collapse {
      border: 1px solid rgba(200, 206, 236, 0.18);
      background: rgba(28, 32, 46, 0.6);
      color: rgba(230, 233, 255, 0.85);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.68rem;
    }
    .coverage-legend-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 8px;
    }
    .coverage-legend-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .coverage-legend-filter {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
    }
    .coverage-legend-filter input {
      width: 14px;
      height: 14px;
    }
    .coverage-legend-branch-btn {
      width: 100%;
      justify-content: center;
      padding: 6px 10px;
      font-size: 0.7rem;
    }
    .coverage-legend-branch-menu {
      left: 0;
      right: auto;
    }
    .coverage-legend-helper {
      font-size: 0.7rem;
      margin-bottom: 6px;
    }
    .coverage-legend-items {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .coverage-legend-item {
      width: 100%;
      justify-content: flex-start;
      padding: 7px 9px;
      font-size: 0.74rem;
    }


    .orientation-info-panel {
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
    }
    .orientation-info-item {
      gap: 6px;
    }
    .orientation-info-label {
      font-size: 0.74rem;
    }
    .orientation-info-value {
      font-size: 0.9rem;
    }
    .orientation-block.is-live #orientationMap {
      height: 160px;
    }
    .orientation-block.is-live .orientation-info-panel {
      padding: 8px;
      gap: 4px;
    }
    .orientation-block.is-live .orientation-info-item {
      padding: 2px 0;
    }
    .orientation-block.is-live .orientation-info-label {
      font-size: 0.68rem;
    }
    .orientation-block.is-live .orientation-info-value {
      font-size: 0.82rem;
    }
    .orientation-target-controls {
      gap: 6px;
      align-items: stretch;
    }
    .orientation-target-input {
      font-size: 0.82rem;
      padding: 9px 10px;
      flex: 1 1 70%;
    }
    .orientation-target-button {
      flex: 0 0 auto;
      padding: 8px 10px;
      font-size: 0.7rem;
      border-radius: 10px;
      width: auto;
    }
    .orientation-target-button.btn-icon {
      gap: 6px;
    }
    .orientation-target-button.btn-icon span:first-child {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      font-size: 0.9rem;
    }
    .orientation-target-info {
      font-size: 0.72rem;
      padding-left: 4px;
    }
  }

  .field {
    margin-top: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .field:first-child {
    margin-top: 0;
  }

  .field label {
    font-size: 0.87rem;
    color: var(--muted);
    font-weight: 500;
    line-height: 1.4;
    transition: color var(--transition-fast);
  }

  .field:focus-within label {
    color: rgba(255, 255, 255, 0.8);
  }

  .pk-lookup-section {
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 16px;
    padding: 16px;
    margin: 12px 0;
    background: rgba(255, 255, 255, 0.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  .pk-lookup-section .field label {
    font-size: 1.1rem;
    font-weight: 600;
    color: #fff;
  }
  .pk-calibration-section {
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 16px;
    padding: 16px;
    margin: 12px 0;
    background: rgba(255, 255, 255, 0.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  .pk-calibration-section .field label {
    font-size: 1.1rem;
    font-weight: 600;
    color: #fff;
  }

  .sensitivity-section {
    border: 1px solid var(--card-border);
    border-radius: 18px;
    padding: 18px;
    margin: 16px 0;
    background: rgba(24, 28, 44, 0.55);
    box-shadow: none;
  }

  .sensitivity-section .field label {
    font-size: 1rem;
    font-weight: 600;
    color: rgba(236, 239, 255, 0.9);
  }

  input, select, textarea {
    width: 100%;
    padding: 12px 16px;
    border-radius: 14px;
    border: 1px solid rgba(200, 206, 236, 0.16);
    background: rgba(16, 19, 32, 0.8);
    color: var(--text);
    font-size: 0.95rem;
    outline: none;
    transition: all var(--transition-fast);
    backdrop-filter: blur(6px);
  }

  input:hover, select:hover, textarea:hover {
    border-color: rgba(200, 206, 236, 0.26);
  }

  input:focus, select:focus, textarea:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(99, 169, 255, 0.22), 0 10px 24px rgba(7, 10, 20, 0.35);
    background: rgba(18, 22, 36, 0.9);
  }

  input:invalid, select:invalid, textarea:invalid {
    border-color: var(--danger);
  }

  textarea {
    resize: vertical;
    min-height: 80px;
  }

  .access-item {
    margin-bottom: 6px;
  }

  .settings-footer {
    margin-top: 12px; 
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 0.05em;
  }

  /* Signature en bas de page */
  .app-footer {
    text-align: center;
    padding: 20px 0;
    margin-top: 30px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 0.75rem;
    color: var(--muted);
    letter-spacing: 0.2em;
  }

  .app-footer-contact {
    margin-top: 6px;
    letter-spacing: 0.04em;
  }

  .app-footer-contact a {
    color: var(--accent);
    text-decoration: none;
    font-weight: 600;
    letter-spacing: 0.02em;
  }

  .app-footer-contact a:hover,
  .app-footer-contact a:focus-visible {
    text-decoration: underline;
  }

  /* Styles pour les boutons de test */
  .test-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .test-item:last-child {
    border-bottom: none;
  }

  .test-item-text {
    flex: 1;
    font-size: 0.9rem;
    color: rgba(236, 239, 255, 0.85);
    line-height: 1.4;
  }

  .test-buttons {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
  }

  .test-btn {
    width: 44px;
    height: 44px;
    border-radius: 10px;
    border: 1px solid;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 1.3rem;
    font-weight: 600;
    transition: all 0.2s ease;
    background: rgba(20, 26, 40, 0.6);
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .test-btn-ok {
    border-color: rgba(70, 200, 180, 0.4);
    color: rgba(70, 200, 180, 0.7);
  }

  .test-btn-ok:hover {
    background: rgba(70, 200, 180, 0.15);
    border-color: rgba(70, 200, 180, 0.6);
    color: rgba(120, 220, 210, 0.9);
  }

  .test-btn-ok.active {
    background: rgba(70, 200, 180, 0.25);
    border-color: rgba(70, 200, 180, 0.7);
    color: #46c8b4;
    box-shadow: 0 0 12px rgba(70, 200, 180, 0.3);
  }

  .test-btn-ko {
    border-color: rgba(255, 111, 122, 0.4);
    color: rgba(255, 111, 122, 0.7);
  }

  .test-btn-ko:hover {
    background: rgba(255, 111, 122, 0.15);
    border-color: rgba(255, 111, 122, 0.6);
    color: rgba(255, 150, 160, 0.9);
  }

  .test-btn-ko.active {
    background: rgba(255, 111, 122, 0.25);
    border-color: rgba(255, 111, 122, 0.7);
    color: #ff6f7a;
    box-shadow: 0 0 12px rgba(255, 111, 122, 0.3);
  }

  @media (max-width: 640px) {
    .test-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
      padding: 14px 0;
    }

    .test-item-text {
      width: 100%;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .test-buttons {
      width: 100%;
      justify-content: flex-end;
      gap: 12px;
    }

    .test-btn {
      width: 50px;
      height: 50px;
      font-size: 1.4rem;
      border-radius: 12px;
    }

    #testListContent h3 {
      font-size: 1.05rem !important;
      margin-top: 24px !important;
      margin-bottom: 14px !important;
      padding-bottom: 8px !important;
    }

    #testListContent p {
      font-size: 0.9rem !important;
      margin-bottom: 16px !important;
    }
  }

  .access-contact-link {
    display: inline-block;
    margin-top: 14px;
    color: var(--accent);
    font-weight: 600;
    text-decoration: none;
    letter-spacing: 0.02em;
  }

  .access-contact-link:hover,
  .access-contact-link:focus-visible {
    text-decoration: underline;
  }

  .divider {
    margin: 10px 0;
    height: 1px;
    background: rgba(255,255,255,0.04);
  }

.signalement-block {
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 18px;
    padding: 16px;
    margin: 14px 0 6px;
    box-shadow: none;
  }

  /* √âtats de chargement */
  .loading {
    position: relative;
    color: transparent !important;
    pointer-events: none;
  }

  .loading::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 16px;
    height: 16px;
    margin: -8px 0 0 -8px;
    border: 2px solid var(--accent);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Feedback visuel pour les actions r√©ussies */
  .success-feedback {
    animation: successPulse 0.4s ease;
  }

  @keyframes successPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); background-color: var(--good-soft); }
    100% { transform: scale(1); }
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .orientation-block {
  margin-top: 10px;
  padding-top: 4px;
}

/* Carte interactive Leaflet avec th√®me sombre */
#orientationMap {
  width: 100%;
  height: 400px;
  border-radius: 12px;
  overflow: hidden;
  margin-top: 12px;
  background: #0a0c12;
}

/* Style personnalis√© pour Leaflet avec th√®me sombre */
.leaflet-container {
  background: #0a0c12;
  color: #fff;
}

/* Marqueur PK actuel (point central) */
.leaflet-marker-pk-actuel {
  background: #3d7bff;
  border: 3px solid #fff;
  border-radius: 50%;
  width: 20px !important;
  height: 20px !important;
  box-shadow: 0 0 15px rgba(61, 123, 255, 0.8);
  animation: pkPulse 2s ease-in-out infinite;
  /* Optimisation batterie : pause les animations quand la page n'est pas visible */
  animation-play-state: running;
}

/* Pause les animations quand la page n'est pas visible */
body[data-page-hidden="true"] .leaflet-marker-pk-actuel {
  animation-play-state: paused;
}

@keyframes pkPulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 15px rgba(61, 123, 255, 0.8);
  }
  50% {
    transform: scale(1.1);
    box-shadow: 0 0 25px rgba(61, 123, 255, 1);
  }
}

/* Ic√¥ne de gare */
.leaflet-marker-gare {
  background: #ff4b6b;
  border: 2px solid #fff;
  border-radius: 50%;
  width: 24px !important;
  height: 24px !important;
  box-shadow: 0 0 10px rgba(255, 75, 107, 0.6);
}

/* Ic√¥ne d'acc√®s (porte) */
.leaflet-marker-acces {
  background: #ff9f7b;
  border: 2px solid #fff;
  border-radius: 4px;
  width: 18px !important;
  height: 18px !important;
  box-shadow: 0 0 8px rgba(255, 159, 123, 0.6);
}

/* Ic√¥ne PK cible (croix rouge) */
.leaflet-marker-pk-target {
  background: transparent;
  width: 30px !important;
  height: 30px !important;
  position: relative;
}
.leaflet-marker-pk-target::before,
.leaflet-marker-pk-target::after {
  content: "";
  position: absolute;
  background: #ff0000;
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.8), 0 0 15px rgba(255, 0, 0, 0.6);
}

.leaflet-marker-pk-target::before {
  width: 3px;
  height: 100%;
  left: 50%;
  top: 0;
  transform: translateX(-50%);
}
.leaflet-marker-pk-target::after {
  width: 100%;
  height: 3px;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
}

/* Ic√¥ne SAM (feu rouge pastel) */
.leaflet-marker-sam {
  background: radial-gradient(circle at 40% 40%, rgba(255, 214, 214, 0.88), rgba(247, 163, 163, 0.88) 70%, rgba(242, 133, 138, 0.88) 100%);
  border: 2px solid rgba(255, 224, 224, 0.9);
  border-radius: 50%;
  width: 22px !important;
  height: 22px !important;
  display: flex;
  align-items: center;
  justify-content: center;
  transform: translateZ(0);
}

/* Ic√¥ne p√©tard (losange pastel) */
.leaflet-marker-petard {
  background: linear-gradient(135deg, rgba(214, 236, 255, 0.88), rgba(203, 200, 255, 0.88) 60%, rgba(240, 201, 255, 0.88) 100%);
  border: 2px solid rgba(220, 226, 255, 0.9);
  border-radius: 4px;
  width: 18px !important;
  height: 18px !important;
  transform: rotate(45deg);
  display: flex;
  align-items: center;
  justify-content: center;
  transform-origin: center;
}

.leaflet-marker-petard span {
  transform: rotate(-45deg);
  font-size: 0.7rem;
  color: rgba(22, 26, 38, 0.7);
}
/* Fl√®che de direction */
.leaflet-marker-direction {
  background: transparent;
  border: none;
  width: 44px !important;
  height: 44px !important;
}

.direction-arrow {
  position: relative;
  width: 34px;
  height: 34px;
  transform-origin: 50% 55%;
  transform: rotate(var(--arrow-rotation, 0deg));
  filter: drop-shadow(0 0 10px rgba(21, 120, 255, 0.55));
}

.direction-arrow::before {
  content: "";
  position: absolute;
  inset: 0;
  clip-path: polygon(50% 0%, 100% 72%, 64% 72%, 50% 100%, 36% 72%, 0% 72%);
  background: linear-gradient(135deg, rgba(28, 200, 255, 0.88), rgba(13, 135, 255, 0.88) 55%, rgba(11, 47, 143, 0.88) 100%);
  box-shadow: 0 0 12px rgba(21, 120, 255, 0.45), 0 8px 18px rgba(4, 10, 24, 0.65);
}

.direction-arrow::after {
  content: "";
  position: absolute;
  inset: 5px 7px 9px 11px;
  clip-path: polygon(50% 0%, 94% 70%, 60% 70%, 50% 94%, 40% 70%, 6% 70%);
  background: rgba(8, 10, 18, 0.92);
  box-shadow: inset 0 0 6px rgba(12, 18, 32, 0.6);
}

.direction-arrow-moving {
  animation: arrowMoveForward 1.8s ease-in-out infinite;
  animation-play-state: running;
}

/* Pause les animations quand la page n'est pas visible */
body[data-page-hidden="true"] .direction-arrow-moving {
  animation-play-state: paused;
}
.direction-arrow-indetermine {
  filter: drop-shadow(0 0 6px rgba(80, 86, 110, 0.6));
}

.direction-arrow-indetermine::before {
  background: linear-gradient(135deg, rgba(163, 168, 186, 0.88), rgba(88, 95, 116, 0.88) 100%);
  box-shadow: 0 0 10px rgba(82, 88, 110, 0.35), 0 6px 14px rgba(6, 8, 16, 0.55);
}
.direction-arrow-indetermine::after {
  background: rgba(8, 10, 18, 0.75);
  box-shadow: inset 0 0 4px rgba(12, 14, 22, 0.6);
}

@media (prefers-reduced-motion: reduce) {
  body::after {
    animation: none;
    opacity: 0.4;
  }
  .title-pill::before,
.hero-gyro::after { animation: none; }
  .direction-arrow-moving,
  .leaflet-marker-pk-actuel,
  .orientation-info-panel,
  .coverage-summary-chip,
  .coverage-legend-item {
    animation: none;
  }
}

/* Styles des r√©sum√©s et popups de couverture travaux */
.coverage-summary-chip {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: rgba(40, 46, 66, 0.6);
  border: 1px solid rgba(200, 206, 236, 0.2);
  border-radius: 999px;
  padding: 6px 14px;
  margin: 4px 10px 4px 0;
  font-size: 0.9rem;
  backdrop-filter: blur(6px);
}

.coverage-summary-chip strong {
  color: #fbe5ff;
  letter-spacing: 0.04em;
}

.coverage-summary-access {
  color: rgba(226, 231, 255, 0.75);
  font-size: 0.82rem;
}
.coverage-summary-access span {
  color: rgba(156, 205, 255, 0.85);
}
.coverage-result-block {
  margin-top: 16px;
  border-radius: 14px;
  background: rgba(9, 11, 18, 0.78);
  border: 1px solid rgba(190, 198, 235, 0.18);
  padding: 16px;
}

.coverage-point {
  margin-top: 14px;
  padding: 12px 14px;
  border-radius: 12px;
  background: linear-gradient(145deg, rgba(18, 21, 34, 0.64), rgba(13, 15, 24, 0.52));
  border: 1px solid rgba(255, 255, 255, 0.04);
}

.coverage-point--nested {
  margin-top: 10px;
  padding: 10px 12px;
  background: linear-gradient(145deg, rgba(18, 21, 34, 0.62), rgba(13, 15, 24, 0.5));
  border: 1px solid rgba(255, 255, 255, 0.04);
}

.coverage-point-header {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: #fef6ff;
  font-size: 0.92rem;
}

.coverage-point--nested .coverage-point-header {
  font-size: 0.85rem;
  letter-spacing: 0.04em;
}

.coverage-point-info {
  margin-top: 6px;
  font-size: 0.85rem;
  color: rgba(226, 231, 255, 0.78);
  line-height: 1.5;
}

.coverage-point-info strong {
  color: #fff;
}

.coverage-nav-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 10px;
}

.coverage-nav-buttons--compact {
  justify-content: center;
  margin-top: 8px;
  gap: 6px;
}

.coverage-nav-buttons--compact .map-nav-btn {
  padding: 6px 10px;
  font-size: 0.78rem;
}

.map-nav-btn {
  background: rgba(28, 32, 46, 0.75);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 999px;
  padding: 6px 14px;
  color: rgba(245, 247, 255, 0.95);
  font-size: 0.82rem;
  font-weight: 600;
  letter-spacing: 0.03em;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
  box-shadow: 0 2px 6px rgba(9, 11, 18, 0.35);
}

.map-nav-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(9, 11, 18, 0.4);
  border-color: rgba(255, 255, 255, 0.18);
}

.map-nav-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 4px rgba(9, 11, 18, 0.25);
}

.map-nav-btn--compact {
  padding: 6px 10px;
  font-size: 0.78rem;
}

.map-nav-btn--waze {
  background: linear-gradient(135deg, rgba(183, 224, 255, 0.9), rgba(132, 190, 255, 0.9));
  border-color: rgba(132, 190, 255, 0.45);
  box-shadow: 0 2px 8px rgba(43, 78, 116, 0.28);
  color: #132132;
}

.map-nav-btn--maps {
  background: linear-gradient(135deg, rgba(196, 245, 214, 0.9), rgba(156, 226, 191, 0.9));
  border-color: rgba(156, 226, 191, 0.45);
  box-shadow: 0 2px 8px rgba(32, 83, 63, 0.26);
  color: #123324;
}

.coverage-popup {
  min-width: 220px;
  max-width: 260px;
  color: #fdfcff;
  font-size: 0.85rem;
  line-height: 1.5;
}

.coverage-popup-title {
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  margin-bottom: 4px;
  color: #ffe7ff;
}

.coverage-popup-meta {
  color: rgba(217, 225, 255, 0.8);
  font-size: 0.8rem;
}

.coverage-popup-access {
  margin-top: 8px;
  font-size: 0.78rem;
  color: rgba(226, 231, 255, 0.85);
}

.coverage-popup-access strong {
  color: #fff;
}

.coverage-popup-actions {
  margin-top: 10px;
}
.coverage-petard-list {
  margin-top: 12px;
  display: grid;
  gap: 10px;
}
.coverage-petard-list .coverage-point {
  margin-top: 0;
}
.leaflet-popup-content-wrapper {
  background: rgba(14, 16, 24, 0.92);
  border-radius: 16px;
  border: 1px solid rgba(200, 206, 236, 0.12);
  box-shadow: 0 8px 24px rgba(4, 6, 12, 0.6);
  color: rgba(236, 239, 255, 0.92);
  backdrop-filter: blur(6px);
}

.leaflet-popup-content {
  color: rgba(236, 239, 255, 0.92);
}
.leaflet-popup-tip {
  background: rgba(14, 16, 24, 0.92);
  border: 1px solid rgba(200, 206, 236, 0.12);
  box-shadow: 0 8px 24px rgba(4, 6, 12, 0.45);
}
.coverage-legend {
  margin-top: 14px;
  padding: 12px;
  border-radius: 12px;
  background: rgba(14, 16, 24, 0.85);
  border: 1px solid rgba(200, 206, 236, 0.16);
  display: none;
}

.coverage-legend-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
}

.coverage-legend-collapse {
  border: 1px solid rgba(200, 206, 236, 0.22);
  background: rgba(28, 32, 46, 0.6);
  color: rgba(230, 233, 255, 0.85);
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
  transition: transform 0.2s ease, background 0.2s ease;
  font-size: 0.78rem;
}

.coverage-legend-collapse:hover {
  background: rgba(46, 52, 70, 0.7);
}

.coverage-legend-title {
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  font-size: 0.78rem;
  color: rgba(230, 233, 255, 0.75);
  margin-bottom: 6px;
}

.coverage-legend-helper {
  font-size: 0.78rem;
  color: rgba(214, 223, 255, 0.7);
  line-height: 1.45;
  margin-bottom: 10px;
}

.coverage-legend-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}

.coverage-legend-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.coverage-legend-filter {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 0.78rem;
  color: rgba(236, 239, 255, 0.82);
  user-select: none;
}

.coverage-legend-filter input {
  width: 16px;
  height: 16px;
  accent-color: var(--accent);
}

.coverage-legend-branch {
  position: relative;
}

.coverage-legend-branch-btn {
  border: 1px solid rgba(200, 206, 236, 0.22);
  background: rgba(28, 32, 46, 0.55);
  color: rgba(236, 239, 255, 0.88);
  border-radius: 999px;
  padding: 7px 14px;
  font-size: 0.78rem;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

.coverage-legend-branch.is-manual .coverage-legend-branch-btn {
  border-color: var(--accent);
  color: rgba(173, 209, 255, 0.95);
}

.coverage-legend-branch-btn:hover {
  background: rgba(46, 52, 70, 0.65);
}

.coverage-legend-branch-menu {
  position: absolute;
  right: 0;
  top: 110%;
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 10px;
  border-radius: 12px;
  background: rgba(18, 20, 30, 0.95);
  border: 1px solid rgba(200, 206, 236, 0.18);
  box-shadow: 0 12px 24px rgba(4, 6, 12, 0.45);
  z-index: 4000;
}

.coverage-legend-branch-menu[hidden] {
  display: none;
}

.coverage-legend-branch-menu button {
  border: none;
  background: rgba(28, 32, 46, 0.7);
  color: rgba(236, 239, 255, 0.9);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 0.76rem;
  cursor: pointer;
  text-align: left;
}

.coverage-legend-branch-menu button:hover {
  background: rgba(46, 52, 70, 0.8);
}

.coverage-legend-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.coverage-legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: 999px;
  border: 1px solid rgba(200, 206, 236, 0.16);
  background: rgba(28, 32, 46, 0.6);
  color: rgba(236, 239, 255, 0.95);
  font-size: 0.82rem;
  font-weight: 600;
  letter-spacing: 0.03em;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, opacity 0.2s ease;
}

.coverage-legend-item:hover {
  transform: translateY(-1px);
  border-color: rgba(255, 255, 255, 0.18);
}

.coverage-legend-item:active {
  transform: translateY(0);
}

.coverage-legend-item.is-disabled {
  opacity: 0.45;
  cursor: default;
  pointer-events: none;
}

.coverage-legend[data-collapsed="true"] .coverage-legend-controls,
.coverage-legend[data-collapsed="true"] .coverage-legend-items,
.coverage-legend[data-collapsed="true"] .coverage-legend-helper {
  display: none;
}

.coverage-legend[data-collapsed="true"] .coverage-legend-collapse {
  transform: rotate(180deg);
}

.coverage-guide-toggle {
  margin-top: 6px;
}
.coverage-guide-toggle label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 0.78rem;
  color: rgba(236, 239, 255, 0.85);
  cursor: pointer;
  user-select: none;
}

.coverage-guide-toggle input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: var(--accent);
}

.coverage-guide {
  display: none;
  margin-top: 10px;
  padding: 12px;
  border-radius: 10px;
  border: 1px solid rgba(200, 206, 236, 0.14);
  background: rgba(18, 20, 30, 0.85);
  color: rgba(236, 239, 255, 0.9);
  font-size: 0.76rem;
  line-height: 1.55;
}
.coverage-guide.is-visible {
  display: block;
}

.coverage-guide ol {
  margin: 0 0 0 18px;
  padding: 0;
}

.coverage-guide ul {
  margin: 8px 0 0 18px;
  padding: 0;
}

.coverage-guide li + li {
  margin-top: 6px;
}

.orientation-target-group {
  gap: 10px;
}
.orientation-target-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  width: 100%;
}

.orientation-target-input {
  flex: 1 1 auto;
}

.orientation-target-button {
  flex-shrink: 0;
}
.orientation-target-info {
  font-size: 0.8rem;
  color: rgba(214, 223, 255, 0.75);
  padding-left: 8px;
}

.coverage-legend-swatch {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  flex-shrink: 0;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
}

.coverage-legend-swatch--sam {
  background: linear-gradient(135deg, rgba(255, 214, 214, 0.88), rgba(247, 163, 163, 0.88) 70%, rgba(242, 133, 138, 0.88) 100%);
}

.coverage-legend-swatch--petard {
  background: linear-gradient(135deg, rgba(214, 236, 255, 0.88), rgba(203, 200, 255, 0.88) 60%, rgba(240, 201, 255, 0.88) 100%);
}

.orientation-info-value.is-clickable {
  cursor: pointer;
  color: rgba(173, 195, 255, 0.95);
  transition: color 0.2s ease;
}

.orientation-info-value.is-clickable:hover,
.orientation-info-value.is-clickable:focus {
  color: rgba(211, 225, 255, 1);
  text-decoration: underline;
}

.orient-access-chip {
  display: block;
  border: none;
  background: none;
  padding: 0;
  margin: 6px 0 0;
  color: rgba(173, 195, 255, 0.95);
  font-size: 0.82rem;
  letter-spacing: 0.02em;
  cursor: pointer;
  text-decoration: none;
  white-space: nowrap;
  text-align: right;
  margin-left: auto;
}

.orient-access-chip:hover,
.orient-access-chip:focus {
  color: rgba(211, 225, 255, 1);
  text-decoration: underline;
  outline: none;
}

/* Animation de la fl√®che qui avance en temps r√©el */
@keyframes arrowMoveForward {
  0% {
    transform: rotate(var(--arrow-rotation, 0deg)) translateY(0) scale(1);
    opacity: 1;
  }
  50% {
    transform: rotate(var(--arrow-rotation, 0deg)) translateY(-6px) scale(1.08);
    opacity: 0.9;
  }
  100% {
    transform: rotate(var(--arrow-rotation, 0deg)) translateY(0) scale(1);
    opacity: 1;
  }
}

/* Panneau d'information sur la carte */
.orientation-info-panel {
  position: relative;
  margin-top: 14px;
  background: rgba(16, 19, 32, 0.9);
  border: 1px solid var(--card-border);
  border-radius: 16px;
  padding: 14px;
  z-index: 1000;
  backdrop-filter: blur(12px);
  box-shadow: 0 18px 40px rgba(5, 7, 16, 0.45);
}

.orientation-info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  font-size: 0.88rem;
}

.orientation-info-label {
  color: var(--muted);
  font-weight: 600;
  letter-spacing: 0.03em;
}

.orientation-info-value {
  color: rgba(236, 239, 255, 0.92);
  font-weight: 600;
  text-align: right;
  flex: 1 1 auto;
  display: block;
}

.orientation-info-group + .orientation-info-group {
  margin-top: 12px;
}

.orientation-info-label {
  font-size: 0.74rem;
}
.orientation-info-value {
  font-size: 0.9rem;
}
.orientation-target-controls {
  gap: 6px;
  align-items: stretch;
}

</style>

</head>
<body>
  <div id="accessOverlay" style="
  position:fixed;
  inset:0;
  background:radial-gradient(circle at top, #251c4a 0%, #050510 60%, #010106 100%);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
">
  <div class="card" style="max-width:320px;width:90%;text-align:center;">
    <div class="card-title" style="width:100%;text-align:center;">Code d'acc√®s</div>
    <div class="muted" style="margin-top:6px;">
      Application interne ‚Äì acc√®s r√©serv√©.<br>
      Saisis le code d'acc√®s.
    </div>

    <div class="field" style="margin-top:12px;">
      <input id="accessCodeInput"
             type="password"
             inputmode="numeric"
             maxlength="6"
             placeholder="Code"
             style="text-align:center;font-size:1.1rem;letter-spacing:0.2em;">
    </div>

    <div class="field">
      <button id="btnAccessCode" class="btn btn-primary btn-icon" type="button">
        <span>üîì</span><span>D√©verrouiller</span>
      </button>
    </div>

    <div id="accessError" class="muted" style="color:var(--danger);display:none;">
      Code incorrect.
    </div>

    <a class="access-contact-link" href="mailto:pascal.akriche@ratp.fr">
      Administrateur&nbsp;: pascal.akriche@ratp.fr
    </a>
  </div>
</div>

  <div class="app">
    <div class="header">
      <div class="title-wrapper">
        <span class="hero-gyro" aria-hidden="true"></span>
        <div class="title-pill">
          <div class="title-main">PK-ASSIST</div>
          <div class="title-sub">RER A</div>
        </div>
        <span class="hero-gyro" aria-hidden="true"></span>
      </div>
      <div class="subtitle">‚ö†Ô∏è Avertissement</div>
      <div class="note">
        Cette application est une aide √† l'orientation sur la voie, destin√©e √† un usage informatif uniquement.<br>
        Elle ne remplace en aucun cas les consignes de s√©curit√©, les proc√©dures internes de la RATP ou la vigilance des agents sur le terrain.<br>
        L'utilisation du t√©l√©phone sur la voie est strictement interdite. Toute consultation doit se faire en dehors des zones de danger et dans le respect absolu des r√®gles de s√©curit√©.
      </div>
    </div>

    <div class="tab-panels">

      <section class="tab-panel is-active" data-tab="status">
        <h2 class="section-title">Statut en temps r√©el</h2>
        <div class="app-content">
          <div class="card full-width status-card">
            <div class="status-header">
              <div>
                <div class="status-heading">G√©olocalisation</div>
                <div id="geolocText" class="status-helper">Pr√™t √† d√©marrer.</div>
              </div>
              <span id="gpsStatusBadge" class="status-badge status-badge--danger">GPS OFF</span>
            </div>
            <button id="btnToggleGeoloc" class="btn btn-primary btn-icon status-cta" type="button">
              <span>üìç</span><span>Lancer la g√©oloc</span>
            </button>
            <div class="branch-choice-control branch-choice-wrapper" style="margin-top: 12px;">
              <span class="branch-choice-label">Forcer la branche :</span>
              <div class="branch-choice-menu-container">
                <button id="btnBranchGeoloc" type="button" class="branch-choice-button" aria-expanded="false">Auto</button>
                <div id="branchMenuGeoloc" class="branch-choice-menu" hidden>
                  <button type="button" data-branch="auto" data-context="geoloc">Auto</button>
                  <button type="button" data-branch="central" data-context="geoloc">Tron√ßon central</button>
                  <button type="button" data-branch="boissy" data-context="geoloc">Boissy</button>
                  <button type="button" data-branch="chessy" data-context="geoloc">Chessy</button>
                </div>
              </div>
            </div>
            <div class="status-list">
              <div class="status-line">
                <span class="status-label">PK actuel</span>
                <div class="status-values">
                  <span id="pkCurrentValue" class="status-value">‚Äî</span>
                  <span id="pkCurrentDetails" class="status-detail"></span>
                </div>
              </div>
              <div class="status-line">
                <span class="status-label">Sens / mouvement</span>
                <div class="status-values">
                  <span id="movementTitle" class="status-value">D√©tection en attente</span>
                  <span id="movementDetails" class="status-detail"></span>
                </div>
              </div>
              <div class="status-line">
                <span class="status-label">Gare la plus proche</span>
                <div class="status-values">
                  <span id="nearestStationName" class="status-value">‚Äî</span>
                  <span id="nearestStationInfo" class="status-detail"></span>
                </div>
              </div>
              <div class="status-line">
                <span class="status-label">Prochaine gare</span>
                <div class="status-values">
                  <span id="nextStationName" class="status-value">‚Äî</span>
                  <span id="nextStationInfo" class="status-detail"></span>
                </div>
              </div>
              <div class="status-line">
                <span class="status-label">Acc√®s le plus proche</span>
                <div class="status-values">
                  <span id="nearestAccessName" class="status-value">‚Äî</span>
                  <span id="nearestAccessInfo" class="status-detail"></span>
                </div>
              </div>
            </div>
          </div>
         </div>
       </section>

      <section class="tab-panel" data-tab="plan">
        <h2 class="section-title">Plan / Orientation</h2>
        <div class="app-content">
          <div id="orientationCard" class="card orientation-block full-width">
            <div class="card-header">
              <div class="card-title">Plan ‚Äì PK / gares / acc√®s</div>
            </div>
            <div id="orientationMap"></div>
            <div id="orientationInfoPanel" class="orientation-info-panel" style="display: none;">
              <div class="orientation-info-item">
                <span class="orientation-info-label">PK actuel :</span>
                <span id="orientPkValue" class="orientation-info-value">‚Äî</span>
              </div>
              <div class="orientation-info-item">
                <span class="orientation-info-label">Sens :</span>
                <span id="orientDirValue" class="orientation-info-value">En attente de GPS‚Ä¶</span>
              </div>
              <div class="orientation-info-group">
                <div class="orientation-info-item">
                  <span class="orientation-info-label">Gare la plus proche :</span>
                  <span id="orientGareValue" class="orientation-info-value">‚Äî</span>
                </div>
              </div>
              <div class="orientation-info-group">
                <div class="orientation-info-item">
                  <span class="orientation-info-label">Acc√®s les plus proches :</span>
                  <span id="orientAccessValue" class="orientation-info-value">‚Äî</span>
                </div>
              </div>
              <div class="orientation-info-group orientation-target-group">
                <div class="orientation-info-item orientation-target-item">
                  <span class="orientation-info-label">PK cible :</span>
                  <div class="orientation-target-controls">
                    <input id="inputPkTarget" type="text" placeholder="ex : 32400 ou 32+400" class="orientation-target-input" />
                    <button id="btnSetPkTarget" class="btn btn-secondary btn-icon orientation-target-button" type="button">
                      <span>üéØ</span><span>D√©finir</span>
                    </button>
                  </div>
                  <div class="branch-choice-control orientation-branch-control branch-choice-wrapper">
                    <span class="branch-choice-label">Branche :</span>
                    <div class="branch-choice-menu-container">
                      <button id="btnBranchTarget" type="button" class="branch-choice-button" aria-expanded="false">Tron√ßon central</button>
                      <div id="branchMenuTarget" class="branch-choice-menu" hidden>
                        <button type="button" data-branch="central" data-context="target">Tron√ßon central</button>
                        <button type="button" data-branch="boissy" data-context="target">Boissy</button>
                        <button type="button" data-branch="chessy" data-context="target">Chessy</button>
                      </div>
                    </div>
                  </div>
                </div>
                <div id="pkTargetInfo" class="orientation-target-info">
                  Aucun PK cible d√©fini pour le moment.
                </div>
              </div>
            </div>
          </div>

          <div class="card full-width plan-line-card">
            <div class="card-header">
              <div class="card-title">Plan de ligne</div>
            </div>
            <div class="field plan-toggle">
              <label>
                <input id="planBoissyToggle" type="checkbox" />
                Afficher le plan de Boissy
              </label>
              <div id="planBoissyContainer" class="plan-line-container" style="display: none;">
                <div class="pdf-navigation">
                  <button class="pdf-nav-btn pdf-nav-prev" data-pdf="boissy" aria-label="Page pr√©c√©dente">‚Äπ</button>
                  <div class="pdf-page-info">
                    <input type="number" class="pdf-page-input" data-pdf="boissy" min="1" value="1" aria-label="Num√©ro de page">
                    <span class="pdf-page-total" data-pdf="boissy">/ ?</span>
                  </div>
                  <button class="pdf-nav-btn pdf-nav-next" data-pdf="boissy" aria-label="Page suivante">‚Ä∫</button>
                </div>
                <iframe id="planBoissyIframe" class="plan-line-iframe" src="docs/Boissy.pdf#page=1&zoom=page-fit" title="Plan de Boissy" type="application/pdf"></iframe>
              </div>
            </div>
            <div class="field plan-toggle">
              <label>
                <input id="planParisOuestToggle" type="checkbox" />
                Afficher le plan de Paris-Ouest
              </label>
              <div id="planParisOuestContainer" class="plan-line-container" style="display: none;">
                <div class="pdf-navigation">
                  <button class="pdf-nav-btn pdf-nav-prev" data-pdf="parisouest" aria-label="Page pr√©c√©dente">‚Äπ</button>
                  <div class="pdf-page-info">
                    <input type="number" class="pdf-page-input" data-pdf="parisouest" min="1" value="1" aria-label="Num√©ro de page">
                    <span class="pdf-page-total" data-pdf="parisouest">/ ?</span>
                  </div>
                  <button class="pdf-nav-btn pdf-nav-next" data-pdf="parisouest" aria-label="Page suivante">‚Ä∫</button>
                </div>
                <iframe id="planParisOuestIframe" class="plan-line-iframe" src="docs/Paris%20-%20Ouest.pdf#page=1" title="Plan de Paris-Ouest" type="application/pdf"></iframe>
              </div>
            </div>
            <div class="field plan-toggle">
              <label>
                <input id="planChessyToggle" type="checkbox" />
                Afficher le plan de Chessy
              </label>
              <div id="planChessyContainer" class="plan-line-container" style="display: none;">
                <div class="pdf-navigation">
                  <button class="pdf-nav-btn pdf-nav-prev" data-pdf="chessy" aria-label="Page pr√©c√©dente">‚Äπ</button>
                  <div class="pdf-page-info">
                    <input type="number" class="pdf-page-input" data-pdf="chessy" min="1" value="1" aria-label="Num√©ro de page">
                    <span class="pdf-page-total" data-pdf="chessy">/ ?</span>
                  </div>
                  <button class="pdf-nav-btn pdf-nav-next" data-pdf="chessy" aria-label="Page suivante">‚Ä∫</button>
                </div>
                <iframe id="planChessyIframe" class="plan-line-iframe" src="docs/Chessy.pdf#page=1" title="Plan de Chessy" type="application/pdf"></iframe>
              </div>
            </div>
          </div>
         </div>
       </section>
      <section class="tab-panel" data-tab="urgence">
        <h2 class="section-title">Urgence &amp; avaries</h2>
        <div class="app-content">
          <div class="card full-width">
            <div class="card-header">
              <div class="card-title">Urgence &amp; avaries</div>
            </div>
            <div id="smsPreview" class="muted">
              En attente de position GPS pour pr√©parer le SMS.
            </div>
            <div class="field">
              <button id="btnCouvreurSeul" class="btn btn-warning btn-icon" type="button">
                <span>üö∂</span><span>Couvreur cheminant seul</span>
              </button>
              <div id="couvreurStatus" class="muted" style="margin-top: 8px; font-size: 0.9em; display: none;">
                Mode actif : surveillance en cours...
              </div>
            </div>
            <div class="field">
              <button id="btnSms" class="btn btn-danger btn-icon" type="button">
                <span>‚úâÔ∏è</span><span>SMS d'urgence</span>
              </button>
            </div>
          </div>

          <div class="card full-width">
            <div class="card-header">
              <div class="card-title">D√©clarer une avarie / un incident</div>
            </div>
            <div class="signalement-block">
              <label for="selectIncidentType" style="font-weight: 700;">üö® Signalement d'avarie / incident</label>
              <select id="selectIncidentType">
                <option value="">-- Choisir un type d'incident --</option>
                <option value="Cheminement endommag√©">Cheminement endommag√©</option>
                <option value="Rail cass√©">Rail cass√©</option>
                <option value="Animal mort">Animal mort</option>
                <option value="Autre">Autre (saisir ci-dessous)</option>
              </select>
              <div class="field" id="incidentOtherField" style="display:none;">
                <label for="inputIncidentOther">Pr√©cisez l'incident :</label>
                <input id="inputIncidentOther" type="text" placeholder="ex : c√¢ble arrach√©, signal d√©t√©rior√©..." />
              </div>
              <div class="field">
                <label for="incidentPhoto">Photo (optionnel)</label>
                <input id="incidentPhoto" type="file" accept="image/*" />
              </div>
              <div class="branch-choice-control branch-choice-wrapper">
                <span class="branch-choice-label">Branche :</span>
                <div class="branch-choice-menu-container">
                  <button id="btnBranchIncident" type="button" class="branch-choice-button" aria-expanded="false">Tron√ßon central</button>
                  <div id="branchMenuIncident" class="branch-choice-menu" hidden>
                    <button type="button" data-branch="central" data-context="incident">Tron√ßon central</button>
                    <button type="button" data-branch="boissy" data-context="incident">Boissy</button>
                    <button type="button" data-branch="chessy" data-context="incident">Chessy</button>
                  </div>
                </div>
              </div>
              <div class="field">
                <button id="btnGenerateIncident" class="btn btn-good btn-icon" type="button">
                  <span>üì£</span><span>G√©n√©rer le message de signalement</span>
                </button>
              </div>
              <div class="field" id="incidentResultField" style="display:none;">
                <label>Message g√©n√©r√© :</label>
                <textarea id="incidentResultText" rows="4" readonly></textarea>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                  <button id="btnCopyIncident" class="btn btn-secondary btn-icon" type="button">
                    <span>üìã</span><span>Copier le texte</span>
                  </button>
                  <button id="btnAddIncidentToNote" class="btn btn-primary btn-icon" type="button">
                    <span>‚ûï</span><span>Ajouter √† la note</span>
                  </button>
                </div>
              </div>
              <div class="field" id="incidentsListField" style="display:none; margin-top: 16px;">
                <label>Avaries enregistr√©es dans la note :</label>
                <div id="incidentsList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 8px; background: var(--card); margin-top: 8px;"></div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                  <button id="btnExportIncidentsNote" class="btn btn-good btn-icon" type="button">
                    <span>üìù</span><span>Exporter la note</span>
                  </button>
                  <button id="btnClearIncidents" class="btn btn-warning btn-icon" type="button">
                    <span>üóëÔ∏è</span><span>Effacer la liste</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="tab-panel" data-tab="recherche">
        <h2 class="section-title">Calcul &amp; recherche PK</h2>
        <div class="app-content">
          <div class="card full-width">
            <div class="card-header">
              <div class="card-title">Recherche PK, rues & acc√®s</div>
            </div>
            <div class="field">
              <label for="inputPkLookup">Recherche par PK et GPS (acc√®s le plus proche)</label>
              <input id="inputPkLookup" type="text" placeholder="ex : 32400 ou 32+400" autocomplete="off" />
              <div class="branch-choice-control branch-choice-wrapper">
                <span class="branch-choice-label">Branche :</span>
                <div class="branch-choice-menu-container">
                  <button id="btnBranchSearch" type="button" class="branch-choice-button" aria-expanded="false">Tron√ßon central</button>
                  <div id="branchMenuSearch" class="branch-choice-menu" hidden>
                    <button type="button" data-branch="central" data-context="search">Tron√ßon central</button>
                    <button type="button" data-branch="boissy" data-context="search">Boissy</button>
                    <button type="button" data-branch="chessy" data-context="search">Chessy</button>
                  </div>
                </div>
              </div>
              <button id="btnPkLookup" class="btn btn-secondary btn-icon" type="button">
                <span>üîé</span><span>Rechercher</span>
              </button>
            </div>
            <div class="field" id="pkLookupResultField" style="display:none;">
              <div id="pkLookupResult" class="muted"></div>
              <div class="field">
                <button id="btnPkLookupOpenMaps" class="btn btn-primary btn-icon" type="button">
                  <span>üìç</span><span>Google Maps</span>
                </button>
                <button id="btnPkLookupOpenWaze" class="btn btn-secondary btn-icon" type="button">
                  <span>üöó</span><span>Waze</span>
                </button>
              </div>
            </div>
          </div>

          <div class="card full-width">
            <div class="card-header">
              <div class="card-title">üö¶ Calculer rouges & p√©tards</div>
            </div>
            <div class="field">
              <label for="inputCoveragePkStart">PK d√©but chantier (m)</label>
              <input id="inputCoveragePkStart" type="number" placeholder="ex : 48000" />
            </div>
            <div class="field">
              <label for="inputCoveragePkEnd">PK fin chantier (m)</label>
              <input id="inputCoveragePkEnd" type="number" placeholder="ex : 49000" />
            </div>
            <div class="branch-choice-control branch-choice-wrapper">
              <span class="branch-choice-label">Branche :</span>
              <div class="branch-choice-menu-container">
                <button id="btnBranchCoverage" type="button" class="branch-choice-button" aria-expanded="false">Tron√ßon central</button>
                <div id="branchMenuCoverage" class="branch-choice-menu" hidden>
                  <button type="button" data-branch="central" data-context="coverage">Tron√ßon central</button>
                  <button type="button" data-branch="boissy" data-context="coverage">Boissy</button>
                  <button type="button" data-branch="chessy" data-context="coverage">Chessy</button>
                </div>
              </div>
            </div>
            <div class="field" style="display:flex; gap:10px; flex-wrap:wrap;">
              <button id="btnComputeCoverage" class="btn btn-primary btn-icon" type="button">
                <span>üö¶</span><span>Calculer rouges & p√©tards</span>
              </button>
              <button id="btnClearCoverage" class="btn btn-secondary" type="button" style="display: none;">
                Effacer les marqueurs
              </button>
            </div>
            <div class="field coverage-guide-toggle">
              <label for="toggleCoverageGuide">
                <input id="toggleCoverageGuide" type="checkbox" />
                Consulter le mode op√©ratoire
              </label>
            </div>
            <div id="coverageGuide" class="coverage-guide" aria-live="polite">
              <p style="margin: 0 0 12px; padding: 10px; background: rgba(255, 193, 7, 0.15); border-left: 3px solid #ffc107; border-radius: 4px; color: #ffc107;">
                <strong>‚ö†Ô∏è Avertissement :</strong><br />
                Le calcul des rouges et des p√©tards fourni par l'application n'est valable que dans le cas d'une couverture simple, c'est-√†-dire une ligne compos√©e de deux voies uniques sans autre voie adjacente ou voie d'embranchement pouvant entrer dans la zone de travail.<br /><br />
                Avant toute mise en place r√©elle sur le terrain, v√©rifiez obligatoirement la configuration exacte sur le plan (onglet Map) pour confirmer qu'il n'existe aucune voie suppl√©mentaire, voie bis, tiroir, voie de service ou embranchement n√©cessitant une couverture renforc√©e.
              </p>
              <p style="margin: 0 0 8px;">Mode op√©ratoire :</p>
              <ul>
                <li>Signal de rep√©rage : signal √† main d'arr√™t + 1 p√©tard positionn√©s √† 100&nbsp;m de chaque extr√©mit√© du chantier.</li>
                <li>P√©tards d'annonce : 3 p√©tards √† 800&nbsp;m (ou 1000&nbsp;m entre Torcy PK&nbsp;48,000 et Marne-la-Vall√©e‚ÄìChessy), altern√©s tous les 30&nbsp;m sur chaque file de rail.</li>
              </ul>
              <p style="margin: 8px 0 0;">Indique le PK d√©but, le PK fin ou les deux pour g√©n√©rer les points pr√©cis et les afficher sur la carte.</p>
            </div>
            <div class="field" style="margin-top: 15px;">
              <label style="font-weight: 600; margin-bottom: 8px;">R√©sultats du calcul :</label>
              <div id="coverageResultsLine" style="padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1); color: #fff; min-height: 40px; display: flex; align-items: center;">
                <span style="color: rgba(255, 255, 255, 0.5);">Cliquez sur ¬´ Calculer rouges & p√©tards ¬ª pour voir les r√©sultats</span>
              </div>
            </div>
            <div id="coverageResult" class="field" style="display: none; margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
              <div id="coverageResultText" style="color: #fff; line-height: 1.6;"></div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-tab="fermetures">
        <h2 class="section-title">Fermetures nocturnes</h2>
        <div class="app-content">
          <div id="fermeturesNocturnesCard" class="card full-width">
            <div class="card-header">
              <div class="card-title">Fermetures nocturnes</div>
            </div>
            <div id="fermeturesNocturnesContent" style="padding: 16px; line-height: 1.8; color: var(--text);">
              <!-- Le contenu sera g√©n√©r√© par JavaScript -->
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-tab="settings">
        <h2 class="section-title">Param√®tres & outils</h2>
        <div class="app-content">
          <div id="settingsPanel" class="card card-soft full-width">
            <div class="card-header"></div>
            <div class="divider"></div>
            <div class="sensitivity-section">
              <div class="field">
                <label for="selectSensitivity">Sensibilit√© au mouvement</label>
                <select id="selectSensitivity">
                  <option value="slow">Marche lente</option>
                  <option value="normal">Normal</option>
                  <option value="train">Train</option>
                </select>
                <div class="muted">¬´ Marche lente ¬ª d√©tecte plus facilement un d√©placement √† pied.</div>
              </div>
            </div>
            <div class="divider"></div>
            <div class="pk-calibration-section">
              <div class="field">
                <label>Recalage PK</label>
                <div id="pkOffsetInfo" class="muted">D√©calage global : 0 m. Corrections locales enregistr√©es : 0.</div>
              </div>
              <div class="field">
                <label>Position PK estim√©e (lecture seule)</label>
                <div id="pkEstimateText" class="muted">En attente de position GPS‚Ä¶</div>
              </div>
              <div class="field">
                <label for="inputPkRecal">PK exact ici (pour recaler l'appli)</label>
                <input id="inputPkRecal" type="text" placeholder="ex : 52700 ou 52+700" />
                <div class="branch-choice-control branch-choice-wrapper">
                  <span class="branch-choice-label">Branche :</span>
                  <div class="branch-choice-menu-container">
                    <button id="btnBranchRecal" type="button" class="branch-choice-button" aria-expanded="false">Tron√ßon central</button>
                    <div id="branchMenuRecal" class="branch-choice-menu" hidden>
                      <button type="button" data-branch="central" data-context="recal">Tron√ßon central</button>
                      <button type="button" data-branch="boissy" data-context="recal">Boissy</button>
                      <button type="button" data-branch="chessy" data-context="recal">Chessy</button>
                    </div>
                  </div>
                </div>
                <button id="btnApplyRecal" class="btn btn-primary" type="button">Pr√©visualiser le recalage</button>
              </div>
              <div class="field recal-preview" id="recalPreview" style="display:none;">
                <label>Aper√ßu du recalage</label>
                <div class="recal-preview-content">
                  PK estim√© actuel : <span id="recalPreviewCurrent">‚Äî</span><br />
                  PK cible (saisi) : <span id="recalPreviewNew">‚Äî</span><br />
                  Branche appliqu√©e : <span id="recalPreviewBranch">‚Äî</span>
                </div>
                <div class="recal-preview-actions">
                  <button id="btnConfirmRecal" class="btn btn-primary" type="button">Confirmer</button>
                  <button id="btnCancelRecal" class="btn btn-secondary" type="button">Annuler</button>
                </div>
              </div>
              <div class="field">
                <button id="btnUndoRecal" class="btn btn-secondary" type="button" style="display:none;">
                  Annuler le dernier recalage
                </button>
              </div>
              <div class="field">
                <div id="recalMessages" class="recal-messages muted"></div>
              </div>
              <div class="field">
                <div id="recalHistoryList" class="recal-history-list muted"></div>
              </div>
              <div class="field">
                <button id="btnResetOffset" class="btn btn-secondary" type="button">
                  R√©initialiser le recalage PK
                </button>
              </div>
              <div class="field">
                <button id="btnExportCalibrations" class="btn btn-secondary btn-icon" type="button">
                  <span>üì§</span><span>Exporter mes recalages (JSON)</span>
                </button>
                <div class="muted">
                  Exporte les recalages que tu as faits (PK exact + GPS) pour les d√©poser ensuite dans GitHub.
                </div>
              </div>
            </div>
            <div class="divider"></div>
            <div class="pk-calibration-section">
              <div class="field">
                <label>Points de carte</label>
                <div id="mapPointsInfo" class="muted">Aucun point enregistr√©.</div>
              </div>
              <div class="field">
                <label for="inputMapPointDescription">Description du point</label>
                <textarea id="inputMapPointDescription" rows="3" placeholder="Ex: Acc√®s, clef VCC, etc."></textarea>
              </div>
              <div class="field">
                <button id="btnNoteLocation" class="btn btn-primary" type="button">Enregistrer l'emplacement</button>
                <div class="muted">
                  Enregistre ta position GPS actuelle avec la description et le PK.
                </div>
              </div>
              <div class="field">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                  <button id="btnExportMapPoints" class="btn btn-secondary btn-icon" type="button">
                    <span>üì§</span><span>Exporter (JSON)</span>
                  </button>
                  <button id="btnExportMapPointsNote" class="btn btn-secondary btn-icon" type="button">
                    <span>üìù</span><span>Exporter (Note)</span>
                  </button>
                </div>
                <div class="muted" style="margin-top: 8px;">
                  Exporte tous les points enregistr√©s : JSON pour GitHub, Note pour un format texte lisible.
                </div>
              </div>
            </div>
            <div class="divider"></div>
            <div class="field">
              <label for="inputSosPhone">Num√©ro SOS pour le SMS d'urgence</label>
              <input id="inputSosPhone" type="tel" placeholder="ex : 0612345678 ou +33612345678" />
              <div style="margin-top: 8px;">
                <button id="btnSavePhone" class="btn btn-primary btn-icon" type="button">
                  <span>üíæ</span><span>Sauvegarder</span>
                </button>
              </div>
              <div class="muted">Ce num√©ro sera utilis√© par le bouton ¬´ SMS d'urgence ¬ª.</div>
            </div>
            <div class="divider"></div>
            <div class="field">
              <button id="btnReadme" class="btn btn-secondary btn-icon" type="button">
                <span>üìñ</span><span>Tutoriel</span>
              </button>
            </div>
            <div id="readmePanel" class="card" style="display: none; margin-top: 15px;">
              <div class="card-header">
                <div class="card-title">üìñ Tutoriel - Guide d'utilisation</div>
              </div>
              <div id="readmeContent" style="padding: 16px; line-height: 1.8; color: var(--text);">
                <!-- Le contenu sera g√©n√©r√© par JavaScript -->
              </div>
              <div class="field" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                <button id="btnCloseReadme" class="btn btn-secondary" type="button">
                  Fermer
                </button>
              </div>
            </div>
            <div class="settings-footer">
              Ces r√©glages restent stock√©s dans ton navigateur (localStorage).
              Ils ne sont pas effac√©s quand on met √† jour l'application.
            </div>
          </div>
        </div>
      </section>

    </div>

    <nav class="tabbar" id="appTabBar" role="tablist">
      <button class="tab-button tab-button--status is-active" type="button" data-tab-target="status" aria-label="Statut" title="Statut">
        <span class="tab-icon" aria-hidden="true">üì°</span>
        <span class="tab-label" aria-hidden="true">Statut</span>
      </button>
      <button class="tab-button tab-button--plan" type="button" data-tab-target="plan" aria-label="Plan / Orientation" title="Plan / Orientation">
        <span class="tab-icon" aria-hidden="true">üó∫Ô∏è</span>
        <span class="tab-label" aria-hidden="true">Plan / Orientation</span>
      </button>
      <button class="tab-button tab-button--urgence" type="button" data-tab-target="urgence" aria-label="Urgence & avaries" title="Urgence & avaries">
        <span class="tab-icon" aria-hidden="true">üö®</span>
        <span class="tab-label" aria-hidden="true">Urgence &amp; avaries</span>
      </button>
      <button class="tab-button tab-button--recherche" type="button" data-tab-target="recherche" aria-label="Calcul & recherche PK" title="Calcul & recherche PK">
        <span class="tab-icon" aria-hidden="true">üîç</span>
        <span class="tab-label" aria-hidden="true">Calcul &amp; Recherche PK</span>
      </button>
      <button class="tab-button tab-button--fermetures" type="button" data-tab-target="fermetures" aria-label="Fermetures nocturnes" title="Fermetures nocturnes">
        <span class="tab-icon" aria-hidden="true">üåô</span>
        <span class="tab-label" aria-hidden="true">Fermetures nocturnes</span>
      </button>
      <button class="tab-button tab-button--settings" type="button" data-tab-target="settings" aria-label="Param√®tres & outils" title="Param√®tres & outils">
        <span class="tab-icon" aria-hidden="true">‚öôÔ∏è</span>
        <span class="tab-label" aria-hidden="true">Param√®tres &amp; outils</span>
      </button>
    </nav>
   </div>

  <script src="config/access-config.js" onerror="console.log('Fichier access-config.js non trouv√©, utilisation du code par d√©faut.')"></script>

  <script>

    const ACTIVE_TAB_KEY = "pkAssistantActiveTab";

    const ACCESS_CODE_KEY = "pkAssistantAccessGranted";
    const ACCESS_LAST_USED_CODE_KEY = "lastUsedCode";
    const ACCESS_CODE = typeof window !== "undefined" && typeof window.__PK_ACCESS_CODE__ === "string"
      ? window.__PK_ACCESS_CODE__
      : "3615"; // Code par d√©faut si non configur√©

  // === DONN√âES DE LIGNE AVEC BIFURCATION ================================

  const troncCommun = [
    { name: "St-Germain-en-Laye",          lat: 48.8984745677, lon: 2.0946251970, pk: 125, pkStart: 0, pkEnd: 250 }, // Vers Vincennes / Vers St-Germain
    { name: "Le V√©sinet ‚Äì Le Pecq",        lat: 48.8984530458, lon: 2.1222846835, pk: 2625, pkStart: 2500, pkEnd: 2750 }, // Vers Vincennes / Vers St-Germain
    { name: "Le V√©sinet ‚Äì Centre",         lat: 48.8901555110, lon: 2.1347027835, pk: 3900, pkStart: 3800, pkEnd: 4000 }, // Vers Vincennes / Vers St-Germain
    { name: "Chatou ‚Äì Croissy",            lat: 48.8854638305, lon: 2.1564040970, pk: 5600, pkStart: 5500, pkEnd: 5700 }, // Vers Vincennes / Vers St-Germain
    { name: "Rueil-Malmaison",             lat: 48.8877403423, lon: 2.1725468932, pk: 6850, pkStart: 6700, pkEnd: 7000 }, // Vers Vincennes / Vers St-Germain
    { name: "Nanterre-Ville",              lat: 48.8952086355, lon: 2.1957210472, pk: 8725, pkStart: 8600, pkEnd: 8850 }, // Vers Vincennes / Vers St-Germain
    { name: "Nanterre-Universit√©",         lat: 48.9009541230, lon: 2.2128683712, pk: 10200, pkStart: 10100, pkEnd: 10300 }, // Vers Vincennes / Vers St-Germain
    { name: "Nanterre-Pr√©fecture",        lat: 48.8958449352, lon: 2.2230702306, pk: 11750, pkStart: 11650, pkEnd: 11850 }, // Vers Vincennes / Vers St-Germain
    { name: "La D√©fense ‚Äì Grande Arche",   lat: 48.8919045058, lon: 2.2385616258, pk: 13100, pkStart: 13000, pkEnd: 13200 }, // Vers Vincennes / Vers St-Germain
    { name: "Charles-de-Gaulle ‚Äì √âtoile",  lat: 48.8742900059, lon: 2.2948848393, pk: 17650, pkStart: 17500, pkEnd: 17800 }, // Vers Vincennes / Vers St-Germain
    { name: "Auber",                       lat: 48.8725358497, lon: 2.3298119681, pk: 20300, pkStart: 20200, pkEnd: 20400 }, // Vers Vincennes / Vers St-Germain
    { name: "Ch√¢telet ‚Äì Les Halles",       lat: 48.8619752528, lon: 2.3469363528, pk: 22200, pkStart: 22100, pkEnd: 22300 }, // Vers Vincennes / Vers St-Germain
    { name: "Gare de Lyon",                lat: 48.8444873499, lon: 2.3743558393, pk: 25000, pkStart: 24900, pkEnd: 25100 }, // Vers Vincennes / Vers St-Germain
    { name: "Nation",                      lat: 48.8488218026, lon: 2.3970239229, pk: 27000, pkStart: 26900, pkEnd: 27100 }, // Vers Vincennes / Vers St-Germain
    { name: "Vincennes",                   lat: 48.8475419027, lon: 2.4332766909, pk: 30000, pkStart: 29900, pkEnd: 30100 } // Vers Vincennes / Vers St-Germain
  ];

  // Branche Boissy : PK relatifs depuis 6500, convertis en absolus
  // Formule : PK absolu = 31500 (fourche) + (PK relatif - 6500)
  // Exemple : PK relatif 7750 ‚Üí PK absolu = 31500 + (7750 - 6500) = 31500 + 1250 = 32750
  const BOISSY_BRANCH_OFFSET = 31500; // Point de fourche apr√®s Vincennes
  const BOISSY_PK_START = 6500; // PK relatif de d√©part de la branche Boissy
  
  const brancheBoissy = [
    { name: "Fontenay-sous-Bois",          lat: 48.84448287866945, lon: 2.464306353806553, pk: 32750, pkStart: 32750, pkEnd: 32500 }, // PK relatif 7750 ‚Üí absolu 32750, 7500 ‚Üí 32500
    { name: "Nogent-sur-Marne",            lat: 48.8353972244, lon: 2.4716593319, pk: 34000, pkStart: 34000, pkEnd: 33700 }, // PK relatif 9000 ‚Üí absolu 34000, 8700 ‚Üí 33700
    { name: "Joinville-le-Pont",           lat: 48.8211820545, lon: 2.4641431755, pk: 35600, pkStart: 35600, pkEnd: 35300 }, // PK relatif 10600 ‚Üí absolu 35600, 10300 ‚Üí 35300
    { name: "Saint-Maur ‚Äì Cr√©teil",        lat: 48.8088207060, lon: 2.4708026167, pk: 37500, pkStart: 37500, pkEnd: 37200 }, // PK relatif 12500 ‚Üí absolu 37500, 12200 ‚Üí 37200
    { name: "Parc de Saint-Maur",           lat: null, lon: null, pk: 38500, pkStart: 38500, pkEnd: 38250 }, // PK relatif 13500 ‚Üí absolu 38500, 13250 ‚Üí 38250
    { name: "Champigny",                   lat: null, lon: null, pk: 40300, pkStart: 40300, pkEnd: 40100 }, // PK relatif 15300 ‚Üí absolu 40300, 15100 ‚Üí 40100
    { name: "La Varenne ‚Äì Chennevi√®res",   lat: 48.7941968899, lon: 2.5135124577, pk: 41800, pkStart: 41800, pkEnd: 41500 }, // PK relatif 16800 ‚Üí absolu 41800, 16500 ‚Üí 41500
    { name: "Sucy ‚Äì Bonneuil",             lat: 48.7709911746, lon: 2.5083777258, pk: 44500, pkStart: 44500, pkEnd: 44200 }, // PK relatif 19500 ‚Üí absolu 44500, 19200 ‚Üí 44200
    { name: "Boissy-Saint-L√©ger",          lat: 48.7539872386, lon: 2.5059802969, pk: 47200, pkStart: 47200, pkEnd: 46900 } // PK relatif 22200 ‚Üí absolu 47200, 21900 ‚Üí 46900
  ];

  const brancheChessy = [
    { name: "Val de Fontenay",             lat: 48.8544183594, lon: 2.4890884591, pk: 34525, pkStart: 34650, pkEnd: 34400 }, // Direction Chessy / Vers Paris
    { name: "Neuilly-Plaisance",           lat: 48.8534646981, lon: 2.5138398779, pk: 36750, pkStart: 36900, pkEnd: 36600 }, // Direction Chessy / Vers Paris
    { name: "Bry-sur-Marne",               lat: 48.8442657465, lon: 2.5261924528, pk: 37950, pkStart: 38100, pkEnd: 37800 }, // Direction Chessy / Vers Paris
    { name: "Noisy-le-Grand ‚Äì Mont d'Est", lat: 48.8410135149, lon: 2.5527359297, pk: 39850, pkStart: 40000, pkEnd: 39700 }, // Direction Chessy / Vers Paris
    { name: "Noisy ‚Äì Champs",              lat: 48.8429502416, lon: 2.5788366796, pk: 42150, pkStart: 42300, pkEnd: 42000 }, // Direction Chessy / Vers Paris
    { name: "Noisiel",                     lat: 48.8437650426, lon: 2.6160790153, pk: 44850, pkStart: 45000, pkEnd: 44700 }, // Direction Chessy / Vers Paris
    { name: "Lognes",                      lat: 48.8393611271, lon: 2.6335250335, pk: 46225, pkStart: 46350, pkEnd: 46100 }, // Direction Chessy / Vers Paris
    { name: "Torcy",                       lat: 48.8390276009, lon: 2.6550584298, pk: 47875, pkStart: 48000, pkEnd: 47750 }, // Direction Chessy / Vers Paris
    { name: "Bussy-Saint-Georges",         lat: 48.8371826388, lon: 2.7125386010, pk: 52200, pkStart: 52300, pkEnd: 52100 }, // Direction Chessy / Vers Paris
    { name: "Val d'Europe",                lat: 48.8561684149, lon: 2.7738274672, pk: 57250, pkStart: 57400, pkEnd: 57100 }, // Direction Chessy / Vers Paris
    { name: "Marne-la-Vall√©e ‚Äì Chessy",    lat: 48.8707237150, lon: 2.7826307507, pk: 59150, pkStart: 59000, pkEnd: 59300 } // Direction Chessy / Vers Paris (invers√© : vers Paris est plus grand)
  ];
  // Tous les points de gare (pour recherche la plus proche, tri, etc.)
  const stations = troncCommun.concat(brancheBoissy, brancheChessy);

  // Pour les acc√®s : un acc√®s par gare pour l'instant
const accessPoints = [
  {
    name: "Gare de St Germain en Laye",
    address: "Gare de St Germain en Laye",
    pk: 0,
    lat: 48.90389600,
    lon: 2.10413400
  },
  {
    name: "¬´ P√®re Igor ¬ª, 39 all√©e de la capitainerie / all√©e des gas Le Pecq",
    address: "¬´ P√®re Igor ¬ª, 39 all√©e de la capitainerie / all√©e des gas Le Pecq",
    pk: 1050,
    lat: 48.90389410,
    lon: 2.10404180
  },
  {
    name: "Entre le 8 et le 10 all√©e des berceaux, Le Pecq (Acc√®s difficile)",
    address: "Entre le 8 et le 10 all√©e des berceaux, Le Pecq (Acc√®s difficile)",
    pk: 1100,
    lat: 48.90419444,
    lon: 2.10502778
  },
  {
    name: "1 all√©e des Gas (acc√®s difficile), Le Pecq",
    address: "1 all√©e des Gas (acc√®s difficile), Le Pecq",
    pk: 1200,
    lat: 48.90389890,
    lon: 2.10613190
  },
  {
    name: "21 bvd Folke Bernadotte, Le Pecq (2 acc√®s chaque c√¥t√© du pont RER)",
    address: "21 bvd Folke Bernadotte, Le Pecq (2 acc√®s chaque c√¥t√© du pont RER)",
    pk: 1750,
    lat: 48.90280760,
    lon: 2.11312440
  },
  {
    name: "47 av. du centre (fin de route, cul-de-sac), Le Pecq",
    address: "47 av. du centre (fin de route, cul-de-sac), Le Pecq",
    pk: 1800,
    lat: 48.90266080,
    lon: 2.11381940
  },
  {
    name: "63 route de Sartrouville, Le Pecq / 31 rue de Seine, Le V√©sinet (de chaque c√¥t√© du pont)",
    address: "63 route de Sartrouville, Le Pecq / 31 rue de Seine, Le V√©sinet (de chaque c√¥t√© du pont)",
    pk: 1855,
    lat: 48.90248620,
    lon: 2.11445710
  },
  {
    name: "23 rue de seine, Le Vesinet",
    address: "23 rue de seine, Le Vesinet",
    pk: 1950,
    lat: 48.90208930,
    lon: 2.11583780
  },
  {
    name: "5 ter rue de seine, Le Vesinet",
    address: "5 ter rue de seine, Le Vesinet",
    pk: 2300,
    lat: 48.90016667,
    lon: 2.11961111
  },
  {
    name: "Sq. Watteau, Le V√©sinet",
    address: "Sq. Watteau, Le V√©sinet",
    pk: 2365,
    lat: 48.89975000,
    lon: 2.12088889
  },
  {
    name: "Gare de Le Vesinet-Le Pecq",
    address: "Gare de Le Vesinet-Le Pecq",
    pk: 2505,
    lat: null,
    lon: null
  },
  {
    name: "Le Vesinet PR, 8 rue Alexandre Dumas, Le Vesinet (grand portail)",
    address: "Le Vesinet PR, 8 rue Alexandre Dumas, Le Vesinet (grand portail)",
    pk: 2750,
    lat: 48.89669444,
    lon: 2.12341667
  },
  {
    name: "100 av. Gallieni, Le V√©sinet",
    address: "100 av. Gallieni, Le V√©sinet",
    pk: 3100,
    lat: null,
    lon: null
  },
  {
    name: "54 av. Galli√©ni, 77 av. Emile Thi√©bault, Le V√©sinet",
    address: "54 av. Galli√©ni, 77 av. Emile Thi√©bault, Le V√©sinet",
    pk: 3460,
    lat: 48.89200130,
    lon: 2.12871240
  },
  {
    name: "32 av. Galli√©ni, Le V√©sinet",
    address: "32 av. Galli√©ni, Le V√©sinet",
    pk: 3750,
    lat: 48.89094210,
    lon: 2.13186570
  },
  {
    name: "Bout de quai de V√©sinet Centre, 61 av. Emile Thi√©bault, Le V√©sinet",
    address: "Bout de quai de V√©sinet Centre, 61 av. Emile Thi√©bault, Le V√©sinet",
    pk: 3808,
    lat: 48.89060440,
    lon: 2.13286440
  },
  {
    name: "Gare de Le V√©sinet Centre (c√¥t√© V2 : 53 av. Maurice Berteaux, Le V√©sinet)",
    address: "Gare de Le V√©sinet Centre (c√¥t√© V2 : 53 av. Maurice Berteaux, Le V√©sinet)",
    pk: 3808,
    lat: null,
    lon: null
  },
  {
    name: "Parking au croisement de av. Galli√©ni et rue Du Gal Clavery, Le V√©sinet",
    address: "Parking au croisement de av. Galli√©ni et rue Du Gal Clavery, Le V√©sinet",
    pk: 4060,
    lat: 48.88966667,
    lon: 2.13625000
  },
  {
    name: "27 av. du Gal De Gaulle, Le V√©sinet",
    address: "27 av. du Gal De Gaulle, Le V√©sinet",
    pk: 4150,
    lat: 48.88910410,
    lon: 2.13773730
  },
  {
    name: "2 bvd des √âtats-Unis, Le V√©sinet",
    address: "2 bvd des √âtats-Unis, Le V√©sinet",
    pk: 4400,
    lat: 48.88791667,
    lon: 2.14166667
  },
  {
    name: "25 av. Maurice Bertaux, Le V√©sinet",
    address: "25 av. Maurice Bertaux, Le V√©sinet",
    pk: 4500,
    lat: 48.88808333,
    lon: 2.14105556
  },
  {
    name: "29 avenue Charles Lambert, Ch√¢tou",
    address: "29 avenue Charles Lambert, Ch√¢tou",
    pk: 4890,
    lat: 48.88650000,
    lon: 2.14630556
  },
  {
    name: "5 av. Charles Lambert, Ch√¢tou",
    address: "5 av. Charles Lambert, Ch√¢tou",
    pk: 5100,
    lat: 48.88593117,
    lon: 2.14874668
  },
  {
    name: "25 av. du Mar√©chal Joffre, Ch√¢tou",
    address: "25 av. du Mar√©chal Joffre, Ch√¢tou",
    pk: 5250,
    lat: 48.88558159,
    lon: 2.15111261
  },
  {
    name: "Gare de Ch√¢tou ‚Äì Croissy",
    address: "Gare de Ch√¢tou ‚Äì Croissy",
    pk: 5502,
    lat: null,
    lon: null
  },
  {
    name: "Bout de quai V2 c√¥t√© Paris : 2 av des Tilleuls, Ch√¢tou (fond de l'impasse)",
    address: "Bout de quai V2 c√¥t√© Paris : 2 av des Tilleuls, Ch√¢tou (fond de l'impasse)",
    pk: 5727,
    lat: 48.88516352,
    lon: 2.15757085
  },
  {
    name: "Mail des impressionnistes, Chatou (√éle de Chatou,",
    address: "Mail des impressionnistes, Chatou (√éle de Chatou,",
    pk: 5950,
    lat: 48.88522222,
    lon: 2.16013889
  },
  {
    name: "Mail des impressionnistes, Chatou (√éle de Chatou,",
    address: "Mail des impressionnistes, Chatou (√éle de Chatou,",
    pk: 6070,
    lat: 48.88547222,
    lon: 2.16219444
  },
  {
    name: "38 rue des Martinets, Rueil-Malmaison / 19 av. de Seine, Rueil-Malmaison",
    address: "38 rue des Martinets, Rueil-Malmaison / 19 av. de Seine, Rueil-Malmaison",
    pk: 6250,
    lat: 48.88586272,
    lon: 2.16488900
  },
  {
    name: "27 av. de Seine, Rueil Malmaison",
    address: "27 av. de Seine, Rueil Malmaison",
    pk: 6430,
    lat: null,
    lon: null
  },
  {
    name: "PR de Rueil, Avenue de Colmar, Rueil-Malmaison",
    address: "PR de Rueil, Avenue de Colmar, Rueil-Malmaison",
    pk: 6570,
    lat: 48.88666667,
    lon: 2.16883333
  },
  {
    name: "Gare de Rueil-Malmaison, 2 rue des 2 gares, Rueil-Malmaison",
    address: "Gare de Rueil-Malmaison, 2 rue des 2 gares, Rueil-Malmaison",
    pk: 6758,
    lat: null,
    lon: null
  },
  {
    name: "Faisceau de Rueil, 143 bvd National, Rueil-Malmaison",
    address: "Faisceau de Rueil, 143 bvd National, Rueil-Malmaison",
    pk: 7500,
    lat: 48.89034072,
    lon: 2.17954308
  },
  {
    name: "CAT Nanterre (acc√®s par badge), 33 av. Henri Martin, Nanterre",
    address: "CAT Nanterre (acc√®s par badge), 33 av. Henri Martin, Nanterre",
    pk: 8250,
    lat: 48.89291667,
    lon: 2.18800000
  },
  {
    name: "Croisement 55 rue de Stalingrad / 57 bvd du Couchant, Nanterre",
    address: "Croisement 55 rue de Stalingrad / 57 bvd du Couchant, Nanterre",
    pk: 8500,
    lat: 48.89447222,
    lon: 2.19358333
  },
  {
    name: "Gare de Nanterre Ville",
    address: "Gare de Nanterre Ville",
    pk: 8600,
    lat: null,
    lon: null
  },
  {
    name: "10 all√©e des Parfumeurs (fond de l'impasse), Nanterre (Parking difficile)",
    address: "10 all√©e des Parfumeurs (fond de l'impasse), Nanterre (Parking difficile)",
    pk: 9000,
    lat: 48.89619076,
    lon: 2.19848833
  },
  {
    name: "Rd-pt 56 rue Pascal / 1 rue Paul Bert, Nanterre",
    address: "Rd-pt 56 rue Pascal / 1 rue Paul Bert, Nanterre",
    pk: 9200,
    lat: 48.89711102,
    lon: 2.20139055
  },
  {
    name: "Cabane des signaux, 94 rue Pascal Nanterre",
    address: "Cabane des signaux, 94 rue Pascal Nanterre",
    pk: 9400,
    lat: 48.89805290,
    lon: 2.20437687
  },
  {
    name: "118 rue Pascal Nanterre",
    address: "118 rue Pascal Nanterre",
    pk: 9650,
    lat: 48.89871930,
    lon: 2.20627078
  },
  {
    name: "Passerelle Nanterre-Ville (2 acc√®s de chaque c√¥t√© de la passerelle), bvd Blaise Pascal, face au 1 all√©e Georges Courteline, Nanterre",
    address: "Passerelle Nanterre-Ville (2 acc√®s de chaque c√¥t√© de la passerelle), bvd Blaise Pascal, face au 1 all√©e Georges Courteline, Nanterre",
    pk: 9800,
    lat: 48.89956965,
    lon: 2.20894508
  },
  {
    name: "1C / 2C (branche Cergy) (2 acc√®s de chaque c√¥t√© du pont), 83 bvd des Provinces Fran√ßaises, Nanterre",
    address: "1C / 2C (branche Cergy) (2 acc√®s de chaque c√¥t√© du pont), 83 bvd des Provinces Fran√ßaises, Nanterre",
    pk: 10050,
    lat: 48.89977146,
    lon: 2.21360501
  },
  {
    name: "Gare de Nanterre Universit√©",
    address: "Gare de Nanterre Universit√©",
    pk: 10111,
    lat: null,
    lon: null
  },
  {
    name: "Courbe de la Folie, Croisement 521 Bd des Provinces Fran√ßaises / all√©e d'Aquitaine, Nanterre",
    address: "Courbe de la Folie, Croisement 521 Bd des Provinces Fran√ßaises / all√©e d'Aquitaine, Nanterre",
    pk: 10450,
    lat: 48.90204234,
    lon: 2.21802275
  },
  {
    name: "Gare de Nanterre Pr√©fecture",
    address: "Gare de Nanterre Pr√©fecture",
    pk: 11638,
    lat: null,
    lon: null
  },
  {
    name: "ADV 710 / 712 : passage par √©chelle au niveau de la baie de ventilation",
    address: "ADV 710 / 712 : passage par √©chelle au niveau de la baie de ventilation",
    pk: 12100,
    lat: null,
    lon: null
  },
  {
    name: "Baie de ventilation, 26 rue des Longues Raies, Nanterre (acc√®s avec la PP)",
    address: "Baie de ventilation, 26 rue des Longues Raies, Nanterre (acc√®s avec la PP)",
    pk: 12430,
    lat: null,
    lon: null
  },
  {
    name: "Bout de VA / VB √† D√©fense",
    address: "Bout de VA / VB √† D√©fense",
    pk: 12650,
    lat: null,
    lon: null
  },
  {
    name: "Passage V2 / VB √† D√©fense",
    address: "Passage V2 / VB √† D√©fense",
    pk: 12730,
    lat: null,
    lon: null
  },
  {
    name: "Gare de La D√©fense",
    address: "Gare de La D√©fense",
    pk: 12990,
    lat: null,
    lon: null
  },
  {
    name: "Aire de stockage VA / VB de D√©fense",
    address: "Aire de stockage VA / VB de D√©fense",
    pk: 13280,
    lat: null,
    lon: null
  },
  {
    name: "Musoir de D√©fense >‚Äì",
    address: "Musoir de D√©fense >‚Äì",
    pk: 13420,
    lat: null,
    lon: null
  },
  {
    name: "Pont de Neuilly, 191 av. Ch. De Gaulle, Neuilly via la station de m√©tro Pont de Neuilly (milieu de Quai dir. Ch√¢teau de Vincennes)",
    address: "Pont de Neuilly, 191 av. Ch. De Gaulle, Neuilly via la station de m√©tro Pont de Neuilly (milieu de Quai dir. Ch√¢teau de Vincennes)",
    pk: 14934,
    lat: 48.88446330,
    lon: 2.26128519
  },
  {
    name: "Nordling, Place Nordling, Neuilly sur Seine (entr√©e face au 5 rue Raoul Nordling)",
    address: "Nordling, Place Nordling, Neuilly sur Seine (entr√©e face au 5 rue Raoul Nordling)",
    pk: 16350,
    lat: null,
    lon: null
  },
  {
    name: "Gare de Charles De Gaulle - √âtoile",
    address: "Gare de Charles De Gaulle - √âtoile",
    pk: 17563,
    lat: null,
    lon: null
  },
  {
    name: "Acc√®s pompier ¬´ Friedland ¬ª, 147 bvd Haussmann, Paris 8e (entr√©e pi√©ton du parking sur la rue)",
    address: "Acc√®s pompier ¬´ Friedland ¬ª, 147 bvd Haussmann, Paris 8e (entr√©e pi√©ton du parking sur la rue)",
    pk: 18895,
    lat: 48.87495190,
    lon: 2.31164272
  },
  {
    name: "Gare de Auber, 17 rue Scribe, 5 Rue des Mathurins",
    address: "Gare de Auber, 17 rue Scribe, 5 Rue des Mathurins",
    pk: 20201,
    lat: 48.87290641,
    lon: 2.32995737
  },
  {
    name: "Musoir de Ch√¢telet ‚Äì<",
    address: "Musoir de Ch√¢telet ‚Äì<",
    pk: 21626,
    lat: null,
    lon: null
  },
  {
    name: "Gare de Ch√¢telet les Halles. Via souterrain des Halles (suivre ¬´ forum Nord ¬ª). Via station Les Halles L4 : 103 rue Rambuteau",
    address: "Gare de Ch√¢telet les Halles. Via souterrain des Halles (suivre ¬´ forum Nord ¬ª). Via station Les Halles L4 : 103 rue Rambuteau",
    pk: 22077,
    lat: 48.86269354,
    lon: 2.34661165
  },
  {
    name: "¬´ Nicolas Flamel ¬ª (trappe) (√Ä CONFIRMER), Angle 39 rue de Rivoli / 10 rue St Martin √Ä c√¥t√© du square de la tour St Jacques. Acc√®s commun ligne A et B",
    address: "¬´ Nicolas Flamel ¬ª (trappe) (√Ä CONFIRMER), Angle 39 rue de Rivoli / 10 rue St Martin √Ä c√¥t√© du square de la tour St Jacques. Acc√®s commun ligne A et B",
    pk: 22650,
    lat: 48.85795843,
    lon: 2.34956165
  },
  {
    name: "‚Üê V1 / ‚Üê V2 (REDAN √Ä CONFIRMER)",
    address: "‚Üê V1 / ‚Üê V2 (REDAN √Ä CONFIRMER)",
    pk: 23180,
    lat: null,
    lon: null
  },
  {
    name: "Par escaliers acc√®s pompiers, Nonnains d'Hy√®res (trappe) 10-12 rue Nonnains d'Hy√®res, Paris 4e",
    address: "Par escaliers acc√®s pompiers, Nonnains d'Hy√®res (trappe) 10-12 rue Nonnains d'Hy√®res, Paris 4e",
    pk: 23420,
    lat: 48.85404139,
    lon: 2.35854652
  },
  {
    name: "Gare de Lyon, Acc√®s face au 164 rue de Bercy, Paris 12e",
    address: "Gare de Lyon, Acc√®s face au 164 rue de Bercy, Paris 12e",
    pk: 24902,
    lat: 48.84319067,
    lon: 2.37499372
  },
  {
    name: "Les ruches (entr√©e du tunnel), 5 av. Gambetta, Saint-Mand√©",
    address: "Les ruches (entr√©e du tunnel), 5 av. Gambetta, Saint-Mand√©",
    pk: 28900,
    lat: 48.84430170,
    lon: 2.42007197
  },
  {
    name: "Rampe en terre, 102 av. Aubert, Vincennes",
    address: "Rampe en terre, 102 av. Aubert, Vincennes",
    pk: 29350,
    lat: 48.84620131,
    lon: 2.42424566
  },
  {
    name: "Gare de Vincennes",
    address: "Gare de Vincennes",
    pk: 29894,
    lat: null,
    lon: null
  },
  {
    name: "Mairie de St-Mand√©, 16 av. Pierre Brossolette, Vincennes",
    address: "Mairie de St-Mand√©, 16 av. Pierre Brossolette, Vincennes",
    pk: 30660,
    lat: 48.84694709,
    lon: 2.44195127
  },
  {
    name: "28 bvd de la lib√©ration, Vincennes",
    address: "28 bvd de la lib√©ration, Vincennes",
    pk: 31250,
    lat: 48.84663889,
    lon: 2.44977778
  },
  {
    name: "Acc√®s Pompiers, 1 Place du Mar√©chal-Lyautey, Vincennes",
    address: "Acc√®s Pompiers, 1 Place du Mar√©chal-Lyautey, Vincennes",
    pk: 31400,
    lat: 48.84619098,
    lon: 2.45189408
  },
  {
    name: "49 av. des Charmes, Fontenay sous Bois",
    address: "49 av. des Charmes, Fontenay sous Bois",
    pk: 31795,
    lat: 48.84551317,
    lon: 2.45553573
  },
  {
    name: "Via la gare de Fontenay",
    address: "Via la gare de Fontenay",
    pk: 32460,
    lat: null,
    lon: null
  },
  {
    name: "Gare de Val de Fontenay",
    address: "Gare de Val de Fontenay",
    pk: 34421,
    lat: null,
    lon: null
  },
  {
    name: "CAT VDF (acc√®s par badge), 199 rue Carnot, Fontenay sous Bois",
    address: "CAT VDF (acc√®s par badge), 199 rue Carnot, Fontenay sous Bois",
    pk: 34660,
    lat: 48.85463889,
    lon: 2.48977778
  },
  {
    name: "¬´ Le bateau ¬ª, Chemin de la Prairie, Neuilly Plaisance",
    address: "¬´ Le bateau ¬ª, Chemin de la Prairie, Neuilly Plaisance",
    pk: 35200,
    lat: 48.85713889,
    lon: 2.49594444
  },
  {
    name: "18 rue Pasteur Neuilly Plaisance",
    address: "18 rue Pasteur Neuilly Plaisance",
    pk: 35500,
    lat: 48.85746827,
    lon: 2.49998451
  },
  {
    name: "Gare de Neuilly Plaisance",
    address: "Gare de Neuilly Plaisance",
    pk: 36630,
    lat: null,
    lon: null
  },
  {
    name: "PR de Bry (fin du viaduc)",
    address: "PR de Bry (fin du viaduc)",
    pk: 37050,
    lat: null,
    lon: null
  },
  {
    name: "30 rue du G√©n√©ral Leclerc, Bry-sur-Marne",
    address: "30 rue du G√©n√©ral Leclerc, Bry-sur-Marne",
    pk: 37100,
    lat: 48.83272275,
    lon: 2.52168104
  },
  {
    name: "145 bvd de la Libert√©, Bry-sur-Marne",
    address: "145 bvd de la Libert√©, Bry-sur-Marne",
    pk: 37300,
    lat: 48.83562965,
    lon: 2.49469926
  },
  {
    name: "Gare de Bry-sur-Marne",
    address: "Gare de Bry-sur-Marne",
    pk: 37892,
    lat: null,
    lon: null
  },
  {
    name: "121 bvd de la Libert√© (Acc√®s difficile), Bry-sur-Marne",
    address: "121 bvd de la Libert√© (Acc√®s difficile), Bry-sur-Marne",
    pk: 38130,
    lat: 48.84838889,
    lon: 2.53066667
  },
  {
    name: "Parking 23 bvd G. Cl√©menceau, Bry-sur-Marne",
    address: "Parking 23 bvd G. Cl√©menceau, Bry-sur-Marne",
    pk: 38500,
    lat: 48.84262630,
    lon: 2.52663406
  },
  {
    name: "Rue des P√¢tis, Bry-sur-Marne",
    address: "Rue des P√¢tis, Bry-sur-Marne",
    pk: 38800,
    lat: 48.84436111,
    lon: 2.53772222
  },
  {
    name: "Parking du RER (4 acc√®s), 3 av. Jean Kiffer, Champigny-sur-Marne",
    address: "Parking du RER (4 acc√®s), 3 av. Jean Kiffer, Champigny-sur-Marne",
    pk: 39400,
    lat: 48.84175000,
    lon: 2.54502778
  },
  {
    name: "Gare de Champigny",
    address: "Gare de Champigny",
    pk: 39529,
    lat: null,
    lon: null
  },
  {
    name: "39 av. J. Baptiste Cl√©ment, Champigny-sur-Marne",
    address: "39 av. J. Baptiste Cl√©ment, Champigny-sur-Marne",
    pk: 39950,
    lat: null,
    lon: null
  },
  {
    name: "13 av. Foch, Champigny-sur-Marne",
    address: "13 av. Foch, Champigny-sur-Marne",
    pk: 40200,
    lat: null,
    lon: null
  },
  {
    name: "19 av. du Mar√©chal Leclerc, La Varenne",
    address: "19 av. du Mar√©chal Leclerc, La Varenne",
    pk: 40500,
    lat: null,
    lon: null
  },
  {
    name: "37 av. Foch, La Varenne",
    address: "37 av. Foch, La Varenne",
    pk: 40850,
    lat: 48.83088889,
    lon: 2.56069444
  },
  {
    name: "Gare de La Varenne - Chennevi√®res",
    address: "Gare de La Varenne - Chennevi√®res",
    pk: 41229,
    lat: null,
    lon: null
  },
  {
    name: "60 av. du Mar√©chal Leclerc, La Varenne",
    address: "60 av. du Mar√©chal Leclerc, La Varenne",
    pk: 41700,
    lat: null,
    lon: null
  },
  {
    name: "118 av. du Mar√©chal Leclerc, La Varenne",
    address: "118 av. du Mar√©chal Leclerc, La Varenne",
    pk: 42150,
    lat: null,
    lon: null
  },
  {
    name: "102 av. du G√©n√©ral De Gaulle, Sucy-en-Brie",
    address: "102 av. du G√©n√©ral De Gaulle, Sucy-en-Brie",
    pk: 42750,
    lat: 48.81308333,
    lon: 2.57508333
  },
  {
    name: "191 av. du G√©n√©ral De Gaulle, Sucy-en-Brie",
    address: "191 av. du G√©n√©ral De Gaulle, Sucy-en-Brie",
    pk: 43500,
    lat: 48.80919444,
    lon: 2.58255556
  },
  {
    name: "Gare de Sucy-Bonneuil",
    address: "Gare de Sucy-Bonneuil",
    pk: 44577,
    lat: null,
    lon: null
  },
  {
    name: "¬´ La cantine ¬ª 11 chemin vert (acc√®s au niveau du pont), Sucy en Brie",
    address: "¬´ La cantine ¬ª 11 chemin vert (acc√®s au niveau du pont), Sucy en Brie",
    pk: 45150,
    lat: 48.76594444,
    lon: 2.50536111
  },
  {
    name: "Voie Mexico, Rue de Villeneuve, Boissy St L√©ger",
    address: "Voie Mexico, Rue de Villeneuve, Boissy St L√©ger",
    pk: 45800,
    lat: 48.75961111,
    lon: 2.50802778
  },
  {
    name: "Atelier MRF Sucy, 13 chemin vert, Sucy en brie",
    address: "Atelier MRF Sucy, 13 chemin vert, Sucy en brie",
    pk: 46200,
    lat: 48.76529003,
    lon: 2.50217879
  },
  {
    name: "Gare de Boissy-Saint-L√©ger",
    address: "Gare de Boissy-Saint-L√©ger",
    pk: 47795,
    lat: null,
    lon: null
  },
  {
    name: "Bvd Georges Cl√©menceau",
    address: "Bvd Georges Cl√©menceau",
    pk: 47380,
    lat: null,
    lon: null
  },
  {
    name: "20 av. de l'hippodrome, La Varenne",
    address: "20 av. de l'hippodrome, La Varenne",
    pk: 44050,
    lat: 48.86168940,
    lon: 2.21708690
  },
  {
    name: "17 route de Br√©tigny, Bonneuil sur marne (Portail √† droite avant le pont)",
    address: "17 route de Br√©tigny, Bonneuil sur marne (Portail √† droite avant le pont)",
    pk: 43160,
    lat: 48.78379361,
    lon: 2.50701747
  },
  {
    name: "253 bvd de Cr√©teil, St Maur des foss√©s",
    address: "253 bvd de Cr√©teil, St Maur des foss√©s",
    pk: 42500,
    lat: 48.78880556,
    lon: 2.49950000
  },
  {
    name: "PR de St Maur (3 acc√®s), bvd de Cr√©teil St Maur des foss√©s",
    address: "PR de St Maur (3 acc√®s), bvd de Cr√©teil St Maur des foss√©s",
    pk: 41500,
    lat: null,
    lon: null
  },
  {
    name: "16 all√©e du Petit Parc, St Maur des foss√©s",
    address: "16 all√©e du Petit Parc, St Maur des foss√©s",
    pk: 41200,
    lat: null,
    lon: null
  },
  {
    name: "20 bvd de Cr√©teil, St Maur des foss√©s",
    address: "20 bvd de Cr√©teil, St Maur des foss√©s",
    pk: 40850,
    lat: 48.80272222,
    lon: 2.48561111
  },
  {
    name: "Gare de St-Maur - Cr√©teil",
    address: "Gare de St-Maur - Cr√©teil",
    pk: 40750,
    lat: null,
    lon: null
  },
  {
    name: "50 av. du Bac, St Maur des foss√©s",
    address: "50 av. du Bac, St Maur des foss√©s",
    pk: 39500,
    lat: 48.79488373,
    lon: 2.51269474
  },
  {
    name: "86 av. du Bac, St Maur des foss√©s",
    address: "86 av. du Bac, St Maur des foss√©s",
    pk: 39150,
    lat: 48.79407368,
    lon: 2.51247564
  },
  {
    name: "Gare de Le Parc de St-Maur",
    address: "Gare de Le Parc de St-Maur",
    pk: 38623,
    lat: null,
    lon: null
  },
  {
    name: "76 av. du Mar√©chal Lyautey, St Maur des foss√©s",
    address: "76 av. du Mar√©chal Lyautey, St Maur des foss√©s",
    pk: 38450,
    lat: 48.81013889,
    lon: 2.47586111
  },
  {
    name: "3 av. de la Terrasse, St Maur des foss√©s",
    address: "3 av. de la Terrasse, St Maur des foss√©s",
    pk: 37950,
    lat: 48.81394444,
    lon: 2.46969444
  },
  {
    name: "Gare de St-Maur - L'√âcluse",
    address: "Gare de St-Maur - L'√âcluse",
    pk: 37476,
    lat: null,
    lon: null
  },
  {
    name: "3 av. Jean Brossolette, St Maur des foss√©s",
    address: "3 av. Jean Brossolette, St Maur des foss√©s",
    pk: 37200,
    lat: 48.80636689,
    lon: 2.49329289
  },
  {
    name: "Gare de Joinville-le-Pont",
    address: "Gare de Joinville-le-Pont",
    pk: 35800,
    lat: null,
    lon: null
  },
  {
    name: "32 av. Foch, Joinville-le-Pont",
    address: "32 av. Foch, Joinville-le-Pont",
    pk: 35600,
    lat: null,
    lon: null
  },
  {
    name: "16 quai de Polangis, Joinville-le-Pont",
    address: "16 quai de Polangis, Joinville-le-Pont",
    pk: 35300,
    lat: 48.82212116,
    lon: 2.46435795
  },
  {
    name: "47 bvd de l'Europe, Joinville-le-Pont",
    address: "47 bvd de l'Europe, Joinville-le-Pont",
    pk: 35150,
    lat: 48.81500797,
    lon: 2.46438259
  },
  {
    name: "4 rue de l'Esp√©rance, Joinville-le-Pont",
    address: "4 rue de l'Esp√©rance, Joinville-le-Pont",
    pk: 35000,
    lat: null,
    lon: null
  },
  {
    name: "6 av. des Tilleuls, Nogent-sur-Marne",
    address: "6 av. des Tilleuls, Nogent-sur-Marne",
    pk: 34800,
    lat: 48.83143509,
    lon: 2.47019678
  },
  {
    name: "20 bvd de la Marne, Nogent-sur-Marne",
    address: "20 bvd de la Marne, Nogent-sur-Marne",
    pk: 34650,
    lat: 48.83182648,
    lon: 2.47057077
  },
  {
    name: "Gare de Nogent-sur-Marne",
    address: "Gare de Nogent-sur-Marne",
    pk: 34020,
    lat: null,
    lon: null
  },
  {
    name: "60 bvd de la R√©publique, Nogent-sur-Marne",
    address: "60 bvd de la R√©publique, Nogent-sur-Marne",
    pk: 33700,
    lat: null,
    lon: null
  },
  {
    name: "20 bvd de la Marne, Nogent-sur-Marne",
    address: "20 bvd de la Marne, Nogent-sur-Marne",
    pk: 33550,
    lat: null,
    lon: null
  },
  {
    name: "155 av. du G√©n√©ral Leclerc, Nogent-sur-Marne",
    address: "155 av. du G√©n√©ral Leclerc, Nogent-sur-Marne",
    pk: 33450,
    lat: null,
    lon: null
  },
  {
    name: "5 rue des Hautes Plainses, Fontenay (Acc√®s difficile)",
    address: "5 rue des Hautes Plainses, Fontenay (Acc√®s difficile)",
    pk: 33200,
    lat: null,
    lon: null
  },
  {
    name: "Gare de Fontenay",
    address: "Gare de Fontenay",
    pk: 32890,
    lat: null,
    lon: null
  },
  {
    name: "5 av. Gambetta, Saint-Mand√©",
    address: "5 av. Gambetta, Saint-Mand√©",
    pk: 32200,
    lat: 48.84437790,
    lon: 2.42016489
  },
  {
    name: "145 av. du G√©n√©ral Leclerc, St Mand√©",
    address: "145 av. du G√©n√©ral Leclerc, St Mand√©",
    pk: 31950,
    lat: null,
    lon: null
  },
  {
    name: "PR de Bry (fin du viaduc) / 8 Rue du Vingt Six Ao√ªt 1944, Bry-sur-Marne",
    address: "PR de Bry (fin du viaduc) / 8 Rue du Vingt Six Ao√ªt 1944, Bry-sur-Marne",
    pk: 37100,
    lat: null,
    lon: null
  },
  {
    name: "Sortie du parc de Bry / 86 av. de Rigny, Bry-sur-Marne",
    address: "Sortie du parc de Bry / 86 av. de Rigny, Bry-sur-Marne",
    pk: 37700,
    lat: 48.84683028,
    lon: 2.52364667
  },
  {
    name: "Gare de Bry-sur-Marne",
    address: "Gare de Bry-sur-Marne",
    pk: 37835,
    lat: null,
    lon: null
  },
  {
    name: "Parc de Bry / 127 bvd Gallieni, Bry-sur-Marne",
    address: "Parc de Bry / 127 bvd Gallieni, Bry-sur-Marne",
    pk: 38050,
    lat: 48.84528599,
    lon: 2.52629374
  },
  {
    name: "66 av Georges Cl√©menceau, Bry-sur-Marne",
    address: "66 av Georges Cl√©menceau, Bry-sur-Marne",
    pk: 38200,
    lat: 48.84301133,
    lon: 2.52677550
  },
  {
    name: "11 rue des Templiers / 14 rue de la Croix aux Biches, Bry-sur-Marne",
    address: "11 rue des Templiers / 14 rue de la Croix aux Biches, Bry-sur-Marne",
    pk: 38380,
    lat: null,
    lon: null
  },
  {
    name: "¬´ Razel ¬ª / 1 rue des Vignes, Bry-sur-Marne",
    address: "¬´ Razel ¬ª / 1 rue des Vignes, Bry-sur-Marne",
    pk: 38600,
    lat: 48.84108994,
    lon: 2.53137569
  },
  {
    name: "Gare de Noisy le Gd ‚Äì Mt d'Est (Acc√®s ascenseur bout de quai 2)",
    address: "Gare de Noisy le Gd ‚Äì Mt d'Est (Acc√®s ascenseur bout de quai 2)",
    pk: 39749,
    lat: 48.84177778,
    lon: 2.54927778
  },
  {
    name: "Escalier m√©tallique / Face au 14 av. du Pav√© Neuf, Noisy-le-Grand",
    address: "Escalier m√©tallique / Face au 14 av. du Pav√© Neuf, Noisy-le-Grand",
    pk: 40200,
    lat: 48.84055556,
    lon: 2.55380556
  },
  {
    name: "1 Rue du Marnois Noisy-le-Grand",
    address: "1 Rue du Marnois Noisy-le-Grand",
    pk: 40680,
    lat: 48.84092116,
    lon: 2.56042493
  },
  {
    name: "A proximit√© du 120 rue Malnoue, Noisy-le-Grand",
    address: "A proximit√© du 120 rue Malnoue, Noisy-le-Grand",
    pk: 41350,
    lat: 48.84144444,
    lon: 2.56930556
  },
  {
    name: "(Acc√®s √† confirmer) / A proximit√© du 21 rue du Mar√©chal Juin (Acc√®s difficile), Noisy-le-Grand",
    address: "(Acc√®s √† confirmer) / A proximit√© du 21 rue du Mar√©chal Juin (Acc√®s difficile), Noisy-le-Grand",
    pk: 41530,
    lat: 48.84204558,
    lon: 2.57206337
  },
  {
    name: "Rue des Hauts Ch√¢teaux / Noisy-le-Grand",
    address: "Rue des Hauts Ch√¢teaux / Noisy-le-Grand",
    pk: 41725,
    lat: 48.84252778,
    lon: 2.57372222
  },
  {
    name: "Gare de Noisy-Champs",
    address: "Gare de Noisy-Champs",
    pk: 42058,
    lat: null,
    lon: null
  },
  {
    name: "Fin de quai / Avant le 1 bvd Archim√®de, Champs-sur-Marne",
    address: "Fin de quai / Avant le 1 bvd Archim√®de, Champs-sur-Marne",
    pk: 42340,
    lat: 48.84309131,
    lon: 2.58204106
  },
  {
    name: "¬´ Les sangliers ¬ª / Route de Malnoue (PR Noisiel), Champs-sur-Marne",
    address: "¬´ Les sangliers ¬ª / Route de Malnoue (PR Noisiel), Champs-sur-Marne",
    pk: 43750,
    lat: 48.84188889,
    lon: 2.60125000
  },
  {
    name: "42 cours du Luzard (acc√®s de chaque c√¥t√© du pont), Champs-sur-Marne",
    address: "42 cours du Luzard (acc√®s de chaque c√¥t√© du pont), Champs-sur-Marne",
    pk: 44050,
    lat: 48.84247222,
    lon: 2.60525000
  },
  {
    name: "Gare de Noisiel (Le Luzard)",
    address: "Gare de Noisiel (Le Luzard)",
    pk: 44754,
    lat: null,
    lon: null
  },
  {
    name: "¬´ Chocolaterie ¬ª / 111 grande all√©e du 12 f√©vrier 1934, Noisiel",
    address: "¬´ Chocolaterie ¬ª / 111 grande all√©e du 12 f√©vrier 1934, Noisiel",
    pk: 45490,
    lat: 48.84213889,
    lon: 2.62422222
  },
  {
    name: "Bv de la Malvoisine, Lognes",
    address: "Bv de la Malvoisine, Lognes",
    pk: 45900,
    lat: 48.84027778,
    lon: 2.62963889
  },
  {
    name: "Gare de Lognes / Acc√®s parking 18 rue Nicolas Appert",
    address: "Gare de Lognes / Acc√®s parking 18 rue Nicolas Appert",
    pk: 46107,
    lat: 48.83947222,
    lon: 2.63150000
  },
  {
    name: "¬´ Les paraboles ¬ª / Vers le 11 Bvd Fr√©d√©ric Chopin, Lognes",
    address: "¬´ Les paraboles ¬ª / Vers le 11 Bvd Fr√©d√©ric Chopin, Lognes",
    pk: 47100,
    lat: 48.83830556,
    lon: 2.64500000
  },
  {
    name: "Gare de Torcy (2 acc√®s : 2 av. Jean Moulin / 2 Rue L√©on Blum)",
    address: "Gare de Torcy (2 acc√®s : 2 av. Jean Moulin / 2 Rue L√©on Blum)",
    pk: 47757,
    lat: null,
    lon: null
  },
  {
    name: "Parking parc (c√¥t√© Torcy) / D128, Bussy-Saint-Martin",
    address: "Parking parc (c√¥t√© Torcy) / D128, Bussy-Saint-Martin",
    pk: 48150,
    lat: 48.84038889,
    lon: 2.65830556
  },
  {
    name: "MRF V19 (c√¥t√© Chessy) / Rd-pt de la grille noire, Bussy-Saint-Martin",
    address: "MRF V19 (c√¥t√© Chessy) / Rd-pt de la grille noire, Bussy-Saint-Martin",
    pk: 48700,
    lat: 48.84186111,
    lon: 2.66744444
  },
  {
    name: "1 Av. Michel Chartier, Bussy-Saint-Martin",
    address: "1 Av. Michel Chartier, Bussy-Saint-Martin",
    pk: 48850,
    lat: 48.84116667,
    lon: 2.66863889
  },
  {
    name: "¬´ Croix Blanche ¬ª (Acc√®s difficile) / Entr√©e parking √† c√¥t√© du 3 All. du Parc, Coll√©gien",
    address: "¬´ Croix Blanche ¬ª (Acc√®s difficile) / Entr√©e parking √† c√¥t√© du 3 All. du Parc, Coll√©gien",
    pk: 49550,
    lat: 48.83922222,
    lon: 2.67655556
  },
  {
    name: "¬´ Les Bordes ¬ª (Acc√®s difficile) / 41 rue de la brosse, Coll√©gien",
    address: "¬´ Les Bordes ¬ª (Acc√®s difficile) / 41 rue de la brosse, Coll√©gien",
    pk: 50250,
    lat: 48.83558333,
    lon: 2.68463889
  },
  {
    name: "¬´ Les gitans ¬ª / Rue de la Butte de Vaux, Coll√©gien",
    address: "¬´ Les gitans ¬ª / Rue de la Butte de Vaux, Coll√©gien",
    pk: 51150,
    lat: 48.83513889,
    lon: 2.69605556
  },
  {
    name: "Bvd de Lagny, Bussy-Saint-Georges",
    address: "Bvd de Lagny, Bussy-Saint-Georges",
    pk: 51850,
    lat: 48.83600000,
    lon: 2.70575000
  },
  {
    name: "Gare de Bussy-Saint-Georges",
    address: "Gare de Bussy-Saint-Georges",
    pk: 52099,
    lat: null,
    lon: null
  },
  {
    name: "¬´ La ferme ¬ª (Acc√®s pi√©ton et v√©hicule) / 7 all√©e Madame de Montespan, Bussy-Saint-Georges",
    address: "¬´ La ferme ¬ª (Acc√®s pi√©ton et v√©hicule) / 7 all√©e Madame de Montespan, Bussy-Saint-Georges",
    pk: 53350,
    lat: 48.83874883,
    lon: 2.72748201
  },
  {
    name: "Croisement av. du G√©n√©ral de Gaulle / 17 Bd des 100 Arpents, Bussy-Saint-Georges",
    address: "Croisement av. du G√©n√©ral de Gaulle / 17 Bd des 100 Arpents, Bussy-Saint-Georges",
    pk: 54100,
    lat: 48.84200000,
    lon: 2.73833333
  },
  {
    name: "¬´ PER Jossigny ¬ª (Acc√®s pi√©ton et v√©hicule) / Rd-pt sur av. de l'europe (D10), Jossigny",
    address: "¬´ PER Jossigny ¬ª (Acc√®s pi√©ton et v√©hicule) / Rd-pt sur av. de l'europe (D10), Jossigny",
    pk: 55100,
    lat: 48.84519444,
    lon: 2.74533333
  },
  {
    name: "(Acc√®s √† confirmer) / 77 Rue de la Charbonni√®re (derri√®re le pont), Mont√©vrain",
    address: "(Acc√®s √† confirmer) / 77 Rue de la Charbonni√®re (derri√®re le pont), Mont√©vrain",
    pk: 56560,
    lat: 48.85341667,
    lon: 2.76950000
  },
  {
    name: "¬´ Les lapins ¬ª (Acc√®s pi√©ton et v√©hicule) / D231, Jossigny",
    address: "¬´ Les lapins ¬ª (Acc√®s pi√©ton et v√©hicule) / D231, Jossigny",
    pk: 56650,
    lat: 48.85063889,
    lon: 2.76561111
  },
  {
    name: "Gare de Val d'Europe",
    address: "Gare de Val d'Europe",
    pk: 57150,
    lat: null,
    lon: null
  },
  {
    name: "PER Chessy (Acc√®s pi√©ton et v√©hicule) / Av. Herg√©, Chessy",
    address: "PER Chessy (Acc√®s pi√©ton et v√©hicule) / Av. Herg√©, Chessy",
    pk: 58500,
    lat: 48.86172222,
    lon: 2.78038889
  },
  {
    name: "Disney / Rue Morris, Chessy",
    address: "Disney / Rue Morris, Chessy",
    pk: 58800,
    lat: 48.86652778,
    lon: 2.78127778
  },
  {
    name: "Gare de Chessy / Via h√¥tel Disney's New York, Rue de la Marni√®re",
    address: "Gare de Chessy / Via h√¥tel Disney's New York, Rue de la Marni√®re",
    pk: 59078,
    lat: null,
    lon: null
  },
  {
    name: "(Acc√®s √† confirmer) Arri√®re gare de Chessy / Zone de service, Coupvray (parking)",
    address: "(Acc√®s √† confirmer) Arri√®re gare de Chessy / Zone de service, Coupvray (parking)",
    pk: 59700,
    lat: null,
    lon: null
  },
];

  // On ajoute automatiquement chaque gare comme un "acc√®s" suppl√©mentaire
  // V√©rifier d'abord si la gare existe d√©j√† dans accessPoints pour √©viter les doublons
  for (const st of stations) {
    if (!st || !st.name) continue; // S√©curit√© : ignorer les entr√©es invalides
    const gareName = "Gare de " + st.name;
    // Normaliser le nom pour la comparaison (enlever les accents, espaces, etc.)
    // Utiliser une fonction de normalisation compatible
    const normalizeString = (str) => {
      if (!str) return "";
      try {
        return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, " ");
      } catch (e) {
        // Fallback si normalize n'est pas support√©
        return str.toLowerCase().replace(/\s+/g, " ");
      }
    };
    
    const normalizedGareName = normalizeString(gareName);
    const stationNameNormalized = normalizeString(st.name);
    
    const existingGare = accessPoints.find(acc => {
      if (!acc || !acc.name) return false;
      const normalizedAccName = normalizeString(acc.name);
      // Extraire le nom de la gare de l'acc√®s (enlever "gare de" et variations)
      const accStationName = normalizedAccName.replace(/^gare\s+(de\s+)?/i, "").trim();
      
      // V√©rifier si le nom de la gare correspond (m√™me apr√®s normalisation)
      const nameMatches = accStationName === stationNameNormalized ||
                         accStationName.includes(stationNameNormalized) ||
                         stationNameNormalized.includes(accStationName) ||
                         // V√©rifier les mots-cl√©s communs (ex: "nanterre universite" vs "nanterre-universite")
                         accStationName.split(/[\s-]+/).some(word => word.length > 3 && stationNameNormalized.includes(word)) ||
                         stationNameNormalized.split(/[\s-]+/).some(word => word.length > 3 && accStationName.includes(word));
      
      // V√©rifier aussi si le PK est tr√®s proche (moins de 200m) comme fallback
      const pkClose = acc.pk != null && st.pk != null && Math.abs(acc.pk - st.pk) < 200;
      
      return normalizedAccName.includes("gare") && (nameMatches || pkClose);
    });
    
    // Si la gare n'existe pas d√©j√†, l'ajouter
    if (!existingGare) {
      accessPoints.push({
        name: gareName,
        address: "Gare RER A " + st.name,
        pk: st.pk,
        lat: st.lat,
        lon: st.lon,
        nearestStation: st.name
      });
    } else {
      // Si elle existe mais avec un PK diff√©rent, mettre √† jour le PK pour correspondre √† la gare officielle
      if (existingGare.pk !== st.pk && st.pk != null) {
        existingGare.pk = st.pk;
        if (st.lat != null && st.lon != null) {
          existingGare.lat = st.lat;
          existingGare.lon = st.lon;
        }
        existingGare.nearestStation = st.name;
      }
    }
  }

  // === CONSTANTES DE BRANCHES (d√©finies avant utilisation) ===
  const BRANCH_COMMON_MAX = 30000; // Fin du tronc commun (apr√®s Vincennes)
  const BRANCH_CHESSY_MIN = 34000; // D√©but de la branche Chessy (Val de Fontenay)
  const BRANCH_CHESSY_MAX = 59700; // Fin de la branche Chessy
  const BRANCH_BOISSY_MIN = 32750; // D√©but de la branche Boissy (Fontenay-sous-Bois)
  const BRANCH_BOISSY_MAX = 47200; // Fin de la branche Boissy (Boissy-Saint-L√©ger)
  const COMMON_BRANCH_PROMPT_MIN = 7050;
  const COMMON_BRANCH_PROMPT_MAX = 22300;

  // === CONFIGURATION GLOBALE DES BRANCHES ET OFFSETS ===
  // Identifiants de branches normalis√©s
  const BRANCH_IDS = {
    OUEST: 'ouest',
    CENTRAL: 'central',
    CHESSY: 'chessy',
    BOISSY: 'boissy'
  };

  // Offsets pour la conversion PK m√©trique ‚Üí PK affich√©
  // Seule la branche Boissy utilise un offset (PK relatifs)
  // Les autres branches (OUEST, CENTRAL, CHESSY) affichent directement le PK m√©trique
  const BRANCH_OFFSETS = {
    [BRANCH_IDS.BOISSY]: 25000, // PK affich√© = PK m√©trique - 25000 pour Boissy
    [BRANCH_IDS.CENTRAL]: 0,    // Pas d'offset pour le tronc commun
    [BRANCH_IDS.CHESSY]: 0,      // Pas d'offset pour Chessy
    [BRANCH_IDS.OUEST]: 0        // Pas d'offset pour Ouest
  };

  // === CONFIGURATION DES DISCONTINUIT√âS PK ===
  // Gestion du saut de PK local (ex: zone Nanterre-Universit√© ‚Üí Nanterre-Pr√©fecture)
  // Entre PK ~10800 et ~11300, il y a un saut de +500m dans la num√©rotation PK
  // La distance m√©trique r√©elle reste ~50m, seul l'affichage du PK re√ßoit le saut
  const pkDiscontinuities = [
    {
      branch: "central",
      pk_before: 10800,
      pk_after: 11300,
      split_ref: { lat: 48.898, lon: 2.218 }, // Point milieu approximatif entre Nanterre-Universit√© et Nanterre-Pr√©fecture
      window_m: 100, // Fen√™tre ¬± m√®tres autour de split_ref pour appliquer la r√®gle
      jump: 500 // pk_after - pk_before
    }
  ];

  // Fonction pour trouver la discontinuit√© applicable √† un PK m√©trique donn√©
  function findDiscontinuityForMetricPk(pkMetric, branchKey) {
    if (!Number.isFinite(pkMetric)) return null;
    const normalized = normalizeBranchKey(branchKey);
    for (const disc of pkDiscontinuities) {
      if (disc.branch === normalized) {
        // V√©rifier si le PK m√©trique est juste avant ou dans la zone de saut
        if (pkMetric >= disc.pk_before - disc.window_m && pkMetric < disc.pk_after) {
          return disc;
        }
      }
    }
    return null;
  }

  // Fonction pour trouver la discontinuit√© applicable √† un PK d'affichage donn√©
  function findDiscontinuityForDisplayPk(pkDisplay, branchKey) {
    if (!Number.isFinite(pkDisplay)) return null;
    const normalized = normalizeBranchKey(branchKey);
    for (const disc of pkDiscontinuities) {
      if (disc.branch === normalized) {
        // V√©rifier si le PK d'affichage est dans la zone de saut [pk_before, pk_after)
        if (pkDisplay >= disc.pk_before && pkDisplay < disc.pk_after) {
          return disc;
        }
      }
    }
    return null;
  }

  // Fonction pour v√©rifier si une position GPS est dans la fen√™tre de discontinuit√©
  function isInDiscontinuityWindow(lat, lon, disc) {
    if (!disc || !disc.split_ref || !Number.isFinite(lat) || !Number.isFinite(lon)) return false;
    const dist = distanceMeters(lat, lon, disc.split_ref.lat, disc.split_ref.lon);
    return dist <= disc.window_m;
  }

  // Fonction pour arrondir un PK m√©trique √† 10800 ou 11300 si dans la zone de saut
  // D√©coupage strict : aucune interpolation entre 10800 et 11300
  function roundPkToDiscontinuityBounds(pkMetric, branchKey) {
    if (!Number.isFinite(pkMetric)) return pkMetric;
    const normalized = normalizeBranchKey(branchKey);
    
    for (const disc of pkDiscontinuities) {
      if (disc.branch !== normalized) continue;
      
      // Si le PK est dans la zone de saut (10800, 11300), arrondir au plus proche
      if (pkMetric > disc.pk_before && pkMetric < disc.pk_after) {
        const distToBefore = pkMetric - disc.pk_before;
        const distToAfter = disc.pk_after - pkMetric;
        // Arrondir au plus proche (10800 ou 11300)
        return distToBefore < distToAfter ? disc.pk_before : disc.pk_after;
      }
    }
    return pkMetric;
  }

  // Fonction pour appliquer le saut PK d'affichage (GPS ‚Üí PK)
  // IMPORTANT : pkMetric est toujours le PK m√©trique r√©el (sans saut)
  // D√©coupage strict : arrondir √† 10800 ou 11300, puis appliquer le saut si en aval
  function applyPkDisplayJump(pkMetric, lat, lon, branchKey) {
    if (!Number.isFinite(pkMetric)) return pkMetric;
    const normalized = normalizeBranchKey(branchKey);
    
    // D'abord arrondir au plus proche si dans la zone de saut (10800 ou 11300)
    const roundedPk = roundPkToDiscontinuityBounds(pkMetric, normalized);
    
    // Chercher une discontinuit√© applicable
    for (const disc of pkDiscontinuities) {
      if (disc.branch !== normalized) continue;
      
      // Si le PK arrondi est exactement √† pk_after (11300), c'est d√©j√† apr√®s le saut
      if (roundedPk === disc.pk_after) {
        return roundedPk; // 11300 : d√©j√† apr√®s le saut, pas de modification
      }
      
      // Si le PK arrondi est exactement √† pk_before (10800), v√©rifier si on est en aval
      if (roundedPk === disc.pk_before) {
        // Si on a des coordonn√©es GPS, v√©rifier si on est en aval du split_ref
        if (lat != null && lon != null && isInDiscontinuityWindow(lat, lon, disc)) {
          // Projeter pour d√©terminer si on est en aval
          const proj = projectToLine(lat, lon);
          if (proj.pkProj != null && proj.pkProj >= disc.pk_before) {
            // On est en aval : afficher 11300 (apr√®s le saut)
            return disc.pk_after;
          }
        }
        // Sinon, on reste √† 10800 (avant le saut)
        return roundedPk;
      }
      
      // Si le PK est dans la zone (10800, 11300) mais arrondi, on a d√©j√† arrondi
      // Le roundedPk est soit 10800 soit 11300, on l'utilise tel quel
    }
    return roundedPk;
  }

  // Fonction pour convertir un PK d'affichage en PK m√©trique (inverse du saut)
  // Utilis√©e pour la recherche PK ‚Üí GPS
  // D√©coupage strict : si pkDisplay est dans (pk_before, pk_after), arrondir au plus proche
  function convertDisplayPkToMetricPk(pkDisplay, branchKey) {
    if (!Number.isFinite(pkDisplay)) return pkDisplay;
    const normalized = normalizeBranchKey(branchKey);
    for (const disc of pkDiscontinuities) {
      if (disc.branch === normalized) {
        // Si le PK d'affichage est dans la zone d'ombre (pk_before, pk_after), arrondir au plus proche
        if (pkDisplay > disc.pk_before && pkDisplay < disc.pk_after) {
          const distToBefore = pkDisplay - disc.pk_before;
          const distToAfter = disc.pk_after - pkDisplay;
          // Arrondir au plus proche
          return distToBefore < distToAfter ? disc.pk_before : disc.pk_after;
        }
        // Si le PK d'affichage est exactement √† pk_before ou pk_after, le retourner tel quel
        if (pkDisplay === disc.pk_before || pkDisplay === disc.pk_after) {
          return pkDisplay;
        }
      }
    }
    return pkDisplay;
  }

   // Attribue une branche simple √† chaque acc√®s
  // (tronc commun = both, le reste on laissera null)
  for (const acc of accessPoints) {
    if (acc.pk <= BRANCH_COMMON_MAX) {
      acc.branch = "both"; // tronc commun
    } else {
      acc.branch = null;   // on d√©terminera la branche √† la vol√©e si besoin
    }
  }

  // Ligne courante utilis√©e pour la projection (tronc + branche selon o√π tu es)
let currentBranch = "chessy";
let linePoints = troncCommun.concat(brancheChessy); // Par d√©faut Chessy
// Polylignes calibr√©es (remplies √† partir des accessPoints + recalages)
let linePointsBoissy = null;
let linePointsChessy = null;
let lastCalibrationBuildTime = 0; // Cache pour √©viter de reconstruire les polylignes √† chaque fois
const CALIBRATION_CACHE_MS = 5000; // Reconstruire les polylignes toutes les 5 secondes max
const CALIBRATION_SINGLE_RADIUS = 1200; // rayon d'influence maximum (m) pour un point isol√©
let calibrationControlPoints = { central: [], boissy: [], chessy: [] };
let calibrationSegments = { central: [], boissy: [], chessy: [] };

const COVERAGE_LEGEND_STATE_KEY = "coverageLegendState";
const COVERAGE_LEGEND_COLLAPSE_KEY = "coverageLegendCollapsed";
const MANUAL_BRANCH_OVERRIDE_KEY = "manualBranchOverride";
// Mode debug : mettre √† false pour d√©sactiver les logs de d√©bogage
const DEBUG_MODE = false;
const BRANCH_SELECTION_STORAGE_KEY = "branchSelections";
const BRANCH_SELECTION_CONTEXTS = {
  search: "search",
  coverage: "coverage",
  target: "target",
  incident: "incident",
  recal: "recal",
  geoloc: "geoloc"
};
const BRANCH_OPTION_LABELS = {
  auto: "Auto",
  central: "Tron√ßon central",
  boissy: "Boissy",
  chessy: "Chessy"
};

  const sensitivityProfiles = {
    slow:   { idle: 0.15, walk: 1.5 },
    normal: { idle: 0.30, walk: 2.5 },
    train:  { idle: 1.00, walk: 6.0 }
  };

  const state = {
    watchId: null,
    lastRawPk: null,
    lastPk: null,
    lastPkTime: null,
    lastLat: null,
    lastLon: null,
    lastDist: null,
    lastAccuracy: null, // AJOUT CALIBRAGE : pr√©cision GPS
    direction: null,
    heading: null,
    nearestStation: null,
    nearestAccess: null
  };

  let pkOffset = 0;
  let sosPhone = "";
  let motionSensitivity = "normal";
  let pkTarget = null;
  let lastPkLookupAccess = null;
  let currentPkLookupTextResults = [];
  let pendingRecal = null;
  let recalHistory = [];
  let manualBranchOverride = null;
  let branchSelections = {
    [BRANCH_SELECTION_CONTEXTS.search]: "central",
    [BRANCH_SELECTION_CONTEXTS.coverage]: "central",
    [BRANCH_SELECTION_CONTEXTS.target]: "central",
    [BRANCH_SELECTION_CONTEXTS.incident]: "central",
    [BRANCH_SELECTION_CONTEXTS.recal]: "central",
    [BRANCH_SELECTION_CONTEXTS.geoloc]: "auto"
  };
  let pkTargetBranch = null;
  let coverageLegendVisibility = { sam: true, petard: true };
  let coverageLegendCollapsed = false;
  

  // === MODE COUVREUR CHEMINANT SEUL ===
  let couvreurSeulActive = false;
  let couvreurLastMovementTime = null; // Timestamp du dernier mouvement significatif (> 3m)
  let couvreurLastPosition = null; // Derni√®re position avec mouvement significatif {lat, lon, time}
  let couvreurCheckInterval = null; // Intervalle de v√©rification
  let couvreurStatusInterval = null; // Intervalle pour mettre √† jour le statut toutes les secondes
  const COUVREUR_NO_MOVEMENT_THRESHOLD = 3; // m√®tres (large de 3m)
  const COUVREUR_ALERT_DELAY = 1 * 60 * 1000; // 1 minute en millisecondes
  const COUVREUR_CHECK_INTERVAL = 30 * 1000; // V√©rifier toutes les 30 secondes
  const COUVREUR_STATUS_UPDATE_INTERVAL = 1000; // Mettre √† jour le statut toutes les secondes
  

  // Timer et sonnerie pour le SMS
  let smsTimerStartTime = null; // Timestamp du d√©but du timer SMS
  let smsTimerEndTime = null; // Timestamp de la fin du timer SMS (quand le SMS est envoy√©)
  let smsTimerInterval = null; // Intervalle pour mettre √† jour l'affichage du timer
  let smsAlarmInterval = null; // Intervalle pour la sonnerie
  let smsAlarmKeepAliveInterval = null; // Intervalle pour maintenir l'alarme active
  let audioContext = null; // Contexte audio pour la sonnerie
  let alarmOscillator = null; // Oscillateur pour la sonnerie
  let alarmGainNode = null; // Gain node pour l'alarme
  let smsSent = false; // Indique si le SMS a √©t√© envoy√©
  let alarmActive = false; // Indique si l'alarme est active
  let notificationPermission = null; // Permission pour les notifications
  const SMS_TIMER_DELAY = 30 * 1000; // 30 secondes avant de d√©clencher la sonnerie
  const ALARM_FREQUENCY = 800; // Fr√©quence de la sonnerie (Hz)
  const ALARM_DURATION = 0.5; // Dur√©e de chaque bip en secondes (pour recr√©er l'oscillateur)
  

  // === AJOUT CALIBRAGE : stockage des recalages locaux + fichier partag√© ===
  const LOCAL_CAL_KEY = "pkCalibrations";
  let localCalibrations = [];
  let sharedCalibrations = [];

  function loadLocalCalibrations() {
    const raw = safeGetItem(LOCAL_CAL_KEY);
    if (!raw) {
      localCalibrations = [];
      return;
    }
    try {
      const parsed = JSON.parse(raw);
      localCalibrations = Array.isArray(parsed) ? parsed : [];
    } catch (e) {
      console.warn("Erreur de parsing pkCalibrations :", e);
      localCalibrations = [];
    }
  }

  function saveLocalCalibrations() {
    try {
      safeSetItem(LOCAL_CAL_KEY, JSON.stringify(localCalibrations));
    } catch (e) {
      console.warn("Erreur lors de la sauvegarde pkCalibrations :", e);
    }
  }

  // === POINTS DE CARTE : stockage des points enregistr√©s ===
  const MAP_POINTS_KEY = "mapPoints";
  let mapPoints = [];

  const INCIDENTS_KEY = "incidents";
  let incidents = [];

  function loadMapPoints() {
    const raw = safeGetItem(MAP_POINTS_KEY);
    if (!raw) {
      mapPoints = [];
      return;
    }
    try {
      const parsed = JSON.parse(raw);
      mapPoints = Array.isArray(parsed) ? parsed : [];
    } catch (e) {
      console.warn("Erreur de parsing mapPoints :", e);
      mapPoints = [];
    }
    updateMapPointsInfo();
  }

  function saveMapPoints() {
    try {
      safeSetItem(MAP_POINTS_KEY, JSON.stringify(mapPoints));
      updateMapPointsInfo();
    } catch (e) {
      console.warn("Erreur lors de la sauvegarde mapPoints :", e);
    }
  }

  // === AVARIES : stockage des avaries enregistr√©es ===
  function loadIncidents() {
    const raw = safeGetItem(INCIDENTS_KEY);
    if (!raw) {
      incidents = [];
      return;
    }
    try {
      const parsed = JSON.parse(raw);
      incidents = Array.isArray(parsed) ? parsed : [];
      updateIncidentsList();
    } catch (e) {
      console.warn("Erreur de parsing incidents :", e);
      incidents = [];
    }
  }

  function saveIncidents() {
    try {
      safeSetItem(INCIDENTS_KEY, JSON.stringify(incidents));
    } catch (e) {
      console.warn("Erreur lors de la sauvegarde incidents :", e);
    }
  }

  function updateIncidentsList() {
    if (!incidentsList) return;
    
    if (incidents.length === 0) {
      incidentsList.innerHTML = '<div class="muted" style="text-align: center; padding: 16px;">Aucune avarie enregistr√©e.</div>';
      if (incidentsListField) incidentsListField.style.display = "none";
      return;
    }

    if (incidentsListField) incidentsListField.style.display = "block";

    let html = "";
    incidents.forEach((incident, index) => {
      const date = new Date(incident.timestamp);
      const dateStr = date.toLocaleString('fr-FR', { 
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      html += `<div style="border-bottom: 1px solid var(--border); padding: 8px 0; ${index === incidents.length - 1 ? 'border-bottom: none;' : ''}">`;
      html += `<div style="font-weight: 600; margin-bottom: 4px;">${index + 1}. ${incident.type}</div>`;
      html += `<div style="font-size: 0.85em; color: var(--text-secondary);">PK : ${incident.pkTxt} | ${dateStr}</div>`;
      html += `</div>`;
    });
    
    incidentsList.innerHTML = html;
  }

  function addIncidentToNote() {
    const incidentText = incidentResultText ? incidentResultText.value.trim() : "";
    if (!incidentText) {
      alert("Aucun message d'avarie √† ajouter. G√©n√®re d'abord un message.");
      return;
    }

    const incident = {
      message: incidentText,
      type: selectIncidentType ? selectIncidentType.value : "",
      pkTxt: state.lastPk != null ? "PK " + formatPk(state.lastPk) : "‚Äî",
      pk: state.lastPk,
      lat: state.lastLat,
      lon: state.lastLon,
      branch: currentBranch,
      timestamp: new Date().toISOString()
    };

    incidents.push(incident);
    saveIncidents();
    updateIncidentsList();

    alert(`‚úÖ Avarie ajout√©e √† la note !\n\nTotal : ${incidents.length} avarie(s) enregistr√©e(s).`);
  }

  function exportIncidentsAsNote() {
    if (incidents.length === 0) {
      alert("Aucune avarie √† exporter.");
      return;
    }

    let noteText = "AVARIES / INCIDENTS - RER A\n";
    noteText += "============================\n\n";
    noteText += `Total : ${incidents.length} avarie(s)\n`;
    noteText += `Date d'export : ${new Date().toLocaleString('fr-FR')}\n\n`;
    noteText += "‚îÄ".repeat(50) + "\n\n";

    incidents.forEach((incident, index) => {
      noteText += `[Avarie ${index + 1}]\n`;
      noteText += incident.message;
      noteText += "\n\n" + "‚îÄ".repeat(50) + "\n\n";
    });

    const blob = new Blob([noteText], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const stamp = now.toISOString().replace(/[:.]/g, "-");
    const filename = "avaries-" + stamp + ".txt";

    try {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert(`‚úÖ Note export√©e avec succ√®s !\n\nFichier : ${filename}\n\nNombre d'avaries : ${incidents.length}`);
    } catch (e) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(noteText).then(() => {
          alert(`‚úÖ Note copi√©e dans le presse-papiers !\n\nColle-la dans un fichier texte.\n\nNombre d'avaries : ${incidents.length}`);
        }).catch(() => {
          alert("‚ùå Erreur lors de la copie dans le presse-papiers.");
        });
      } else {
        alert("‚ùå Impossible d'exporter. Essaie sur un ordinateur ou v√©rifie les permissions du navigateur.");
      }
    }
  }

  function clearIncidents() {
    if (incidents.length === 0) {
      alert("La liste est d√©j√† vide.");
      return;
    }

    if (confirm(`Voulez-vous vraiment effacer toutes les ${incidents.length} avarie(s) enregistr√©e(s) ?`)) {
      incidents = [];
      saveIncidents();
      updateIncidentsList();
      alert("‚úÖ Liste effac√©e.");
    }
  }

  function updateMapPointsInfo() {
    const mapPointsInfo = document.getElementById("mapPointsInfo");
    if (!mapPointsInfo) return;
    const count = mapPoints.length;
    if (count === 0) {
      mapPointsInfo.textContent = "Aucun point enregistr√©.";
    } else {
      mapPointsInfo.textContent = count + " point(s) enregistr√©(s).";
    }
  }
  function noteLocation() {
    if (state.lastLat == null || state.lastLon == null) {
      alert("Pas de position GPS disponible. Lance la g√©olocalisation d'abord.");
      return;
    }

    const description = document.getElementById("inputMapPointDescription");
    if (!description) return;

    const descText = description.value.trim();
    if (!descText) {
      alert("Veuillez saisir une description pour ce point.");
      return;
    }

    // Calculer le PK actuel si disponible
    const currentPk = state.lastRawPk != null ? computePkWithCalibrations(state.lastRawPk, currentBranch) : null;

    const point = {
      lat: state.lastLat,
      lon: state.lastLon,
      description: descText,
      pk: currentPk,
      accuracy: state.lastAccuracy,
      branch: currentBranch,
      timestamp: new Date().toISOString()
    };

    mapPoints.push(point);
    saveMapPoints();

    // Vider le champ description
    description.value = "";

    alert("‚úÖ Point enregistr√© avec succ√®s !\n\nDescription : " + descText + "\nPosition : " + state.lastLat.toFixed(6) + ", " + state.lastLon.toFixed(6) + (currentPk != null ? "\nPK : " + Math.round(currentPk) + " m" : ""));
  }

  function exportMapPointsForGitHub() {
    if (!mapPoints.length) {
      alert("Tu n'as encore enregistr√© aucun point de carte.");
      return;
    }

    const dataStr = JSON.stringify(mapPoints, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const stamp = now.toISOString().replace(/[:.]/g, "-");
    const filename = "map-points-" + stamp + ".json";

    // M√©thode pour mobile et desktop
    try {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (e) {
      // Fallback : copier dans le presse-papiers (mobile)
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(dataStr).then(() => {
          alert("‚úÖ Donn√©es copi√©es dans le presse-papiers !\n\nColle-les dans un fichier .json et d√©pose-le sur GitHub.\n\nNombre de points : " + mapPoints.length);
        }).catch(() => {
          alert("‚ùå Erreur lors de la copie dans le presse-papiers.");
        });
      } else {
        alert("‚ùå Impossible d'exporter. Essaie sur un ordinateur ou v√©rifie les permissions du navigateur.");
      }
    }
  }

  function exportMapPointsAsNote() {
    if (!mapPoints.length) {
      alert("Tu n'as encore enregistr√© aucun point de carte.");
      return;
    }

    let noteText = "POINTS DE CARTE - RER A\n";
    noteText += "========================\n\n";
    noteText += `Total : ${mapPoints.length} point(s)\n`;
    noteText += `Date d'export : ${new Date().toLocaleString('fr-FR')}\n\n`;
    noteText += "‚îÄ".repeat(50) + "\n\n";

    mapPoints.forEach((point, index) => {
      noteText += `[Point ${index + 1}]\n`;
      noteText += `Description : ${point.description || "‚Äî"}\n`;
      
      if (point.pk != null) {
        noteText += `PK : ${formatPk(point.pk)} (${Math.round(point.pk)} m)\n`;
      } else {
        noteText += `PK : ‚Äî\n`;
      }
      
      if (point.lat != null && point.lon != null) {
        noteText += `Coordonn√©es GPS : ${point.lat.toFixed(6)}, ${point.lon.toFixed(6)}\n`;
      } else {
        noteText += `Coordonn√©es GPS : ‚Äî\n`;
      }
      
      if (point.accuracy != null) {
        noteText += `Pr√©cision GPS : ¬±${Math.round(point.accuracy)} m\n`;
      }
      
      if (point.branch) {
        const branchLabel = point.branch === "central" ? "Tron√ßon central" : 
                           point.branch === "boissy" ? "Boissy" : 
                           point.branch === "chessy" ? "Chessy" : point.branch;
        noteText += `Branche : ${branchLabel}\n`;
      }
      
      if (point.timestamp) {
        const date = new Date(point.timestamp);
        noteText += `Date d'enregistrement : ${date.toLocaleString('fr-FR')}\n`;
      }
      
      noteText += "\n" + "‚îÄ".repeat(50) + "\n\n";
    });

    const blob = new Blob([noteText], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const stamp = now.toISOString().replace(/[:.]/g, "-");
    const filename = "map-points-" + stamp + ".txt";

    // M√©thode pour mobile et desktop
    try {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (e) {
      // Fallback : copier dans le presse-papiers (mobile)
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(noteText).then(() => {
          alert("‚úÖ Note copi√©e dans le presse-papiers !\n\nColle-la dans un fichier texte.\n\nNombre de points : " + mapPoints.length);
        }).catch(() => {
          alert("‚ùå Erreur lors de la copie dans le presse-papiers.");
        });
      } else {
        alert("‚ùå Impossible d'exporter. Essaie sur un ordinateur ou v√©rifie les permissions du navigateur.");
      }
    }
  }

// === AJOUT CALIBRAGE : fichier partag√© optionnel =========================
async function loadSharedCalibrations() {
  try {
    const resp = await fetch("data/calibrations.json", { cache: "no-store" });
    if (!resp.ok) {
      console.log("Aucun calibrage partag√© (data/calibrations.json).");
      return;
    }
    const data = await resp.json();
    if (Array.isArray(data)) {
      sharedCalibrations = data;
      console.log("Calibrages partag√©s charg√©s :", sharedCalibrations.length);
    }
  } catch (e) {
    console.log("Impossible de charger les calibrages partag√©s :", e);
  }
}
// Laisse l'appel d√©sactiv√© tant que le fichier n'existe pas :
// loadSharedCalibrations();


  function exportLocalCalibrationsForGitHub() {
    if (!localCalibrations.length) {
      alert("Tu n'as encore enregistr√© aucun recalage PK.");
      return;
    }

    const dataStr = JSON.stringify(localCalibrations, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const stamp = now.toISOString().replace(/[:.]/g, "-");
    const filename = "pk-calibrations-local-" + stamp + ".json";

    // M√©thode pour mobile et desktop
    try {
    const a = document.createElement("a");
    a.href = url;
      a.download = filename;
      a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
      
      // Sur mobile, afficher aussi le contenu pour copier
      setTimeout(() => {
        const copyText = "üìã Copie le contenu ci-dessous et colle-le dans un fichier .json :\n\n" + dataStr;
        const shouldCopy = confirm(
          "Fichier t√©l√©charg√© : " + filename + "\n\n" +
          "Sur mobile, tu peux aussi copier le contenu JSON pour le partager.\n\n" +
          "Clique sur OK pour voir le contenu √† copier."
        );
        
        if (shouldCopy) {
          // Cr√©er une zone de texte pour copier facilement
          const textarea = document.createElement("textarea");
          textarea.value = dataStr;
          textarea.style.position = "fixed";
          textarea.style.left = "-9999px";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            alert("‚úÖ Contenu JSON copi√© dans le presse-papiers !\n\nTu peux maintenant le coller dans un message ou un fichier.");
          } catch (err) {
            // Si la copie √©choue, afficher le contenu
            const displayWindow = window.open("", "_blank");
            if (displayWindow) {
              displayWindow.document.write("<pre style='padding: 20px; font-family: monospace; white-space: pre-wrap;'>" + 
                JSON.stringify(localCalibrations, null, 2) + 
                "</pre>");
            } else {
              alert("Contenu JSON :\n\n" + dataStr.substring(0, 500) + "...\n\n(Contenu tronqu√©, utilise le t√©l√©chargement)");
            }
          }
          document.body.removeChild(textarea);
        }
      }, 100);
      
    URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Erreur lors de l'export :", error);
      // Fallback : afficher le JSON dans une alerte ou une nouvelle fen√™tre
      const displayWindow = window.open("", "_blank");
      if (displayWindow) {
        displayWindow.document.write("<pre style='padding: 20px; font-family: monospace; white-space: pre-wrap;'>" + 
          JSON.stringify(localCalibrations, null, 2) + 
          "</pre>");
      } else {
        alert("Erreur lors du t√©l√©chargement. Contenu JSON :\n\n" + dataStr.substring(0, 1000));
      }
    }
  }
  // === FIN AJOUT CALIBRAGE ===

  const gpsStatusBadge = document.getElementById("gpsStatusBadge");
  const geolocText = document.getElementById("geolocText");
  const btnToggleGeoloc = document.getElementById("btnToggleGeoloc");

  const nearestStationName = document.getElementById("nearestStationName");
  const nearestStationInfo = document.getElementById("nearestStationInfo");

  const movementTitle = document.getElementById("movementTitle");
  const movementDetails = document.getElementById("movementDetails");

  const nextStationName = document.getElementById("nextStationName");
  const nextStationInfo = document.getElementById("nextStationInfo");

  const nearestAccessName = document.getElementById("nearestAccessName");
  const nearestAccessInfo = document.getElementById("nearestAccessInfo");

  const pkTargetInfo = document.getElementById("pkTargetInfo");
  const inputPkTarget = document.getElementById("inputPkTarget");
  const btnSetPkTarget = document.getElementById("btnSetPkTarget");

  const smsPreview = document.getElementById("smsPreview");
  const btnSms = document.getElementById("btnSms");
  const btnCouvreurSeul = document.getElementById("btnCouvreurSeul");
  const couvreurStatus = document.getElementById("couvreurStatus");

  const pkCurrentValue = document.getElementById("pkCurrentValue");
  const pkCurrentDetails = document.getElementById("pkCurrentDetails");

  const orientationCard   = document.getElementById("orientationCard");
  const orientGareValueEl = document.getElementById("orientGareValue");

  const fermeturesNocturnesCard = document.getElementById("fermeturesNocturnesCard");
  const fermeturesNocturnesContent = document.getElementById("fermeturesNocturnesContent");

  const settingsPanel = document.getElementById("settingsPanel");
  const btnReadme = document.getElementById("btnReadme");
  const readmePanel = document.getElementById("readmePanel");
  const readmeContent = document.getElementById("readmeContent");
  const btnCloseReadme = document.getElementById("btnCloseReadme");
  const btnTestList = document.getElementById("btnTestList");
  const testListPanel = document.getElementById("testListPanel");
  const testListContent = document.getElementById("testListContent");
  const btnCloseTestList = document.getElementById("btnCloseTestList");

  const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
  const tabPanels = Array.from(document.querySelectorAll(".tab-panel"));

  const inputSosPhone = document.getElementById("inputSosPhone");
  const btnSavePhone = document.getElementById("btnSavePhone");
  const selectSensitivity = document.getElementById("selectSensitivity");
  const pkOffsetInfo = document.getElementById("pkOffsetInfo");
  const pkEstimateText = document.getElementById("pkEstimateText");
  const inputPkRecal = document.getElementById("inputPkRecal");
  const btnApplyRecal = document.getElementById("btnApplyRecal");
  const btnConfirmRecal = document.getElementById("btnConfirmRecal");
  const btnCancelRecal = document.getElementById("btnCancelRecal");
  const btnUndoRecal = document.getElementById("btnUndoRecal");
  const recalPreview = document.getElementById("recalPreview");
  const recalPreviewCurrent = document.getElementById("recalPreviewCurrent");
  const recalPreviewNew = document.getElementById("recalPreviewNew");
  const recalPreviewBranch = document.getElementById("recalPreviewBranch");
  const recalMessages = document.getElementById("recalMessages");
  const recalHistoryList = document.getElementById("recalHistoryList");
  const btnResetOffset = document.getElementById("btnResetOffset");
  const btnNoteLocation = document.getElementById("btnNoteLocation");
  const btnExportMapPoints = document.getElementById("btnExportMapPoints");
  const btnExportMapPointsNote = document.getElementById("btnExportMapPointsNote");
  const inputPkLookup = document.getElementById("inputPkLookup");
  const pkLookupSuggestions = document.getElementById("pkLookupSuggestions");
  const btnPkLookup = document.getElementById("btnPkLookup");
  const pkLookupResultField = document.getElementById("pkLookupResultField");
  const pkLookupResult = document.getElementById("pkLookupResult");
  const btnPkLookupOpenMaps = document.getElementById("btnPkLookupOpenMaps");
  const btnPkLookupOpenWaze = document.getElementById("btnPkLookupOpenWaze");
  const btnBranchSearch = document.getElementById("btnBranchSearch");
  const btnBranchCoverage = document.getElementById("btnBranchCoverage");
  const btnBranchTarget = document.getElementById("btnBranchTarget");
  const btnBranchIncident = document.getElementById("btnBranchIncident");
  const btnBranchRecal = document.getElementById("btnBranchRecal");
  const btnBranchGeoloc = document.getElementById("btnBranchGeoloc");

  const selectIncidentType = document.getElementById("selectIncidentType");
  const btnAddIncidentToNote = document.getElementById("btnAddIncidentToNote");
  const btnExportIncidentsNote = document.getElementById("btnExportIncidentsNote");
  const btnClearIncidents = document.getElementById("btnClearIncidents");
  const incidentsList = document.getElementById("incidentsList");
  const incidentsListField = document.getElementById("incidentsListField");
  const incidentOtherField = document.getElementById("incidentOtherField");
  const inputIncidentOther = document.getElementById("inputIncidentOther");
  const incidentPhotoInput = document.getElementById("incidentPhoto");
  const btnGenerateIncident = document.getElementById("btnGenerateIncident");
  const incidentResultField = document.getElementById("incidentResultField");
  const incidentResultText = document.getElementById("incidentResultText");
  const btnCopyIncident = document.getElementById("btnCopyIncident");

  // AJOUT CALIBRAGE : bouton d'export
  const btnExportCalibrations = document.getElementById("btnExportCalibrations");

  // Convertit un PK absolu en PK relatif selon la branche
  // NOTE : Seule la branche Boissy utilise des PK relatifs. Chessy et tronc commun utilisent les PK absolus.
  // === HELPERS CENTRAUX POUR CONVERSION PK M√âTRIQUE ‚Üî PK AFFICH√â ===
  // Ces deux fonctions sont la porte d'entr√©e/sortie oblig√©e entre le monde "terrain" (PK vus par l'agent)
  // et le monde interne (PK physique/m√©trique utilis√© pour g√©oloc, projections, calibrations, etc.)

  /**
   * Convertit un PK m√©trique (absolu) en PK affich√© (relatif pour Boissy)
   * @param {string} branchId - Identifiant de la branche ('central', 'boissy', 'chessy', 'ouest')
   * @param {number} pkMetric - PK m√©trique/absolu utilis√© en interne
   * @returns {string} - PK format√© pour l'affichage (ex: "9 000" pour Boissy, "34 000" pour Chessy)
   */
  function getDisplayPk(branchId, pkMetric) {
    if (!Number.isFinite(pkMetric)) return "‚Äî";
    
    // Normaliser l'identifiant de branche
    const normalizedBranch = normalizeBranchKey(branchId);
    if (!normalizedBranch) {
      // Si pas de branche, essayer de d√©tecter par plage de PK
      if (pkMetric >= BRANCH_BOISSY_MIN && pkMetric <= BRANCH_BOISSY_MAX) {
        const pkStrAuto = formatPkForUi(pkMetric - BRANCH_OFFSETS[BRANCH_IDS.BOISSY]);
        // Marque visuelle pour les PK relatifs Boissy (debug)
        return pkStrAuto + "‚Äô";
      }
      return formatPkForUi(pkMetric);
    }
    
    // R√©cup√©rer l'offset pour cette branche (0 pour toutes sauf Boissy)
    const offset = BRANCH_OFFSETS[normalizedBranch] || 0;
    const pkDisplay = pkMetric - offset;
    
    // Formater pour l'UI (ex: "9 000" ou "34 000")
    const pkStr = formatPkForUi(pkDisplay);
    // Marque visuelle pour les PK relatifs Boissy
    if (normalizedBranch === BRANCH_IDS.BOISSY || normalizedBranch === "boissy") {
      return pkStr + "‚Äô";
    }
    return pkStr;
  }

  /**
   * Parse une cha√Æne de PK saisie par l'utilisateur et la convertit en PK m√©trique
   * @param {string} branchId - Identifiant de la branche ('central', 'boissy', 'chessy', 'ouest')
   * @param {string} pkInputString - PK saisi par l'utilisateur (ex: "9+000" ou "9000")
   * @returns {number|null} - PK m√©trique utilisable par la g√©oloc/calibrations, ou null si invalide
   */
  function parseUserPkInput(branchId, pkInputString) {
    if (!pkInputString) return null;
    
    // On enl√®ve la prime √©ventuelle (‚Äô ou ') et espaces parasites
    const cleanedInput = String(pkInputString).replace(/[‚Äô']/g, "").trim();
    
    // Parser la cha√Æne nettoy√©e (ex: "9+000" ‚Üí 9000 ou "9000" ‚Üí 9000)
    const pkParsed = parsePkStringToNumber(cleanedInput);
    if (!Number.isFinite(pkParsed)) return null;
    
    // Normaliser l'identifiant de branche
    const normalizedBranch = normalizeBranchKey(branchId);
    if (!normalizedBranch) {
      // Si pas de branche, essayer de d√©tecter si c'est un PK relatif Boissy
      // (plage typique 6500-22200) ou un PK absolu
      if (pkParsed >= BOISSY_PK_START && pkParsed <= 22200) {
        return pkParsed + BRANCH_OFFSETS[BRANCH_IDS.BOISSY];
      }
      return pkParsed; // Consid√©rer comme PK absolu
    }
    
    // R√©cup√©rer l'offset pour cette branche (BRANCH_OFFSETS[BRANCH_IDS.BOISSY] pour Boissy, 0 pour les autres)
    const offset = BRANCH_OFFSETS[normalizedBranch] || 0;
    const pkMetric = pkParsed + offset;
    
    return pkMetric;
  }

  /**
   * Helper pour parser une cha√Æne PK en nombre
   * @param {string} str - Cha√Æne √† parser (ex: "9+000" ou "9000")
   * @returns {number|null} - Nombre pars√© ou null si invalide
   */
  function parsePkStringToNumber(str) {
    if (!str) return null;
    str = String(str).trim().replace(/\s+/g, "");
    
    if (/^\d+\+\d+$/.test(str)) {
      const [km, r] = str.split("+");
      return parseInt(km, 10) * 1000 + parseInt(r, 10);
    } else if (/^\d+$/.test(str)) {
      return parseInt(str, 10);
    }
    
    return null;
  }

  /**
   * Helper pour formater un PK en cha√Æne pour l'UI
   * @param {number} pk - PK √† formater
   * @returns {string} - PK format√© (ex: "9 000" ou "34 000")
   */
  function formatPkForUi(pk) {
    if (pk == null || isNaN(pk)) return "‚Äî";
    const m = Math.round(pk);
    const km = Math.floor(m / 1000);
    const rest = m % 1000;
    return km + " " + rest.toString().padStart(3, "0");
  }

  // === FONCTIONS DE CONVERSION (utilisent les helpers centraux) ===
  // Ces fonctions sont conserv√©es pour compatibilit√© mais utilisent maintenant getDisplayPk/parseUserPkInput
  
  /**
   * Convertit un PK absolu en PK relatif selon la branche (pour compatibilit√©)
   * @deprecated Utiliser getDisplayPk() directement pour l'affichage
   */
  function convertToRelativePk(pkAbsolute, branchKey = null) {
    if (pkAbsolute == null || !Number.isFinite(pkAbsolute)) return pkAbsolute;
    
    const branch = branchKey || currentBranch;
    const normalized = normalizeBranchKey(branch);
    const offset = BRANCH_OFFSETS[normalized] || 0;
    
    return pkAbsolute - offset;
  }

  /**
   * Formate un PK m√©trique pour l'affichage (utilise getDisplayPk)
   * @param {number} pkMeters - PK m√©trique/absolu
   * @param {string} branchKey - Branche (optionnel, utilise currentBranch si non fourni)
   * @returns {string} - PK format√© pour l'UI
   */
  function formatPk(pkMeters, branchKey = null) {
    const branch = branchKey || currentBranch;
    return getDisplayPk(branch, pkMeters);
  }

  /**
   * Convertit un PK relatif en PK absolu selon la branche (pour compatibilit√©)
   * @deprecated Utiliser parseUserPkInput() directement pour la saisie
   */
  function convertRelativeToAbsolutePk(pkRelative, branchKey = null) {
    if (pkRelative == null || !Number.isFinite(pkRelative)) return pkRelative;
    
    const branch = branchKey || currentBranch;
    const normalized = normalizeBranchKey(branch);
    const offset = BRANCH_OFFSETS[normalized] || 0;
    
    return pkRelative + offset;
  }

  /**
   * Parse une cha√Æne de PK saisie par l'utilisateur (utilise parseUserPkInput)
   * @param {string} str - Cha√Æne √† parser (ex: "9+000" ou "9000")
   * @param {string} branchKey - Branche (optionnel, utilise currentBranch si non fourni)
   * @returns {number|null} - PK m√©trique utilisable en interne, ou null si invalide
   */
  function parsePkInput(str, branchKey = null) {
    const branch = branchKey || currentBranch;
    return parseUserPkInput(branch, str);
  }

  const branchSelectionButtons = {
    [BRANCH_SELECTION_CONTEXTS.search]: null,
    [BRANCH_SELECTION_CONTEXTS.coverage]: null,
    [BRANCH_SELECTION_CONTEXTS.target]: null,
    [BRANCH_SELECTION_CONTEXTS.incident]: null,
    [BRANCH_SELECTION_CONTEXTS.recal]: null
  };

  function normalizeBranchInput(value) {
    if (value == null) return "auto";
    const normalized = String(value)
      .trim()
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    if (!normalized) return "auto";
    if (normalized === "auto" || normalized === "automatique") return "auto";
    if (normalized.startsWith("bo")) return "boissy";
    if (normalized.startsWith("ch")) return "chessy";
    if (normalized.startsWith("tronc") || normalized.startsWith("centr")) return "central";
    if (normalized === "central") return "central";
    return null;
  }

  function branchValueToLabel(value) {
    return BRANCH_OPTION_LABELS[value] || BRANCH_OPTION_LABELS.auto;
  }

  function updateBranchSelectionButton(context) {
    const button = branchSelectionButtons[context];
    if (!button) return;
    const value = branchSelections[context] || "central";
    button.textContent = branchValueToLabel(value);
  }

  function saveBranchSelections() {
    try {
      safeSetItem(BRANCH_SELECTION_STORAGE_KEY, JSON.stringify(branchSelections));
    } catch (error) {
      console.warn("Impossible de sauvegarder la s√©lection de branche", error);
    }
  }

  function loadBranchSelections() {
    const stored = safeGetItem(BRANCH_SELECTION_STORAGE_KEY);
    if (!stored) {
      Object.keys(branchSelections).forEach(context => updateBranchSelectionButton(context));
      return;
    }
    try {
      const parsed = JSON.parse(stored);
      if (parsed && typeof parsed === "object") {
        Object.keys(branchSelections).forEach(context => {
          const candidate = normalizeBranchInput(parsed[context]);
          branchSelections[context] = candidate || "central";
        });
      }
    } catch (error) {
      console.warn("Impossible de charger les s√©lections de branche", error);
      Object.keys(branchSelections).forEach(context => {
        branchSelections[context] = "central";
      });
    }
    Object.keys(branchSelections).forEach(context => updateBranchSelectionButton(context));
    // Ne pas forcer l'override au chargement : laisser la d√©tection GPS fonctionner
    // L'override ne sera appliqu√© que lors d'actions explicites (recherche, recalage, etc.)
  }

  function applyManualOverrideForBranch(value) {
    if (value === "auto" || value == null) {
      setManualBranchOverride("auto");
    } else if (value === "boissy" || value === "central" || value === "chessy") {
      setManualBranchOverride(value);
    }
  }

  function setBranchSelection(context, value, options = {}) {
    const normalized = normalizeBranchInput(value);
    if (!normalized) {
      alert("Choix de branche invalide.");
      return;
    }
    debugLog("üíæ setBranchSelection: contexte", context, "valeur", value, "normalis√©e", normalized);
    branchSelections[context] = normalized;
    debugLog("üíæ branchSelections apr√®s mise √† jour:", JSON.stringify(branchSelections));
    updateBranchSelectionButton(context);
    // Ne pas forcer l'override automatiquement : seulement si explicitement demand√©
    // L'override sera appliqu√© lors des actions (recherche, recalage, etc.) via ensureBranchForPk
    if (!options.skipSave) {
      saveBranchSelections();
    }
  }

  function showBranchSelectionDialog(context, allowed = ["auto", "central", "boissy", "chessy"]) {
    if (!branchSelections.hasOwnProperty(context)) {
      branchSelections[context] = "central";
    }
    const current = branchSelections[context] || "central";
    const labelList = allowed.map(value => branchValueToLabel(value)).join(", ");
    const input = window.prompt(
      `Choisis la branche pour cette action (options : ${labelList}).\nR√©ponds par auto, boissy, tron√ßon central ou chessy.`,
      current
    );
    if (input == null) {
      return;
    }
    const normalized = normalizeBranchInput(input);
    if (!normalized || !allowed.includes(normalized)) {
      alert(`Choix invalide. Options disponibles : ${labelList}.`);
      return;
    }
    setBranchSelection(context, normalized);
    // Si l'utilisateur choisit explicitement une branche (pas "auto"), appliquer l'override
    if (normalized !== "auto") {
      applyManualOverrideForBranch(normalized);
    } else {
      // Si on revient √† "auto", supprimer l'override pour laisser la d√©tection GPS fonctionner
      setManualBranchOverride("auto");
    }
  }

  function getContextBranch(context) {
    const result = branchSelections[context] || "central";
    debugLog("üìñ getContextBranch: contexte", context, "retourne", result, "branchSelections:", JSON.stringify(branchSelections));
    return result;
  }

  function promptCommonZoneBranch(context) {
    let attempts = 0;
    // Utiliser la branche d√©tect√©e par GPS si disponible, sinon celle sauvegard√©e, sinon "central"
    let currentDetected = null;
    if (state.lastLat != null && state.lastLon != null) {
      const detected = detectBranch(state.lastLat, state.lastLon);
      if (detected === "boissy") {
        currentDetected = "boissy";
      } else if (detected === "central" || detected === "both") {
        currentDetected = "central";
      }
    }
    // Si pas de d√©tection GPS, utiliser currentBranch (qui peut √™tre mis √† jour par la d√©tection pr√©c√©dente)
    if (!currentDetected) {
      currentDetected = currentBranch === "boissy" ? "boissy" : (currentBranch === "central" || currentBranch === "both" ? "central" : null);
    }
    const defaultBranch = branchSelections[context] === "boissy" ? "boissy" : (currentDetected || "central");
    while (attempts < 3) {
      const input = window.prompt(
        "Le PK se situe dans la zone commune (Boissy / Tron√ßon central). Indique la branche : boissy ou central.",
        defaultBranch
      );
      if (input == null) {
        break;
      }
      const normalized = normalizeBranchInput(input);
      if (normalized === "boissy" || normalized === "central") {
        setBranchSelection(context, normalized);
        return normalized;
      }
      alert("R√©ponse non reconnue. Tape ¬´ boissy ¬ª ou ¬´ central ¬ª.");
      attempts += 1;
    }
    // Si annul√©, on utilise la branche d√©tect√©e ou "central" par d√©faut, sans forcer l'override
    const fallback = currentDetected || "central";
    setBranchSelection(context, fallback, { skipManualOverride: true });
    return fallback;
  }

  function ensureBranchForPk(pk, context) {
    const contextKey = branchSelections.hasOwnProperty(context) ? context : BRANCH_SELECTION_CONTEXTS.search;
    const selection = getContextBranch(contextKey);
    if (selection && selection !== "auto") {
      return selection;
    }
    if (Number.isFinite(pk) && pk >= COMMON_BRANCH_PROMPT_MIN && pk <= COMMON_BRANCH_PROMPT_MAX) {
      const resolved = promptCommonZoneBranch(contextKey);
      if (resolved && resolved !== "auto") {
        applyManualOverrideForBranch(resolved);
      }
      return resolved;
    }
    if (selection === "auto" && manualBranchOverride) {
      return manualBranchOverride;
    }
    return selection || "auto";
  }

  function distanceMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  function computeBearing(lat1, lon1, lat2, lon2) {
    if (
      !Number.isFinite(lat1) || !Number.isFinite(lon1) ||
      !Number.isFinite(lat2) || !Number.isFinite(lon2)
    ) {
      return null;
    }
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;
    const œÜ1 = toRad(lat1);
    const œÜ2 = toRad(lat2);
    const ŒîŒª = toRad(lon2 - lon1);
    const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
    const x = Math.cos(œÜ1) * Math.sin(œÜ2) - Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
    if (x === 0 && y === 0) {
      return null;
    }
    const Œ∏ = Math.atan2(y, x);
    return (toDeg(Œ∏) + 360) % 360;
  }

  function projectForward(lat, lon, distanceMeters, bearingDegrees) {
    if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(distanceMeters) || !Number.isFinite(bearingDegrees)) {
      return { lat, lon };
    }
    const R = 6378137; // Rayon moyen de la Terre (WGS84)
    const Œ¥ = distanceMeters / R;
    const Œ∏ = bearingDegrees * Math.PI / 180;
    const œÜ1 = lat * Math.PI / 180;
    const Œª1 = lon * Math.PI / 180;

    const sinœÜ1 = Math.sin(œÜ1);
    const cosœÜ1 = Math.cos(œÜ1);
    const sinŒ¥ = Math.sin(Œ¥);
    const cosŒ¥ = Math.cos(Œ¥);
    const sinŒ∏ = Math.sin(Œ∏);
    const cosŒ∏ = Math.cos(Œ∏);

    const sinœÜ2 = sinœÜ1 * cosŒ¥ + cosœÜ1 * sinŒ¥ * cosŒ∏;
    const œÜ2 = Math.asin(sinœÜ2);
    const y = sinŒ∏ * sinŒ¥ * cosœÜ1;
    const x = cosŒ¥ - sinœÜ1 * sinœÜ2;
    const Œª2 = Œª1 + Math.atan2(y, x);

    return {
      lat: œÜ2 * 180 / Math.PI,
      lon: ((Œª2 * 180 / Math.PI + 540) % 360) - 180 // normalisation -180/+180
    };
  }
  function projectToSegment(lat, lon, a, b) {
    const meanLat = (a.lat + b.lat) / 2 * Math.PI/180;
    const cosLat = Math.cos(meanLat);

    const ax = a.lon * cosLat;
    const ay = a.lat;
    const bx = b.lon * cosLat;
    const by = b.lat;
    const px = lon * cosLat;
    const py = lat;

    const vx = bx - ax;
    const vy = by - ay;
    const wx = px - ax;
    const wy = py - ay;

    const c1 = vx * wx + vy * wy;
    const c2 = vx * vx + vy * vy;
    let t = c2 > 0 ? c1 / c2 : 0;
    if (t < 0) t = 0;
    if (t > 1) t = 1;

    const latProj = a.lat + (b.lat - a.lat) * t;
    const lonProj = a.lon + (b.lon - a.lon) * t;
    const pkProj = a.pk + (b.pk - a.pk) * t;
    const dist = distanceMeters(lat, lon, latProj, lonProj);

    return { latProj, lonProj, pkProj, dist };
  }

  function roughBranchFromLatLon(lat, lon) {
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
      return "central";
    }

    let minTronc = Infinity;
    let pkTronc = null;

    for (let i = 0; i < troncCommun.length - 1; i++) {
      const a = troncCommun[i];
      const b = troncCommun[i + 1];
      if (a.lat == null || a.lon == null || b.lat == null || b.lon == null) continue;

      const proj = projectToSegment(lat, lon, a, b);
      if (proj.dist < minTronc) {
        minTronc = proj.dist;
        pkTronc = proj.pkProj;
      }
    }

    if (minTronc < 300 && pkTronc != null && pkTronc <= BRANCH_COMMON_MAX) {
      return "central";
    }

    let dBoissy = Infinity;
    let dChessy = Infinity;

    for (let i = 0; i < Math.min(3, brancheBoissy.length); i++) {
      const ref = brancheBoissy[i];
      if (ref.lat == null || ref.lon == null) continue;
      const d = distanceMeters(lat, lon, ref.lat, ref.lon);
      if (d < dBoissy) dBoissy = d;
    }

    for (let i = 0; i < Math.min(3, brancheChessy.length); i++) {
      const ref = brancheChessy[i];
      if (ref.lat == null || ref.lon == null) continue;
      const d = distanceMeters(lat, lon, ref.lat, ref.lon);
      if (d < dChessy) dChessy = d;
    }

    if (Math.abs(dBoissy - dChessy) < 100) {
      return "central";
    }

    return dBoissy < dChessy ? "boissy" : "chessy";
  }

  function normalizeBranchKey(branchKey) {
    if (branchKey === "boissy" || branchKey === "chessy") {
      return branchKey;
    }
    if (branchKey === "central" || branchKey === "both") {
      return "central";
    }
    return "central";
  }

  function determineCalibrationBranch(pk, branchHint, lat, lon) {
    let branch = branchHint;

    if (branch === "both") {
      branch = "central";
    }

    if (branch === "boissy" || branch === "chessy" || branch === "central") {
      return branch;
    }

    if (Number.isFinite(pk)) {
      if (pk <= BRANCH_COMMON_MAX) {
        return "central";
      }
    }

    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      const inferred = roughBranchFromLatLon(lat, lon);
      if (inferred === "boissy" || inferred === "chessy") {
        return inferred;
      }
    }

    return "central";
  }

  function computeCalibrationOffsetFromEntry(entry) {
    if (!entry || typeof entry !== "object") {
      return null;
    }
    if (Number.isFinite(entry.offset)) {
      return entry.offset;
    }
    if (Number.isFinite(entry.pkOffset)) {
      return entry.pkOffset;
    }
    const pkExact = Number.isFinite(entry.pkExact) ? entry.pkExact : (Number.isFinite(entry.pk) ? entry.pk : null);
    let pkRaw = null;
    if (Number.isFinite(entry.pkRaw)) {
      pkRaw = entry.pkRaw;
    } else if (Number.isFinite(entry.pkExact) && Number.isFinite(entry.pkOffset)) {
      pkRaw = entry.pkExact - entry.pkOffset;
    }
    if (pkExact != null && pkRaw != null) {
      return pkExact - pkRaw;
    }
    return null;
  }

  function buildCalibrationSegmentsForBranch(points) {
    if (!Array.isArray(points) || !points.length) {
      return [];
    }
    if (points.length === 1) {
      const center = points[0];
      return [{
        type: "single",
        center,
        start: center.pk - CALIBRATION_SINGLE_RADIUS,
        end: center.pk + CALIBRATION_SINGLE_RADIUS,
        radius: CALIBRATION_SINGLE_RADIUS
      }];
    }
    const segments = [];
    for (let i = 0; i < points.length - 1; i++) {
      const left = points[i];
      const right = points[i + 1];
      if (!Number.isFinite(left.pk) || !Number.isFinite(right.pk)) continue;
      if (right.pk <= left.pk) continue;
      segments.push({
        type: "pair",
        left,
        right,
        start: left.pk,
        end: right.pk
      });
    }
    return segments;
  }

  function updateCalibrationAdjustments(sourceByBranch) {
    const branches = ["central", "boissy", "chessy"];
    branches.forEach(branch => {
      const arr = Array.isArray(sourceByBranch[branch]) ? sourceByBranch[branch].slice() : [];
      arr.sort((a, b) => a.pk - b.pk);
      calibrationControlPoints[branch] = arr;
      calibrationSegments[branch] = buildCalibrationSegmentsForBranch(arr);
    });
  }

  function computeOffsetFromSegments(pk, segments) {
    if (!Array.isArray(segments) || !segments.length) {
      return null;
    }
    for (const segment of segments) {
      if (segment.type === "pair") {
        const left = segment.left;
        const right = segment.right;
        if (pk < left.pk || pk > right.pk) continue;
        const span = right.pk - left.pk;
        if (!(span > 0)) continue;
        const t = (pk - left.pk) / span;
        return left.offset + (right.offset - left.offset) * t;
      } else if (segment.type === "single") {
        if (pk < segment.start || pk > segment.end) continue;
        const radius = segment.radius;
        if (!(radius > 0)) {
          return segment.center.offset;
        }
        const dist = Math.abs(pk - segment.center.pk);
        const factor = Math.max(0, 1 - dist / radius);
        return segment.center.offset * factor;
      }
    }
    return null;
  }

  function getCalibrationOffsetForPk(pk, branchKey) {
    if (!Number.isFinite(pk)) {
      return 0;
    }
    const normalized = normalizeBranchKey(branchKey);
    
    // Filtrage strict par branche : ne chercher QUE dans la branche demand√©e
    // Exception : si on est sur le tronc commun (pk <= 30000), on peut utiliser "central"
    // Mais pour Boissy/Chessy, on ne cherche QUE dans leur branche respective
    
    if (normalized === "boissy") {
      // Pour Boissy : uniquement si PK > 30000 (hors tronc commun)
      if (pk > BRANCH_COMMON_MAX && pk >= BRANCH_BOISSY_MIN && pk <= BRANCH_BOISSY_MAX) {
        const offset = computeOffsetFromSegments(pk, calibrationSegments["boissy"]);
        if (offset != null) return offset;
      }
      // Si dans le tronc commun, utiliser central
      if (pk <= BRANCH_COMMON_MAX) {
        const offset = computeOffsetFromSegments(pk, calibrationSegments["central"]);
        if (offset != null) return offset;
      }
    } else if (normalized === "chessy") {
      // Pour Chessy : uniquement si PK > 30000 (hors tronc commun)
      if (pk > BRANCH_COMMON_MAX && pk >= BRANCH_CHESSY_MIN && pk <= BRANCH_CHESSY_MAX) {
        const offset = computeOffsetFromSegments(pk, calibrationSegments["chessy"]);
        if (offset != null) return offset;
      }
      // Si dans le tronc commun, utiliser central
      if (pk <= BRANCH_COMMON_MAX) {
        const offset = computeOffsetFromSegments(pk, calibrationSegments["central"]);
        if (offset != null) return offset;
      }
    } else {
      // Pour central : uniquement le tronc commun
      if (pk <= BRANCH_COMMON_MAX) {
        const offset = computeOffsetFromSegments(pk, calibrationSegments["central"]);
        if (offset != null) return offset;
      }
    }
    
    return 0;
  }

  function computePkWithCalibrations(pkRaw, branchKey) {
    if (!Number.isFinite(pkRaw)) {
      return pkRaw;
    }
    const normalized = normalizeBranchKey(branchKey);
    const localOffset = getCalibrationOffsetForPk(pkRaw, normalized);
    const pkWithCalibrations = pkRaw + pkOffset + localOffset;
    
    // Appliquer le saut d'affichage pour les discontinuit√©s PK
    // Utiliser les coordonn√©es GPS actuelles si disponibles
    const lat = state.lastLat;
    const lon = state.lastLon;
    return applyPkDisplayJump(pkWithCalibrations, lat, lon, normalized);
  }
  function projectToLine(lat, lon) {
    let best = { dist: Infinity, pkProj: null, latProj: null, lonProj: null };
    
    // V√©rification de s√©curit√©
    if (!linePoints || linePoints.length < 2) {
      console.warn("‚ö†Ô∏è projectToLine: linePoints invalide ou vide. linePoints:", linePoints, "length:", linePoints ? linePoints.length : 0);
      return best;
    }
    
    // Compter les points valides (avec GPS)
    let validPointsCount = 0;
    for (const pt of linePoints) {
      if (pt.lat != null && pt.lon != null) validPointsCount++;
    }
    
    if (validPointsCount < 2) {
      console.warn("‚ö†Ô∏è projectToLine: Pas assez de points avec GPS. Valid:", validPointsCount, "Total:", linePoints.length, "branche:", currentBranch);
      return best;
    }
    
    // M√©thode 1 : Projection sur les segments de la ligne (m√©thode classique)
    for (let i = 0; i < linePoints.length - 1; i++) {
      const a = linePoints[i];
      const b = linePoints[i+1];
      
      // Ignorer les points sans coordonn√©es GPS
      if (a.lat == null || a.lon == null || b.lat == null || b.lon == null) continue;
      
      const res = projectToSegment(lat, lon, a, b);
      if (res.dist < best.dist) {
        best = { dist: res.dist, pkProj: res.pkProj, latProj: res.latProj, lonProj: res.lonProj };
      }
    }
    
    // Si aucune projection n'a √©t√© trouv√©e, c'est un probl√®me
    if (best.pkProj == null) {
      console.warn("‚ö†Ô∏è projectToLine: Aucune projection trouv√©e. linePoints.length:", linePoints.length, "validPoints:", validPointsCount, "branche:", currentBranch);
      return best;
    }
    
    // M√©thode 2 : Interpolation pond√©r√©e bas√©e sur TOUS les points GPS connus (affinage)
    // Utilise les accessPoints + les points de calibration pour am√©liorer la pr√©cision
    const nearbyPoints = [];
    
    // 1) Points issus des accessPoints (191 acc√®s + gares ajout√©es)
    for (const acc of accessPoints) {
      if (acc.lat == null || acc.lon == null || acc.pk == null) continue;
      const d = distanceMeters(lat, lon, acc.lat, acc.lon);
      // On garde les points dans un rayon de 1000m pour l'interpolation (augment√© de 500m)
      if (d < 1000) {
        nearbyPoints.push({ pk: acc.pk, lat: acc.lat, lon: acc.lon, dist: d, weight: 1.0 });
      }
    }
    
    // 2) Points issus des recalages PK (local + partag√©) - ces points sont plus pr√©cis
    const allCals = [];
    if (Array.isArray(sharedCalibrations)) allCals.push(...sharedCalibrations);
    if (Array.isArray(localCalibrations))  allCals.push(...localCalibrations);
    
    for (const c of allCals) {
      if (!c || c.lat == null || c.lon == null) continue;
      const pk = c.pkExact != null ? c.pkExact : c.pk;
      if (pk == null) continue;
      const d = distanceMeters(lat, lon, c.lat, c.lon);
      // Les points de calibration sont plus pr√©cis, on les garde dans un rayon de 3000m (augment√© de 1000m)
      // et on leur donne un poids plus √©lev√© (2.0 au lieu de 1.0) car ce sont des mesures calibr√©es
      if (d < 3000) {
        // Ajuster le poids selon l'accuracy GPS du point de calibration (si disponible)
        // Plus l'accuracy est bonne (faible valeur), plus le poids est √©lev√©
        let calibWeight = 2.0;
        if (c.accuracy != null && c.accuracy > 0) {
          // Si accuracy < 10m, poids maximal (2.5), sinon d√©gressif
          if (c.accuracy < 10) calibWeight = 2.5;
          else if (c.accuracy < 20) calibWeight = 2.2;
          else if (c.accuracy < 50) calibWeight = 2.0;
          else calibWeight = 1.8;
        }
        nearbyPoints.push({ pk: pk, lat: c.lat, lon: c.lon, dist: d, weight: calibWeight });
      }
    }
    
    // Si on a des points GPS proches, on affine le calcul
    if (nearbyPoints.length >= 1) {
      // Tri par distance
      nearbyPoints.sort((a, b) => a.dist - b.dist);
      
      // Interpolation pond√©r√©e : on utilise jusqu'√† 10 points les plus proches (augment√© de 5)
      // Plus on a de points GPS, plus la pr√©cision est grande
      const maxPoints = Math.min(10, nearbyPoints.length);
      const topPoints = nearbyPoints.slice(0, maxPoints);
      
      // Calcul du poids inverse de la distance (plus proche = plus de poids)
      let totalWeight = 0;
      let weightedPk = 0;
      
      for (const pt of topPoints) {
        // Poids = (weight * 1) / (distance + 1)^0.8 pour √©viter division par z√©ro
        // Utilisation d'une fonction exponentielle pour donner plus de poids aux points proches
        // Les points de calibration ont un poids plus √©lev√© (2.0 vs 1.0)
        const weight = (pt.weight || 1.0) / Math.pow(pt.dist + 1, 0.8);
        totalWeight += weight;
        weightedPk += pt.pk * weight;
      }
      
      if (totalWeight > 0) {
        const interpolatedPk = weightedPk / totalWeight;
        
        // On combine la projection sur la ligne (m√©thode 1) avec l'interpolation GPS (m√©thode 2)
        const minDist = topPoints[0].dist;
        
        let finalPk = null;
        if (minDist < 50) {
          // Tr√®s proche d'un point GPS connu (< 50m) : on privil√©gie fortement l'interpolation
          finalPk = interpolatedPk;
          best.dist = minDist;
        } else if (minDist < 200) {
          // Proche d'un point GPS connu (< 200m) : on privil√©gie l'interpolation
          if (best.pkProj != null) {
            finalPk = best.pkProj * 0.3 + interpolatedPk * 0.7;
          } else {
            finalPk = interpolatedPk;
          }
        } else if (minDist < 500 && best.pkProj != null) {
          // Moyennement proche (< 500m) : on combine les deux m√©thodes
          const projectionWeight = best.dist < 100 ? 0.5 : 0.4;
          const interpolationWeight = 1 - projectionWeight;
          finalPk = best.pkProj * projectionWeight + interpolatedPk * interpolationWeight;
        } else if (minDist < 1000 && best.pkProj != null) {
          // Assez proche (< 1000m) : on utilise l'interpolation comme correction
          const projectionWeight = 0.7;
          const interpolationWeight = 0.3;
          finalPk = best.pkProj * projectionWeight + interpolatedPk * interpolationWeight;
        } else if (minDist < 2000 && best.pkProj != null) {
          // Loin mais dans le rayon (< 2000m) : on utilise l'interpolation comme correction l√©g√®re
          const projectionWeight = 0.85;
          const interpolationWeight = 0.15;
          finalPk = best.pkProj * projectionWeight + interpolatedPk * interpolationWeight;
        }
        
        // Appliquer l'arrondi √† 10800 ou 11300 si dans la zone de saut (d√©coupage strict)
        if (finalPk != null) {
          best.pkProj = roundPkToDiscontinuityBounds(finalPk, currentBranch);
        }
      }
    }
    
    // Appliquer l'arrondi √† 10800 ou 11300 si dans la zone de saut (pour la projection directe aussi)
    if (best.pkProj != null) {
      best.pkProj = roundPkToDiscontinuityBounds(best.pkProj, currentBranch);
    }
    
    return best;
  }

  branchSelectionButtons[BRANCH_SELECTION_CONTEXTS.search] = btnBranchSearch;
  branchSelectionButtons[BRANCH_SELECTION_CONTEXTS.coverage] = btnBranchCoverage;
  branchSelectionButtons[BRANCH_SELECTION_CONTEXTS.target] = btnBranchTarget;
  branchSelectionButtons[BRANCH_SELECTION_CONTEXTS.incident] = btnBranchIncident;
  branchSelectionButtons[BRANCH_SELECTION_CONTEXTS.geoloc] = btnBranchGeoloc;

  // Gestion des menus d√©roulants pour le choix de branche (initialis√© apr√®s le chargement du DOM)
  function initBranchMenus() {
    debugLog("üîß Initialisation des menus de branche...");
    const branchMenuMap = {
      [BRANCH_SELECTION_CONTEXTS.search]: { button: btnBranchSearch, menu: document.getElementById("branchMenuSearch") },
      [BRANCH_SELECTION_CONTEXTS.coverage]: { button: btnBranchCoverage, menu: document.getElementById("branchMenuCoverage") },
      [BRANCH_SELECTION_CONTEXTS.target]: { button: btnBranchTarget, menu: document.getElementById("branchMenuTarget") },
      [BRANCH_SELECTION_CONTEXTS.incident]: { button: btnBranchIncident, menu: document.getElementById("branchMenuIncident") },
      [BRANCH_SELECTION_CONTEXTS.recal]: { button: btnBranchRecal, menu: document.getElementById("branchMenuRecal") },
      [BRANCH_SELECTION_CONTEXTS.geoloc]: { button: btnBranchGeoloc, menu: document.getElementById("branchMenuGeoloc") }
    };
    
    // V√©rifier que tous les boutons et menus existent
    Object.keys(branchMenuMap).forEach(context => {
      const { button, menu } = branchMenuMap[context];
      if (!button) {
        console.error("‚ùå Bouton manquant pour le contexte:", context);
      }
      if (!menu) {
        console.error("‚ùå Menu manquant pour le contexte:", context);
      }
      if (button && menu) {
        debugLog("‚úÖ Menu initialis√© pour:", context, "bouton:", button.textContent);
      }
    });

    // Fermer tous les menus sauf celui sp√©cifi√©
    function closeAllBranchMenus(exceptContext = null) {
      Object.keys(branchMenuMap).forEach(context => {
        if (context === exceptContext) return;
        const { button, menu } = branchMenuMap[context];
        if (button && menu) {
          button.setAttribute("aria-expanded", "false");
          menu.hidden = true;
        }
      });
    }

    // G√©rer l'ouverture/fermeture des menus
    Object.keys(branchMenuMap).forEach(context => {
      const { button, menu } = branchMenuMap[context];
      if (!button || !menu) return;

      button.addEventListener("click", (e) => {
        e.stopPropagation();
        const isExpanded = button.getAttribute("aria-expanded") === "true";
        closeAllBranchMenus(isExpanded ? context : null);
        if (!isExpanded) {
          button.setAttribute("aria-expanded", "true");
          menu.hidden = false;
        } else {
          button.setAttribute("aria-expanded", "false");
          menu.hidden = true;
        }
      });

      // G√©rer les clics sur les options du menu
      menu.querySelectorAll("button[data-branch]").forEach(option => {
        option.addEventListener("click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          const branch = option.getAttribute("data-branch");
          const contextKey = option.getAttribute("data-context");
          debugLog("üñ±Ô∏è Clic sur option menu - branch:", branch, "contextKey:", contextKey);
          if (branch && contextKey) {
            debugLog("üéØ Choix de branche dans le menu:", branch, "pour le contexte:", contextKey);
            // Sauvegarder le choix dans le contexte (cela met aussi √† jour le texte du bouton)
            setBranchSelection(contextKey, branch);
            debugLog("‚úÖ Choix sauvegard√©, bouton mis √† jour:", branchValueToLabel(branch));
            
            // V√©rifier imm√©diatement apr√®s la sauvegarde
            const verifyValue = getContextBranch(contextKey);
            debugLog("üîç V√©rification apr√®s sauvegarde - getContextBranch retourne:", verifyValue);
            
            // Forcer l'override global pour que la g√©olocalisation l'utilise (uniquement pour le contexte geoloc)
            if (contextKey === BRANCH_SELECTION_CONTEXTS.geoloc) {
              if (branch !== "auto") {
                debugLog("üîß Application de l'override global pour g√©oloc:", branch);
                setManualBranchOverride(branch);
              } else {
                debugLog("üîß Suppression de l'override global (retour √† auto)");
                setManualBranchOverride("auto");
              }
            }
            
            button.setAttribute("aria-expanded", "false");
            menu.hidden = true;
            debugLog("‚úÖ Branche", branch, "appliqu√©e pour le contexte", contextKey, "- Bouton:", button.textContent);
          } else {
            console.error("‚ùå Donn√©es manquantes - branch:", branch, "contextKey:", contextKey);
          }
        });
      });
    });

    // Fermer les menus quand on clique ailleurs
    document.addEventListener("click", (e) => {
      if (!e.target.closest(".branch-choice-menu-container")) {
        closeAllBranchMenus();
      }
    });
  }

  // Initialiser les menus apr√®s le chargement du DOM
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBranchMenus);
  } else {
    initBranchMenus();
  }

  if (inputPkLookup) {
    inputPkLookup.addEventListener("keydown", event => {
      if (event.key === "Enter") {
        event.preventDefault();
        handlePkLookup().catch(err => console.error("handlePkLookup error", err));
      }
    });
    inputPkLookup.addEventListener("input", () => {
      updatePkLookupSuggestionsList(inputPkLookup.value);
    });
  }

  // ... (rest of the code remains unchanged)
function buildCalibrationPolylines() {
  // Cache : ne reconstruire que si n√©cessaire (nouveau recalage ou cache expir√©)
  const now = Date.now();
  if (now - lastCalibrationBuildTime < CALIBRATION_CACHE_MS && linePointsBoissy && linePointsChessy) {
    return; // Utiliser le cache
  }
  lastCalibrationBuildTime = now;
  
  const calibTronc  = [];
  const calibBoissy = [];
  const calibChessy = [];

  const calibrationPointsByBranch = { central: [], boissy: [], chessy: [] };

  // Ajoute un point de calibration dans les bons tableaux
  function addCalibPoint(pk, lat, lon, branchHint) {
    if (pk == null || lat == null || lon == null) return null;
    const calPoint = { pk, lat, lon };

    if (pk <= BRANCH_COMMON_MAX) {
      calibTronc.push(calPoint);
      return "central";
    }

    const resolved = determineCalibrationBranch(pk, branchHint, lat, lon);

    if (resolved === "boissy") {
      calibBoissy.push(calPoint);
      return "boissy";
    }
    if (resolved === "chessy") {
      calibChessy.push(calPoint);
      return "chessy";
    }

    calibTronc.push(calPoint);
    return "central";
  }

  // 1) Points issus des accessPoints eux-m√™mes (tes 191 acc√®s + les gares ajout√©es)
  for (const acc of accessPoints) {
    addCalibPoint(acc.pk, acc.lat, acc.lon, acc.branch);
  }

  // 2) Points issus des recalages PK (local + partag√©)
  const allCals = [];
  if (Array.isArray(sharedCalibrations)) allCals.push(...sharedCalibrations);
  if (Array.isArray(localCalibrations))  allCals.push(...localCalibrations);

  for (const c of allCals) {
    if (!c) continue;
    const pk = c.pkExact != null ? c.pkExact : c.pk;
    if (pk == null) continue;
    
    // D√©terminer la branche du point de calibration de mani√®re stricte
    const calBranch = determineCalibrationBranch(pk, c.branch, c.lat, c.lon);
    const branchUsed = addCalibPoint(pk, c.lat, c.lon, calBranch);
    const offset = computeCalibrationOffsetFromEntry(c);
    
    // Filtrer strictement : n'ajouter que si la branche d√©termin√©e correspond
    if (branchUsed && Number.isFinite(offset) && branchUsed === calBranch) {
      const normalized = normalizeBranchKey(branchUsed);
      if (!calibrationPointsByBranch[normalized]) {
        calibrationPointsByBranch[normalized] = [];
      }
      calibrationPointsByBranch[normalized].push({ pk, offset });
    }
  }

  updateCalibrationAdjustments(calibrationPointsByBranch);

  // Tri par PK
  calibTronc.sort((a, b) => a.pk - b.pk);
  calibBoissy.sort((a, b) => a.pk - b.pk);
  calibChessy.sort((a, b) => a.pk - b.pk);

  // V√©rification de s√©curit√© : s'assurer que troncCommun, brancheBoissy et brancheChessy sont des tableaux
  const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
  const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
  const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];

  // Poly-ligne calibr√©e Boissy = tronc commun + branche Boissy + points de calibration
  linePointsBoissy = safeTroncCommun
    .concat(calibTronc, safeBrancheBoissy, calibBoissy)
    .sort((a, b) => a.pk - b.pk);

  // Poly-ligne calibr√©e Chessy = tronc commun + branche Chessy + points de calibration
  linePointsChessy = safeTroncCommun
    .concat(calibTronc, safeBrancheChessy, calibChessy)
    .sort((a, b) => a.pk - b.pk);
  
  // S'assurer que les tableaux ne sont jamais null (au moins des tableaux vides)
  if (!Array.isArray(linePointsBoissy)) {
    linePointsBoissy = safeTroncCommun.concat(safeBrancheBoissy);
  }
  if (!Array.isArray(linePointsChessy)) {
    linePointsChessy = safeTroncCommun.concat(safeBrancheChessy);
  }
  
  // Initialiser linePoints par d√©faut si pas encore d√©fini
  if (!linePoints || linePoints.length === 0) {
    linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
    console.log("linePoints initialis√© par d√©faut (Chessy), longueur:", linePoints.length);
  }
  
  console.log("Polylignes construites - Boissy:", linePointsBoissy ? linePointsBoissy.length : 0, 
              "Chessy:", linePointsChessy ? linePointsChessy.length : 0);
}
  function findNearestStation(pk, branch) {
    if (pk == null) return null;
    
    // IMPORTANT : pk est toujours en absolu (m√™me si l'utilisateur voit du relatif √† l'√©cran)
    // Les stations ont toujours leur PK en absolu dans st.pk
    // Donc la comparaison est correcte : absolu vs absolu
    
    let list;
    const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
    const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
    const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];
    
    // Normaliser la branche pour la comparaison
    const normalizedBranch = branch ? normalizeBranchKey(branch) : null;
    
    if (normalizedBranch === "boissy") {
      list = safeTroncCommun.concat(safeBrancheBoissy);
    } else if (normalizedBranch === "chessy") {
      list = safeTroncCommun.concat(safeBrancheChessy);
    } else {
      // Pour "both" ou "central", utiliser toutes les stations mais filtrer intelligemment
      // Si PK > 30000, on est probablement sur une branche, donc filtrer selon le PK
      if (pk > BRANCH_COMMON_MAX) {
        // D√©terminer la branche selon le PK
        if (pk >= BRANCH_CHESSY_MIN) {
          list = safeTroncCommun.concat(safeBrancheChessy);
        } else if (pk >= BRANCH_BOISSY_MIN) {
          list = safeTroncCommun.concat(safeBrancheBoissy);
        } else {
          list = stations;
        }
      } else {
        list = stations;
      }
    }
    
    let best = null;
    let bestDiff = Infinity;
    for (const st of list) {
      if (st.pk == null) continue;
      // Comparaison absolu vs absolu (toujours correct)
      const d = Math.abs(st.pk - pk);
      if (d < bestDiff) {
        bestDiff = d;
        best = st;
      }
    }
    return best;
  }

  // Constantes pour le calcul de couverture travaux
  const PETARD_SPACING = 30; // m
  const SAM_OFFSET = 100;    // m (SAM √† 100m du PK de chantier)
  const DISTANCE_RULE_STANDARD = 800;   // m (premier p√©tard √† 800m du SAM)
  const DISTANCE_RULE_TORCY_CHESSY = 1000; // m (premier p√©tard √† 1000m du SAM entre Torcy PK 48000 et Chessy)
  const TORCY_CHESSY_ZONE_START = 48000; // PK de d√©but de la zone sp√©ciale (Torcy)
  const TORCY_CHESSY_ZONE_END = 59300;    // PK de fin de la zone sp√©ciale (Chessy)

  // D√©termine la distance √† utiliser selon la position
  function getPetardDistance(pkSam, direction, pkChantier) {
    // direction = "est" (PK augmente) ou "ouest" (PK diminue)
    // V√©rifier si le SAM ou le chantier sont dans la zone Torcy-Chessy
    // La zone sp√©ciale s'applique entre Torcy (PK 48000) et Chessy (PK 59300)
    const pkToCheck = pkChantier != null ? pkChantier : pkSam;
    
    // Si le SAM ou le chantier sont dans la zone Torcy-Chessy, utiliser 1000m
    if (pkToCheck >= TORCY_CHESSY_ZONE_START && pkToCheck <= TORCY_CHESSY_ZONE_END) {
      return DISTANCE_RULE_TORCY_CHESSY;
    }
    // V√©rifier aussi si le SAM lui-m√™me est dans la zone
    if (pkSam >= TORCY_CHESSY_ZONE_START && pkSam <= TORCY_CHESSY_ZONE_END) {
      return DISTANCE_RULE_TORCY_CHESSY;
    }
    return DISTANCE_RULE_STANDARD;
  }

  // Cr√©e les 3 p√©tards espac√©s de 30 m
  function makePetards(basePk, direction) {
    // direction = "est" (PK augmente) ou "ouest" (PK diminue)
    const sign = direction === "est" ? 1 : -1;
    const railOrder = ["droite", "gauche", "droite"];
    const branchForCoverage = currentBranch || "central";
    return railOrder.map((rail, index) => {
      let pk = basePk + sign * index * PETARD_SPACING;
      // Arrondir si dans la zone de saut (d√©coupage strict)
      pk = roundPkToDiscontinuityBounds(pk, branchForCoverage);
      return {
        order: index + 1,
        railFile: rail,
        pk: pk,
      };
    });
  }
  // Fonction principale pour calculer les marqueurs de couverture
  function computeCoverageMarkers(pkStart, pkEnd) {
    const results = [];
    const branchForCoverage = currentBranch || "central";

    if (Number.isFinite(pkStart)) {
      // C√¥t√© PK d√©but : SAM √† 100m en direction St-Germain (PK diminue)
      // Exemple : PK chantier 48000 ‚Üí SAM √† 47900
      let pkSamStart = pkStart - SAM_OFFSET;
      // Arrondir si dans la zone de saut (d√©coupage strict)
      pkSamStart = roundPkToDiscontinuityBounds(pkSamStart, branchForCoverage);
      
      // D√©terminer la distance √† utiliser selon la zone
      const distanceStart = getPetardDistance(pkSamStart, "ouest", pkStart);
      
      // Premier p√©tard √† distance du SAM (donc en amont du SAM)
      // Exemple : SAM 47900 ‚Üí premier p√©tard √† 47100 (47900 - 800) ou 46900 (47900 - 1000)
      let pkPetardsStart = pkSamStart - distanceStart;
      // Arrondir si dans la zone de saut
      pkPetardsStart = roundPkToDiscontinuityBounds(pkPetardsStart, branchForCoverage);
      
      const petardsStart = makePetards(pkPetardsStart, "ouest");

      results.push({
        side: "pkStart",
        pkSamRep: pkSamStart,
        petards: petardsStart,
        distanceRule: distanceStart,
        rationale: `SAM √† ${SAM_OFFSET} m en direction St-Germain, 3 p√©tards espac√©s de ${PETARD_SPACING} m en amont √† ${distanceStart} m`,
      });
    }

    if (Number.isFinite(pkEnd)) {
      // C√¥t√© PK fin : SAM √† 100m en direction Chessy/Boissy (PK augmente)
      // Exemple : PK chantier 49000 ‚Üí SAM √† 49100
      let pkSamEnd = pkEnd + SAM_OFFSET;
      // Arrondir si dans la zone de saut (d√©coupage strict)
      pkSamEnd = roundPkToDiscontinuityBounds(pkSamEnd, branchForCoverage);
      
      // D√©terminer la distance √† utiliser selon la zone
      const distanceEnd = getPetardDistance(pkSamEnd, "est", pkEnd);
      
      // Premier p√©tard √† distance du SAM (donc en amont du SAM)
      // Exemple : SAM 49100 ‚Üí premier p√©tard √† 49900 (49100 + 800) ou 50100 (49100 + 1000)
      let pkPetardsEnd = pkSamEnd + distanceEnd;
      // Arrondir si dans la zone de saut
      pkPetardsEnd = roundPkToDiscontinuityBounds(pkPetardsEnd, branchForCoverage);
      
      const petardsEnd = makePetards(pkPetardsEnd, "est");

      results.push({
        side: "pkEnd",
        pkSamRep: pkSamEnd,
        petards: petardsEnd,
        distanceRule: distanceEnd,
        rationale: `SAM √† ${SAM_OFFSET} m en direction Chessy/Boissy, 3 p√©tards espac√©s de ${PETARD_SPACING} m en amont √† ${distanceEnd} m`,
      });
    }

    if (!results.length) {
      throw new Error("Aucun PK valide fourni pour le calcul.");
    }

    // Calculer la distance maximale utilis√©e pour l'affichage
    const maxDistance = Math.max(...results.map(r => r.distanceRule || DISTANCE_RULE_STANDARD));

    return {
      lineId: "RERA",
      bySide: results,
      distanceRule: maxDistance,
    };
  }

  function formatMetersReadable(meters) {
    if (meters == null || !Number.isFinite(meters)) return null;
    if (meters >= 1000) {
      const value = meters / 1000;
      return value.toLocaleString("fr-FR", { maximumFractionDigits: 1, minimumFractionDigits: 0 }) + " km";
    }
    return Math.round(meters) + " m";
  }

  function getNearestAccessDetails(lat, lon, pk, branchHint = null) {
    let nearest = null;
    let distanceText = null;

    // Si une branche est sp√©cifi√©e, privil√©gier findNearestAccess avec la branche
    // car findNearestAccessGeo ne filtre pas par branche
    if (branchHint && branchHint !== "auto" && pk != null) {
      debugLog("üîç getNearestAccessDetails : branche sp√©cifi√©e", branchHint, "‚Üí utilisation de findNearestAccess avec filtre");
      nearest = findNearestAccess(pk, branchHint);
      if (nearest && nearest.lat != null && nearest.lon != null && lat != null && lon != null) {
        const dist = distanceMeters(lat, lon, nearest.lat, nearest.lon);
        distanceText = formatMetersReadable(dist);
      }
    } else if (lat != null && lon != null) {
      // Sinon, utiliser findNearestAccessGeo (sans filtre de branche)
      nearest = findNearestAccessGeo(lat, lon);
      if (nearest && nearest.lat != null && nearest.lon != null) {
        const dist = distanceMeters(lat, lon, nearest.lat, nearest.lon);
        distanceText = formatMetersReadable(dist);
      }
    }

    // Fallback : si toujours pas d'acc√®s et qu'on a un PK, essayer sans filtre
    if (!nearest && pk != null) {
      nearest = findNearestAccess(pk, branchHint);
    }

    if (!nearest) {
      return null;
    }

    if (!distanceText && pk != null && nearest.pk != null) {
      const delta = Math.abs(nearest.pk - pk);
      distanceText = "ŒîPK ‚âà " + Math.round(delta) + " m";
    }

    return {
      name: nearest.name || "Acc√®s inconnu",
      pk: nearest.pk != null ? nearest.pk : null,
      distanceText,
      lat: nearest.lat != null ? nearest.lat : null,
      lon: nearest.lon != null ? nearest.lon : null,
      address: nearest.address || ""
    };
  }

  function createNavigationButtonsHTML(lat, lon, options = {}) {
    const { compact = false } = options;
    const latNum = Number(lat);
    const lonNum = Number(lon);
    if (!Number.isFinite(latNum) || !Number.isFinite(lonNum)) {
      return "";
    }
    const latStr = latNum.toFixed(6);
    const lonStr = lonNum.toFixed(6);
    const containerClass = compact ? "coverage-nav-buttons coverage-nav-buttons--compact" : "coverage-nav-buttons";
    const compactClass = compact ? " map-nav-btn--compact" : "";
    return `
      <div class="${containerClass}">
        <button type="button" class="map-nav-btn map-nav-btn--waze${compactClass}" data-nav-provider="waze" data-lat="${latStr}" data-lon="${lonStr}">Waze</button>
        <button type="button" class="map-nav-btn map-nav-btn--maps${compactClass}" data-nav-provider="google" data-lat="${latStr}" data-lon="${lonStr}">Maps</button>
      </div>
    `;
  }

  function createCoveragePopupContent(point, extra = {}) {
    const title = extra.label || point.title || "";
    const pkText = point.pk != null ? "PK " + formatPk(point.pk) : "";
    const access = point.nearestAccess;
    const accessText = access
      ? `üö™ <strong>${access.name}</strong>${access.pk != null ? " ¬∑ PK " + formatPk(access.pk) : ""}${access.distanceText ? " ¬∑ " + access.distanceText : ""}`
      : null;
    const navHtml = createNavigationButtonsHTML(point.lat, point.lon, { compact: true });
    return `
      <div class="coverage-popup">
        <div class="coverage-popup-title">${title}</div>
        <div class="coverage-popup-meta">${pkText}</div>
        ${accessText ? `<div class="coverage-popup-access">${accessText}</div>` : ""}
        ${navHtml ? `<div class="coverage-popup-actions">${navHtml}</div>` : ""}
      </div>
    `;
  }

  function openNavigationApp(provider, lat, lon) {
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
      alert("Coordonn√©es non disponibles pour la navigation.");
      return;
    }
    const latStr = lat.toFixed(6);
    const lonStr = lon.toFixed(6);
    let url = "";
    if (provider === "waze") {
      url = `https://waze.com/ul?ll=${latStr},${lonStr}&navigate=yes`;
    } else if (provider === "google") {
      url = `https://www.google.com/maps/dir/?api=1&destination=${latStr},${lonStr}`;
    } else {
      console.warn("Provider de navigation inconnu :", provider);
      return;
    }
    window.open(url, "_blank");
  }

  function ensureOrientationMapReady() {
    if (!orientationMap) {
      initOrientationMap();
    }
  }

  // Fonction pour obtenir les coordonn√©es GPS d'un PK donn√©
  function getGpsFromPk(targetPk) {
    if (targetPk == null || !linePoints || linePoints.length < 2) {
      return null;
    }

    // Convertir le PK d'affichage en PK m√©trique si n√©cessaire (gestion des discontinuit√©s)
    // D√©coupage strict : arrondir au plus proche (10800 ou 11300) si dans la zone
    const metricPk = convertDisplayPkToMetricPk(targetPk, currentBranch);

    // Trouver les deux points les plus proches du PK m√©trique
    let bestBefore = null;
    let bestAfter = null;
    let minDiffBefore = Infinity;
    let minDiffAfter = Infinity;

    for (let i = 0; i < linePoints.length; i++) {
      const pt = linePoints[i];
      if (pt.pk == null || pt.lat == null || pt.lon == null) continue;

      const diff = metricPk - pt.pk;
      if (diff === 0) {
        // PK exact trouv√©
        return { lat: pt.lat, lon: pt.lon };
      } else if (diff > 0 && diff < minDiffAfter) {
        // Point apr√®s le PK cible
        minDiffAfter = diff;
        bestAfter = pt;
      } else if (diff < 0 && Math.abs(diff) < minDiffBefore) {
        // Point avant le PK cible
        minDiffBefore = Math.abs(diff);
        bestBefore = pt;
      }
    }

    // Si on a trouv√© un point exact
    if (minDiffAfter === 0 || minDiffBefore === 0) {
      const exact = bestAfter || bestBefore;
      return { lat: exact.lat, lon: exact.lon };
    }

    // V√©rifier si on est dans une zone de discontinuit√© - pas d'interpolation dans (10800, 11300)
    const disc = findDiscontinuityForMetricPk(metricPk, currentBranch);
    if (disc && metricPk > disc.pk_before && metricPk < disc.pk_after) {
      // Dans la zone de saut : arrondir au plus proche (10800 ou 11300)
      const distToBefore = metricPk - disc.pk_before;
      const distToAfter = disc.pk_after - metricPk;
      const roundedPk = distToBefore < distToAfter ? disc.pk_before : disc.pk_after;
      
      // Chercher le point correspondant au PK arrondi
      for (let i = 0; i < linePoints.length; i++) {
        const pt = linePoints[i];
        if (pt.pk != null && pt.lat != null && pt.lon != null && pt.pk === roundedPk) {
          return { lat: pt.lat, lon: pt.lon };
        }
      }
      // Si pas de point exact, utiliser l'interpolation vers le point le plus proche
      if (roundedPk === disc.pk_before && bestBefore) {
        return { lat: bestBefore.lat, lon: bestBefore.lon };
      }
      if (roundedPk === disc.pk_after && bestAfter) {
        return { lat: bestAfter.lat, lon: bestAfter.lon };
      }
    }

    // Interpolation entre les deux points les plus proches (hors zone de saut)
    if (bestBefore && bestAfter) {
      // V√©rifier qu'on n'interpole pas dans une zone de discontinuit√©
      const discCheck = findDiscontinuityForMetricPk(metricPk, currentBranch);
      if (discCheck && metricPk > discCheck.pk_before && metricPk < discCheck.pk_after) {
        // Ne pas interpoler dans la zone de saut
        const distToBefore = metricPk - discCheck.pk_before;
        const distToAfter = discCheck.pk_after - metricPk;
        if (distToBefore < distToAfter && bestBefore) {
          return { lat: bestBefore.lat, lon: bestBefore.lon };
        }
        if (bestAfter) {
          return { lat: bestAfter.lat, lon: bestAfter.lon };
        }
      }
      
      const totalDiff = bestAfter.pk - bestBefore.pk;
      const targetDiff = metricPk - bestBefore.pk;
      const ratio = totalDiff > 0 ? targetDiff / totalDiff : 0;

      const lat = bestBefore.lat + (bestAfter.lat - bestBefore.lat) * ratio;
      const lon = bestBefore.lon + (bestAfter.lon - bestBefore.lon) * ratio;

      return { lat: lat, lon: lon };
    }

    // Si on n'a qu'un seul point proche, on l'utilise
    if (bestBefore) {
      return { lat: bestBefore.lat, lon: bestBefore.lon };
    }
    if (bestAfter) {
      return { lat: bestAfter.lat, lon: bestAfter.lon };
    }

    return null;
  }

  // Nearest access uniquement par PK (utilis√© pour la recherche manuelle)
  // branchHint : branche choisie par l'utilisateur (boissy, central, chessy, ou null pour auto)
  function findNearestAccess(pk, branchHint = null) {
    if (pk == null) return null;
    let best = null;
    let bestDiff = Infinity;
    
    for (const acc of accessPoints) {
      if (acc.pk == null) continue;
      
      // Si une branche est sp√©cifi√©e, filtrer les acc√®s selon leur branche
      if (branchHint && branchHint !== "auto") {
        // D√©terminer la branche de l'acc√®s selon son PK
        let accBranch = null;
        if (acc.pk <= BRANCH_COMMON_MAX) {
          accBranch = "central";
        } else if (acc.pk >= BRANCH_CHESSY_MIN && acc.pk <= BRANCH_CHESSY_MAX) {
          // PK entre 34000 et 59700 = Chessy
          accBranch = "chessy";
        } else if (acc.pk >= BRANCH_BOISSY_MIN && acc.pk <= BRANCH_BOISSY_MAX) {
          // PK entre 32750 et 47200 = Boissy
          accBranch = "boissy";
        } else {
          // PK entre 30000 et 34000 (zone de transition apr√®s Vincennes)
          accBranch = null; // √Ä d√©terminer selon le contexte
        }
        
        // Si la branche de l'acc√®s ne correspond pas √† celle demand√©e, l'ignorer
        if (branchHint === "central" && accBranch !== "central") continue;
        if (branchHint === "boissy" && accBranch !== "boissy") continue;
        if (branchHint === "chessy" && accBranch !== "chessy") continue;
        
        console.log("  Acc√®s", acc.name, "PK", acc.pk, "branche", accBranch, "‚Üí accept√©");
      }
      
      const d = Math.abs(acc.pk - pk);
      if (d < bestDiff) {
        bestDiff = d;
        best = acc;
      }
    }
    
    // Si aucun acc√®s trouv√© avec le filtre de branche, chercher sans filtre
    if (!best && branchHint && branchHint !== "auto") {
      console.log("Aucun acc√®s trouv√© sur la branche", branchHint, ", recherche sans filtre");
      for (const acc of accessPoints) {
        if (acc.pk == null) continue;
        const d = Math.abs(acc.pk - pk);
        if (d < bestDiff) {
          bestDiff = d;
          best = acc;
        }
      }
    }
    
    return best;
  }

  // Trouve les acc√®s d'une gare donn√©e
  function findAccessesForStation(stationName) {
    if (!stationName) return [];
    const stationNameLower = stationName.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    const results = [];
    
    // Extraire les mots significatifs du nom de la gare (exclure "de", "le", "la", etc.)
    const stopWords = new Set(["de", "le", "la", "les", "du", "des", "et", "en", "sur", "sous", "d"]);
    const stationWords = stationNameLower
      .split(/[\s-‚Äì‚Äî]+/)
      .filter(w => w.length > 2 && !stopWords.has(w));
    
    // Mots-cl√©s distinctifs (ex: "champs" pour Noisy-Champs, "mont" et "est" pour Mont d'Est)
    const distinctiveWords = stationWords.filter(w => 
      !["noisy", "grand", "saint", "paris", "l", "gare"].includes(w)
    );
    
    // Mots distinctifs d'autres gares √† exclure (pour √©viter les faux positifs)
    const conflictingWords = {
      "champs": ["mont", "est", "grand"], // Si on cherche "champs", exclure "mont", "est", "grand"
      "mont": ["champs"], // Si on cherche "mont", exclure "champs"
      "est": ["champs"] // Si on cherche "est", exclure "champs"
    };
    
    for (const acc of accessPoints) {
      if (!acc.name) continue;
      const accNameLower = acc.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      
      // V√©rifier si l'acc√®s contient "gare" et correspond √† la gare
      if (!accNameLower.includes("gare")) continue;
      
      // Extraire les mots significatifs de l'acc√®s
      const accWords = accNameLower
        .split(/[\s-‚Äì‚Äî]+/)
        .filter(w => w.length > 1 && !stopWords.has(w));
      
      // EXCLUSION : Si on a des mots distinctifs, exclure les acc√®s qui contiennent des mots conflictuels
      if (distinctiveWords.length > 0) {
        let hasConflict = false;
        for (const distWord of distinctiveWords) {
          const conflicts = conflictingWords[distWord];
          if (conflicts) {
            for (const conflictWord of conflicts) {
              if (accWords.some(accWord => {
                // V√©rifier si l'acc√®s contient un mot conflictuel
                const abbrevMap = {
                  "gd": "grand", "grand": "gd",
                  "mt": "mont", "mont": "mt",
                  "ch": "champs", "champs": "ch"
                };
                return accWord === conflictWord || 
                       (conflictWord.length >= 3 && accWord.length >= 3 && 
                        (accWord.includes(conflictWord) || conflictWord.includes(accWord))) ||
                       abbrevMap[accWord] === conflictWord || abbrevMap[conflictWord] === accWord;
              })) {
                hasConflict = true;
                break;
              }
            }
            if (hasConflict) break;
          }
        }
        if (hasConflict) {
          continue; // Exclure cet acc√®s car il contient des mots conflictuels
        }
      }
      
      // V√©rifier que TOUS les mots distinctifs matchent
      if (distinctiveWords.length > 0) {
        let allDistinctiveMatch = true;
        for (const distWord of distinctiveWords) {
          const found = accWords.some(accWord => {
            // Correspondance exacte
            if (accWord === distWord) return true;
            // Correspondance partielle (au moins 3 caract√®res)
            if (distWord.length >= 3 && accWord.length >= 3) {
              return accWord.includes(distWord) || distWord.includes(accWord);
            }
            // G√©rer les abr√©viations
            const abbrevMap = {
              "gd": "grand", "grand": "gd",
              "mt": "mont", "mont": "mt",
              "ch": "champs", "champs": "ch"
            };
            return abbrevMap[accWord] === distWord || abbrevMap[distWord] === accWord;
          });
          if (!found) {
            allDistinctiveMatch = false;
            break;
          }
        }
        if (!allDistinctiveMatch) {
          continue; // Pas tous les mots distinctifs pr√©sents
        }
      }
      
      // Compter les correspondances pour les autres mots (au moins "noisy" doit matcher)
      let matchCount = 0;
      for (const stationWord of stationWords) {
        const found = accWords.some(accWord => {
          // Correspondance exacte
          if (accWord === stationWord) return true;
          // Correspondance partielle (au moins 4 caract√®res)
          if (stationWord.length >= 4 && accWord.length >= 4) {
            return accWord.includes(stationWord) || stationWord.includes(accWord);
          }
          // G√©rer les abr√©viations
          const abbrevMap = {
            "gd": "grand", "grand": "gd",
            "mt": "mont", "mont": "mt",
            "ch": "champs", "champs": "ch"
          };
          return abbrevMap[accWord] === stationWord || abbrevMap[stationWord] === accWord;
        });
        if (found) matchCount++;
      }
      
      // Si on a des mots distinctifs qui matchent tous, accepter
      // Sinon, au moins la moiti√© des mots doivent correspondre
      const minMatches = distinctiveWords.length > 0 
        ? Math.max(1, stationWords.length - distinctiveWords.length) // Au moins les mots non-distinctifs
        : Math.max(1, Math.ceil(stationWords.length / 2));
      
      if (matchCount >= minMatches) {
        results.push(acc);
      }
    }
    
    return results;
  }

  // Nearest access par distance GPS (pour "autour de moi")
  function findNearestAccessGeo(lat, lon) {
    if (lat == null || lon == null) return null;
    let best = null;
    let bestDist = Infinity;
    for (const acc of accessPoints) {
      if (acc.lat == null || acc.lon == null) continue;
      const d = distanceMeters(lat, lon, acc.lat, acc.lon);
      if (d < bestDist) {
        bestDist = d;
        best = acc;
      }
    }
    return best;
  }
  // Top N acc√®s par distance GPS (utilis√© pour "Top 2 en PK")
  function getNearestAccessesGeo(lat, lon, pk, maxCount = 2) {
    if (lat == null || lon == null) return [];

    const list = [];

    for (const acc of accessPoints) {
     
      if (acc.lat == null || acc.lon == null) continue;

      const dGeo = distanceMeters(lat, lon, acc.lat, acc.lon);
      const dPk  = (pk != null && acc.pk != null) ? Math.abs(acc.pk - pk) : null;

      list.push({ acc, dGeo, dPk });
    }

    // Classement par distance GPS r√©elle
    list.sort((a, b) => a.dGeo - b.dGeo);

    // On ne garde que les N premiers (par d√©faut 2)
    return list.slice(0, maxCount);
  }

  function findNextStation(pk, direction, branch) {
    if (pk == null) return null;
    let arr;
    const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
    const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
    const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];
    
    if (branch === "boissy") {
      arr = safeTroncCommun.concat(safeBrancheBoissy);
    } else if (branch === "chessy") {
      arr = safeTroncCommun.concat(safeBrancheChessy);
    } else {
      // Pour "both" ou "central", utiliser toutes les stations mais filtrer intelligemment
      // Si PK > 30000, on est probablement sur une branche, donc filtrer selon le PK
      if (pk > BRANCH_COMMON_MAX) {
        // D√©terminer la branche selon le PK
        if (pk >= BRANCH_CHESSY_MIN) {
          arr = safeTroncCommun.concat(safeBrancheChessy);
        } else if (pk >= BRANCH_BOISSY_MIN) {
          arr = safeTroncCommun.concat(safeBrancheBoissy);
        } else {
          arr = stations;
        }
      } else {
        arr = stations;
      }
    }

    let candidates;
    if (direction === "est") {
      candidates = arr.filter(s => s.pk > pk).sort((a,b) => a.pk - b.pk);
    } else if (direction === "ouest") {
      candidates = arr.filter(s => s.pk < pk).sort((a,b) => b.pk - a.pk);
    } else {
      return findNearestStation(pk, branch);
    }
    return candidates[0] || findNearestStation(pk, branch);
  }
function detectBranch(lat, lon) {
  // Si on n'a pas de GPS (cas de certains acc√®s sans coordonn√©es),
  // on reste en "both" = tronc commun / branche inconnue
  if (lat == null || lon == null) {
    return "both";
  }

  // S'assure que les polylignes calibr√©es sont pr√™tes
  buildCalibrationPolylines();

  // V√©rification de s√©curit√© : si les polylignes ne sont pas initialis√©es ou ont moins de 2 √©l√©ments, on utilise les valeurs par d√©faut
  if (!linePointsBoissy || !linePointsChessy || !troncCommun || 
      troncCommun.length < 2 || 
      linePointsBoissy.length < 2 || 
      linePointsChessy.length < 2) {
    return "both";
  }

  // √âTAPE 1 : V√©rifier d'abord si on est sur le TRONC COMMUN (PK 0-30000, jusqu'√† Vincennes)
  // On projette sur le tronc commun pour obtenir la distance et le PK estim√©
  let minTronc = Infinity;
  let pkTronc = null;
  
  for (let i = 0; i < troncCommun.length - 1; i++) {
    const a = troncCommun[i];
    const b = troncCommun[i + 1];
    if (a.lat == null || a.lon == null || b.lat == null || b.lon == null) continue;
    
    const proj = projectToSegment(lat, lon, a, b);
    if (proj.dist < minTronc) {
      minTronc = proj.dist;
      pkTronc = proj.pkProj;
    }
  }

  // Si on est tr√®s proche du tronc commun (moins de 200m) ET que le PK est <= 30000, on est sur le tronc commun
  if (minTronc < 200 && pkTronc != null && pkTronc <= BRANCH_COMMON_MAX) {
    return "both"; // Tronc commun
  }

  // √âTAPE 2 : Si on n'est pas clairement sur le tronc commun, comparer Boissy vs Chessy
  // On utilise la projection sur les segments (plus pr√©cis que la distance aux points)
  let minBoissy = Infinity;
  let pkBoissy = null;
  
  for (let i = 0; i < linePointsBoissy.length - 1; i++) {
    const a = linePointsBoissy[i];
    const b = linePointsBoissy[i + 1];
    if (a.lat == null || a.lon == null || b.lat == null || b.lon == null) continue;
    
    const proj = projectToSegment(lat, lon, a, b);
    if (proj.dist < minBoissy) {
      minBoissy = proj.dist;
      pkBoissy = proj.pkProj;
    }
  }
  let minChessy = Infinity;
  let pkChessy = null;
  
  for (let i = 0; i < linePointsChessy.length - 1; i++) {
    const a = linePointsChessy[i];
    const b = linePointsChessy[i + 1];
    if (a.lat == null || a.lon == null || b.lat == null || b.lon == null) continue;
    
    const proj = projectToSegment(lat, lon, a, b);
    if (proj.dist < minChessy) {
      minChessy = proj.dist;
      pkChessy = proj.pkProj;
    }
  }

  // Si pour une raison quelconque on n'a rien trouv√©, on reste neutre
  if (!isFinite(minBoissy) && !isFinite(minChessy)) {
    return "both";
  }

  // √âTAPE 3 : Comparer les distances avec un seuil de tol√©rance
  // Si les deux distances sont tr√®s proches (< 50m de diff√©rence), on utilise le PK pour trancher
  const diff = Math.abs(minBoissy - minChessy);
  
  if (diff < 50 && pkBoissy != null && pkChessy != null) {
    // Si les distances sont tr√®s proches, on utilise le PK pour d√©terminer la branche
    // Si on est proche de la bifurcation (PK ~30000, apr√®s Vincennes), on privil√©gie la distance
    if (pkBoissy > BRANCH_COMMON_MAX && pkChessy > BRANCH_COMMON_MAX) {
      // On est clairement sur une branche, on utilise la distance la plus proche
      // Mais si le PK est >= 34000, on est sur Chessy (Val de Fontenay)
      if (pkChessy >= BRANCH_CHESSY_MIN) return "chessy";
      // Si le PK est >= 32750, on est sur Boissy (Fontenay-sous-Bois)
      if (pkBoissy >= BRANCH_BOISSY_MIN) return "boissy";
      return minBoissy < minChessy ? "boissy" : "chessy";
    } else if (pkBoissy <= BRANCH_COMMON_MAX && pkChessy <= BRANCH_COMMON_MAX) {
      // On est sur le tronc commun
      return "both";
    } else {
      // Une branche a un PK > 30000, l'autre non : on choisit celle avec PK > 30000
      return pkBoissy > BRANCH_COMMON_MAX ? "boissy" : "chessy";
    }
  }

  // √âTAPE 4 : Branche = celle dont la poly-ligne calibr√©e est la plus proche
  // Avec un seuil : si la diff√©rence est trop faible, on reste sur "both" pour √©viter les erreurs
  if (diff < 30) {
    // Si la diff√©rence est tr√®s faible, on v√©rifie le PK pour trancher
    if (pkBoissy != null && pkChessy != null) {
      // Si le PK est >= 34000, on est sur Chessy (Val de Fontenay)
      if (pkChessy >= BRANCH_CHESSY_MIN) return "chessy";
      // Si le PK est >= 32750, on est sur Boissy (Fontenay-sous-Bois)
      if (pkBoissy >= BRANCH_BOISSY_MIN) return "boissy";
      if (pkBoissy > BRANCH_COMMON_MAX && pkChessy <= BRANCH_COMMON_MAX) return "boissy";
      if (pkChessy > BRANCH_COMMON_MAX && pkBoissy <= BRANCH_COMMON_MAX) return "chessy";
    }
    // Sinon, on reste neutre si vraiment ind√©termin√©
    return "both";
  }

  return minBoissy < minChessy ? "boissy" : "chessy";
}
  function safeGetItem(key) {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      console.warn("localStorage getItem bloqu√© pour", key, e);
      return null;
    }
  }

  function safeSetItem(key, value) {
    try {
      localStorage.setItem(key, value);
    } catch (e) {
      console.warn("localStorage setItem bloqu√© pour", key, e);
    }
  }

  function loadSettings() {
    let storedOffset = parseFloat(safeGetItem("pkOffset"));
    pkOffset = isNaN(storedOffset) ? 0 : storedOffset;

    const sos = safeGetItem("sosPhone");
    const ms  = safeGetItem("motionSensitivity");

    sosPhone = sos || "";
    motionSensitivity = ms || "normal";

    inputSosPhone.value = sosPhone;
    selectSensitivity.value = motionSensitivity;
    updateOffsetInfo();
    const storedTab = safeGetItem(ACTIVE_TAB_KEY);
    const fallbackTab = "status";
    const initialTab = storedTab && tabPanels.some(panel => panel.dataset.tab === storedTab)
      ? storedTab
      : fallbackTab;
    activateTab(initialTab, { skipStore: true });

    const storedPkLookup = safeGetItem("pkLookupQuery");
    if (storedPkLookup && inputPkLookup) {
      inputPkLookup.value = storedPkLookup;
      updatePkLookupSuggestionsList(storedPkLookup);
    }

    const storedLastAccess = safeGetItem("pkLookupLastAccess");
    const storedLastTarget = safeGetItem("pkLookupLastTargetPk");
    if (storedLastAccess) {
      try {
        const parsed = JSON.parse(storedLastAccess);
        if (parsed && parsed.name) {
          const match = accessPoints.find(acc => acc.name === parsed.name && (parsed.pk == null || acc.pk === parsed.pk));
          if (match) {
            const targetPk = storedLastTarget ? parseFloat(storedLastTarget) : null;
            if (Number.isFinite(targetPk)) {
              ensureBranchForPk(targetPk, BRANCH_SELECTION_CONTEXTS.search);
            }
            renderPkLookupSummary({
              access: match,
              targetPk: Number.isFinite(targetPk) ? targetPk : null,
              branchChoice: (() => {
                const contextBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.search);
                return contextBranch !== "auto" ? contextBranch : null;
              })()
            });
          }
        }
      } catch (error) {
        console.warn("Impossible de restaurer le dernier acc√®s s√©lectionn√©", error);
      }
    }

    loadRecalHistory();
    loadCoverageLegendState();
    if (manualBranchOverride) {
      setManualBranchOverride(manualBranchOverride);
    } else {
      updateLegendBranchUI();
    }
    setCoverageLegendCollapsed(coverageLegendCollapsed, { skipSave: true });
    applyCoverageLegendFilters();
    setRecalMessage("");

    generateFermeturesNocturnesContent();
  }

  function activateTab(tabId, options = {}) {
    if (!tabPanels.length) return;
    const { skipStore = false } = options;
    tabButtons.forEach(button => {
      const target = button.getAttribute("data-tab-target");
      const isActive = target === tabId;
      button.classList.toggle("is-active", isActive);
      button.setAttribute("aria-pressed", isActive ? "true" : "false");
    });
    tabPanels.forEach(panel => {
      panel.classList.toggle("is-active", panel.dataset.tab === tabId);
    });
    if (!skipStore) {
      safeSetItem(ACTIVE_TAB_KEY, tabId);
    }
    window.scrollTo({ top: 0, behavior: "smooth" });
    if (tabId === "plan") {
      ensureOrientationMapReady();
      updateOrientationPanel();
    } else if (tabId === "fermetures") {
      generateFermeturesNocturnesContent();
    }
  }

  function setRecalMessage(message, tone = "info") {
    if (!recalMessages) return;
    if (!message) {
      recalMessages.textContent = "";
      recalMessages.classList.remove("is-error", "is-success");
      return;
    }
    recalMessages.textContent = message;
    recalMessages.classList.remove("is-error", "is-success");
    if (tone === "error") {
      recalMessages.classList.add("is-error");
    } else if (tone === "success") {
      recalMessages.classList.add("is-success");
    }
  }

  function saveRecalHistory() {
    try {
      const subset = recalHistory.slice(0, 10);
      safeSetItem("pkRecalHistory", JSON.stringify(subset));
    } catch (error) {
      console.warn("Impossible de sauvegarder l'historique de recalage", error);
    }
  }

  function renderRecalHistoryList() {
    if (!recalHistoryList) return;
    if (!recalHistory.length) {
      recalHistoryList.innerHTML = "Aucun recalage r√©cent.";
      if (btnUndoRecal) btnUndoRecal.style.display = "none";
      return;
    }
    const items = recalHistory.slice(0, 5).map(entry => {
      const date = new Date(entry.timestamp).toLocaleString("fr-FR", {
        day: "2-digit", month: "2-digit", hour: "2-digit", minute: "2-digit"
      });
      const branch = entry.branch ? getBranchLabel(entry.branch) : "branche inconnue";
      const branchKey = entry.branch || currentBranch || "central";
      const delta = Math.round(entry.offset);
      // entry.pkExact est un PK m√©trique, on passe la branche pour l'affichage en PK relatif Boissy
      return `<div class="recal-history-item"><strong>${date}</strong> ¬∑ ${entry.pkExact != null ? "PK " + formatPk(entry.pkExact, branchKey) : "PK ?"} ¬∑ Offset ${delta > 0 ? '+' + delta : delta} m ¬∑ ${branch}</div>`;
    }).join("");
    recalHistoryList.innerHTML = items;
    if (btnUndoRecal) btnUndoRecal.style.display = "inline-flex";
  }

  function loadRecalHistory() {
    const stored = safeGetItem("pkRecalHistory");
    if (!stored) {
      recalHistory = [];
      renderRecalHistoryList();
      return;
    }
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        recalHistory = parsed.filter(item => item && typeof item === "object");
      } else {
        recalHistory = [];
      }
    } catch (error) {
      console.warn("Impossible de lire l'historique de recalage", error);
      recalHistory = [];
    }
    if (recalHistory.length > 10) {
      recalHistory = recalHistory.slice(0, 10);
    }
    renderRecalHistoryList();
  }

  function loadCoverageLegendState() {
    try {
      const raw = safeGetItem(COVERAGE_LEGEND_STATE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object") {
          coverageLegendVisibility.sam = parsed.sam !== false;
          coverageLegendVisibility.petard = parsed.petard !== false;
        }
      }
    } catch (error) {
      console.warn("Impossible de lire l'√©tat de la l√©gende", error);
      coverageLegendVisibility = { sam: true, petard: true };
    }

    const collapseStored = safeGetItem(COVERAGE_LEGEND_COLLAPSE_KEY);
    if (collapseStored === null || collapseStored === undefined || collapseStored === "") {
      coverageLegendCollapsed = window.innerWidth <= 640;
    } else {
      coverageLegendCollapsed = collapseStored === "true";
    }

    const manualBranchStored = safeGetItem(MANUAL_BRANCH_OVERRIDE_KEY);
    if (manualBranchStored) {
      manualBranchOverride = manualBranchStored === "auto" ? null : manualBranchStored;
    } else {
      manualBranchOverride = null;
    }
  }

  function saveCoverageLegendState() {
    try {
      safeSetItem(COVERAGE_LEGEND_STATE_KEY, JSON.stringify({
        sam: coverageLegendVisibility.sam !== false,
        petard: coverageLegendVisibility.petard !== false
      }));
    } catch (error) {
      console.warn("Impossible de sauvegarder l'√©tat de la l√©gende", error);
    }
  }

  function isLegendKindVisible(kind) {
    if (kind === "petard") {
      return coverageLegendVisibility.petard !== false;
    }
    return coverageLegendVisibility.sam !== false;
  }

  function applyCoverageLegendFilters() {
    const showSam = coverageLegendVisibility.sam !== false;
    const showPetard = coverageLegendVisibility.petard !== false;

    if (legendToggleSam) {
      legendToggleSam.checked = showSam;
    }
    if (legendTogglePetard) {
      legendTogglePetard.checked = showPetard;
    }

    if (orientationMap) {
      coverageSamMarkers.forEach(marker => {
        if (!marker) return;
        const hasLayer = orientationMap.hasLayer(marker);
        if (showSam && !hasLayer) {
          marker.addTo(orientationMap);
        } else if (!showSam && hasLayer) {
          orientationMap.removeLayer(marker);
        }
      });
      coveragePetardMarkers.forEach(marker => {
        if (!marker) return;
        const hasLayer = orientationMap.hasLayer(marker);
        if (showPetard && !hasLayer) {
          marker.addTo(orientationMap);
        } else if (!showPetard && hasLayer) {
          orientationMap.removeLayer(marker);
        }
      });
    }

    if (!coverageLegendItems) {
      return;
    }
    const items = coverageLegendItems.querySelectorAll('.coverage-legend-item');
    items.forEach(item => {
      const kind = item.getAttribute('data-legend-kind') || 'sam';
      const visible = isLegendKindVisible(kind);
      item.classList.toggle('is-disabled', !visible);
      item.setAttribute('aria-disabled', visible ? 'false' : 'true');
    });
  }


  function setLegendToggleState(kind, value) {
    if (kind !== 'sam' && kind !== 'petard') return;
    coverageLegendVisibility[kind] = !!value;
    saveCoverageLegendState();
    applyCoverageLegendFilters();
  }

  function setCoverageLegendCollapsed(collapsed, options = {}) {
    if (!coverageLegend) {
      coverageLegendCollapsed = !!collapsed;
      return;
    }
     coverageLegendCollapsed = !!collapsed;
     if (coverageLegend) {
       coverageLegend.setAttribute('data-collapsed', coverageLegendCollapsed ? 'true' : 'false');
     }
     if (btnLegendCollapse) {
       btnLegendCollapse.setAttribute('aria-expanded', coverageLegendCollapsed ? 'false' : 'true');
       btnLegendCollapse.textContent = coverageLegendCollapsed ? '‚§¥' : '‚§µ';
     }
     if (coverageLegendCollapsed) {
       closeLegendBranchMenu();
     }
     if (!options.skipSave) {
       safeSetItem(COVERAGE_LEGEND_COLLAPSE_KEY, coverageLegendCollapsed ? 'true' : 'false');
     }
  }

  function closeLegendBranchMenu() {
    if (!legendBranchMenu) return;
    legendBranchMenu.hidden = true;
    if (btnLegendBranch) {
      btnLegendBranch.setAttribute('aria-expanded', 'false');
    }
  }

  function toggleLegendBranchMenu(forceOpen) {
    if (!legendBranchMenu || !btnLegendBranch) return;
    const shouldOpen = typeof forceOpen === 'boolean' ? forceOpen : legendBranchMenu.hidden;
    legendBranchMenu.hidden = !shouldOpen;
    btnLegendBranch.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
  }

  function updateLegendBranchUI() {
    if (legendBranchLabel) {
      const branchKeyRaw = manualBranchOverride || currentBranch || 'central';
      const branchKey = branchKeyRaw === 'both' ? 'central' : branchKeyRaw;
      legendBranchLabel.textContent = getBranchLabel(branchKey);
    }
    if (legendBranchControls) {
      legendBranchControls.classList.toggle('is-manual', !!manualBranchOverride);
    }
  }

  function recomputeAfterBranchChange() {
    if (state.lastRawPk != null) {
      const correctedPk = computePkWithCalibrations(state.lastRawPk, currentBranch);
      state.lastPk = correctedPk;
      state.nearestStation = findNearestStation(correctedPk, currentBranch);
      state.nearestAccess = (state.lastLat != null && state.lastLon != null)
        ? findNearestAccessGeo(state.lastLat, state.lastLon)
        : findNearestAccess(correctedPk, currentBranch);
      updateNearestStation(correctedPk, state.nearestStation);
      updateNextStation(correctedPk);
      updateNearestAccess(correctedPk);
      updateOrientationPanel();
      updateSmsPreview();
      updatePkEstimateInSettings();
    } else {
      updateOrientationPanel();
    }
  }

  function setManualBranchOverride(branchKey) {
    debugLog("setManualBranchOverride appel√© avec:", branchKey);
    
    // S'assurer que les polylignes sont construites
    if (!linePointsBoissy || !linePointsChessy) {
      buildCalibrationPolylines();
    }
    
    if (!branchKey || branchKey === 'auto') {
      manualBranchOverride = null;
      safeSetItem(MANUAL_BRANCH_OVERRIDE_KEY, '');
      debugLog("Override supprim√©, retour √† la d√©tection automatique");
    } else if (branchKey === 'boissy' || branchKey === 'central' || branchKey === 'chessy') {
      manualBranchOverride = branchKey;
      safeSetItem(MANUAL_BRANCH_OVERRIDE_KEY, branchKey);
      currentBranch = branchKey;
      debugLog("‚úÖ Override manuel d√©fini:", branchKey, "currentBranch:", currentBranch);
      
      // Mettre √† jour linePoints imm√©diatement
      const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
      const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
      const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];
      if (branchKey === 'boissy') {
        linePoints = linePointsBoissy || safeTroncCommun.concat(safeBrancheBoissy);
      } else if (branchKey === 'chessy') {
        linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      } else if (branchKey === 'central') {
        linePoints = safeTroncCommun.slice();
      }
      debugLog("linePoints mis √† jour pour", branchKey, ", longueur:", linePoints ? linePoints.length : 0);
      
      // Si la g√©olocalisation est active, forcer une nouvelle projection avec la nouvelle branche
      if (geolocActive && state.lastLat != null && state.lastLon != null) {
        debugLog("üîÑ Recalcul du PK avec la nouvelle branche:", branchKey);
        // Mettre √† jour linePoints AVANT de projeter
        if (branchKey === 'boissy') {
          linePoints = linePointsBoissy || troncCommun.concat(brancheBoissy);
        } else if (branchKey === 'chessy') {
          linePoints = linePointsChessy || troncCommun.concat(brancheChessy);
        } else if (branchKey === 'central') {
          linePoints = troncCommun.slice();
        }
        
        const proj = projectToLine(state.lastLat, state.lastLon);
        if (proj.pkProj != null) {
          const correctedPk = computePkWithCalibrations(proj.pkProj, currentBranch);
          state.lastRawPk = proj.pkProj;
          state.lastPk = correctedPk;
          state.lastDist = proj.dist;
          debugLog("‚úÖ Nouveau PK calcul√©:", correctedPk, "pour la branche", currentBranch, "PK brut:", proj.pkProj);
          
          // Mettre √† jour la gare la plus proche avec la nouvelle branche
          const nearest = findNearestStation(correctedPk, currentBranch);
          state.nearestStation = nearest;
          updateNearestStation(correctedPk, nearest);
          updateNextStation(correctedPk);
          updateNearestAccess(correctedPk);
          
          // Mettre √† jour l'interface imm√©diatement
          if (pkCurrentValue) {
            const pkText = "PK " + formatPk(correctedPk);
            pkCurrentValue.textContent = pkText;
            debugLog("‚úÖ PK actuel mis √† jour:", pkText);
          }
          if (pkCurrentDetails) {
            let distText = proj.dist != null ? "¬±" + Math.round(proj.dist) + " m de la voie" : "";
            // V√©rifier si on est dans une zone de saut PK et ajouter un message UX/log
            const disc = findDiscontinuityForMetricPk(proj.pkProj, currentBranch);
            if (disc && proj.pkProj >= disc.pk_before - disc.window_m && proj.pkProj < disc.pk_after) {
              const roundedPk = roundPkToDiscontinuityBounds(proj.pkProj, currentBranch);
              if (distText) distText += " ¬∑ ";
              distText += `Zone de saut PK (${disc.pk_before}‚Üî${disc.pk_after}) ‚Äî position arrondie √† ${roundedPk}`;
            }
            pkCurrentDetails.textContent = distText;
          }
          
          // Mettre √† jour toutes les autres vues
          updatePkTargetView();
          updateSmsPreview();
          updatePkEstimateInSettings();
          updateOrientationPanel();
          
          debugLog("‚úÖ Toutes les vues mises √† jour avec la branche", currentBranch);
        } else {
          console.error("‚ùå Impossible de projeter avec la nouvelle branche");
        }
      } else {
        debugLog("‚ÑπÔ∏è G√©olocalisation non active, override sauvegard√© pour la prochaine utilisation");
      }
    } else {
      console.warn("Branche invalide:", branchKey);
      return;
    }
    updateLegendBranchUI();
    recomputeAfterBranchChange();
  }
  function handleLegendBranchChoice(branchKey) {
    setManualBranchOverride(branchKey);
    closeLegendBranchMenu();
  }

  function showRecalPreview(entry) {
    if (!recalPreview) return;
    const branchKey = entry.branch || currentBranch || "central";
    if (recalPreviewCurrent) {
      if (entry.pkRaw != null) {
        const currentEstimate = computePkWithCalibrations(entry.pkRaw, branchKey);
        recalPreviewCurrent.textContent = Number.isFinite(currentEstimate) ? formatPk(currentEstimate, branchKey) : "‚Äî";
      } else {
        recalPreviewCurrent.textContent = "‚Äî";
      }
    }
    if (recalPreviewNew) {
      // entry.pkExact est d√©j√† un PK m√©trique (retourn√© par parsePkInput)
      // On doit passer la branche pour que formatPk convertisse correctement en PK relatif pour Boissy
      recalPreviewNew.textContent = entry.pkExact != null ? formatPk(entry.pkExact, branchKey) : "‚Äî";
    }
    if (recalPreviewBranch) {
      recalPreviewBranch.textContent = getBranchLabel(branchKey);
    }
    
    // V√©rifier si on est dans une zone de discontinuit√© et afficher un avertissement
    const disc = findDiscontinuityForDisplayPk(entry.pkExact, branchKey);
    if (disc && recalPreviewNew) {
      const jumpInfo = document.createElement("div");
      jumpInfo.style.cssText = "margin-top: 8px; padding: 6px; background: rgba(255, 193, 7, 0.15); border-left: 2px solid #ffc107; border-radius: 4px; font-size: 0.85rem; color: #ffc107;";
      jumpInfo.textContent = `‚ö†Ô∏è Zone de saut PK : +${disc.jump} m appliqu√©`;
      // Supprimer l'ancien avertissement s'il existe
      const oldWarning = recalPreviewNew.parentElement.querySelector(".discontinuity-warning");
      if (oldWarning) oldWarning.remove();
      jumpInfo.className = "discontinuity-warning";
      recalPreviewNew.parentElement.appendChild(jumpInfo);
    } else {
      // Supprimer l'avertissement s'il n'y a plus de discontinuit√©
      const oldWarning = recalPreviewNew?.parentElement?.querySelector(".discontinuity-warning");
      if (oldWarning) oldWarning.remove();
    }
    
    recalPreview.style.display = "block";
  }

  function hideRecalPreview() {
    if (!recalPreview) return;
    recalPreview.style.display = "none";
    pendingRecal = null;
  }

  function applyPendingRecal(entry) {
    if (!entry) {
      setRecalMessage("Aucun recalage en attente.", "error");
      return;
    }
    const timestamp = entry.timestamp || new Date().toISOString();
    entry.timestamp = timestamp;

    const appliedOffset = entry.offset;
    // D√©terminer la branche de mani√®re stricte en utilisant le PK et les coordonn√©es GPS
    const branchForCal = determineCalibrationBranch(
      entry.pkExactMetric != null ? entry.pkExactMetric : entry.pkExact,
      entry.branch || currentBranch,
      entry.lat,
      entry.lon
    );

    const recalLat = entry.lat;
    const recalLon = entry.lon;
    const recalAccuracy = entry.accuracy;

    let calibrationTimestamp = null;
    if (recalLat != null && recalLon != null) {
      // Utiliser le PK m√©trique pour le stockage interne (sans saut d'affichage)
      const pkExactForStorage = entry.pkExactMetric != null ? entry.pkExactMetric : entry.pkExact;
      const calib = {
        pkExact: pkExactForStorage, // Stocker le PK m√©trique (sans saut)
        pkRaw: entry.pkRaw,
        pkOffset: appliedOffset,
        lat: recalLat,
        lon: recalLon,
        accuracy: recalAccuracy,
        branch: branchForCal,
        timestamp
      };
      localCalibrations.push(calib);
      saveLocalCalibrations();
      calibrationTimestamp = timestamp;
    }

    lastCalibrationBuildTime = 0;
    buildCalibrationPolylines();

    safeSetItem("pkOffset", pkOffset);
    updateOffsetInfo();

    recomputeAfterBranchChange();
    updatePkTargetView();

    const historyEntry = {
      pkExact: entry.pkExact,
      pkRaw: entry.pkRaw,
      offset: appliedOffset,
      previousOffset: entry.previousOffset,
      branch: branchForCal,
      lat: recalLat,
      lon: recalLon,
      accuracy: recalAccuracy,
      timestamp,
      calibrationTimestamp
    };
    recalHistory.unshift(historyEntry);
    if (recalHistory.length > 10) {
      recalHistory.length = 10;
    }
    saveRecalHistory();
    renderRecalHistoryList();

    hideRecalPreview();
    if (inputPkRecal) {
      inputPkRecal.value = "";
    }
    const offsetRounded = Math.round(appliedOffset);
    const offsetLabel = offsetRounded > 0 ? "+" + offsetRounded : String(offsetRounded);
    // entry.pkExact est un PK m√©trique, on passe la branche pour l'affichage en PK relatif Boissy
    const pkLabel = entry.pkExact != null ? formatPk(entry.pkExact, branchForCal) : "‚Äî";
    const branchLabel = getBranchLabel(branchForCal);
    let message = `Correction locale appliqu√©e : ŒîPK ${offsetLabel} m autour du PK ${pkLabel}. Branche : ${branchLabel}.`;
    if (!calibrationTimestamp) {
      message += " ‚ö†Ô∏è Coordonn√©es GPS indisponibles, point non enregistr√©.";
    }
    setRecalMessage(message.trim(), "success");
  }

  function undoLastRecal() {
    if (!recalHistory.length) {
      setRecalMessage("Aucun recalage √† annuler.", "error");
      return;
    }
    const entry = recalHistory.shift();
    const newOffset = Number.isFinite(entry.previousOffset) ? entry.previousOffset : pkOffset;
    pkOffset = newOffset;

    if (entry.calibrationTimestamp && Array.isArray(localCalibrations) && localCalibrations.length) {
      const index = localCalibrations.findIndex(cal => cal && cal.timestamp === entry.calibrationTimestamp);
      if (index !== -1) {
        localCalibrations.splice(index, 1);
        saveLocalCalibrations();
      }
    }

    lastCalibrationBuildTime = 0;
    buildCalibrationPolylines();

    safeSetItem("pkOffset", pkOffset);
    updateOffsetInfo();

    recomputeAfterBranchChange();
    updatePkTargetView();

    saveRecalHistory();
    renderRecalHistoryList();
    hideRecalPreview();
    if (inputPkRecal) {
      inputPkRecal.value = "";
    }
    const offsetRounded = Math.round(entry.offset || 0);
    const offsetLabel = offsetRounded > 0 ? "+" + offsetRounded : String(offsetRounded);
    setRecalMessage(`Dernier recalage annul√©. Correction locale ${offsetLabel} m retir√©e.`, "info");
  }

  function updateOffsetInfo() {
    const val = Math.round(pkOffset);
    const sign = val === 0 ? "0" : (val > 0 ? "+"+val : ""+val);
    const calibCount = localCalibrations ? localCalibrations.length : 0;
    pkOffsetInfo.textContent = "D√©calage global : " + sign + " m. Corrections locales enregistr√©es : " + calibCount + ".";
  }

  function savePhoneNumber() {
    const phoneValue = inputSosPhone.value.trim();
    
    if (!phoneValue) {
      alert("Veuillez saisir un num√©ro de t√©l√©phone.");
      return;
    }

    // Validation et nettoyage du num√©ro de t√©l√©phone
    // Supprimer les espaces, tirets et points
    const cleaned = phoneValue.replace(/[\s\-\.]/g, "");
    
    // V√©rifier le format : doit commencer par +33 ou 0, puis 9 chiffres
    // Format accept√© : +33XXXXXXXXX ou 0XXXXXXXXX (10 chiffres au total)
    const phoneRegex = /^(\+33|0)[1-9]\d{8}$/;
    
    if (!phoneRegex.test(cleaned)) {
      // Avertissement mais on permet quand m√™me la sauvegarde
      const confirmSave = confirm(
        "Le format du num√©ro de t√©l√©phone semble incorrect.\n" +
        "Format recommand√© : 0612345678 ou +33612345678\n\n" +
        "Voulez-vous quand m√™me enregistrer ce num√©ro ?"
      );
      if (!confirmSave) {
        return; // L'utilisateur annule
      }
      sosPhone = phoneValue; // Sauvegarder tel quel si format incorrect mais confirm√©
    } else {
      // Si le format est correct, on sauvegarde le num√©ro nettoy√©
      sosPhone = cleaned;
      inputSosPhone.value = sosPhone;
    }

    safeSetItem("sosPhone", sosPhone);
    
    // Message de confirmation
    alert("Num√©ro de t√©l√©phone sauvegard√© avec succ√®s ‚úÖ\n\nLe num√©ro sera conserv√© et recharg√© automatiquement.");
  }

  function saveSettings() {
    sosPhone = inputSosPhone.value.trim();
    motionSensitivity = selectSensitivity.value;

    // Validation et nettoyage du num√©ro de t√©l√©phone (optionnel)
    if (sosPhone) {
      // Supprimer les espaces, tirets et points
      const cleaned = sosPhone.replace(/[\s\-\.]/g, "");
      
      // V√©rifier le format : doit commencer par +33 ou 0, puis 9 chiffres
      // Format accept√© : +33XXXXXXXXX ou 0XXXXXXXXX (10 chiffres au total)
      const phoneRegex = /^(\+33|0)[1-9]\d{8}$/;
      
      if (!phoneRegex.test(cleaned)) {
        // Avertissement mais on permet quand m√™me la sauvegarde
        const confirmSave = confirm(
          "Le format du num√©ro de t√©l√©phone semble incorrect.\n" +
          "Format recommand√© : 0612345678 ou +33612345678\n\n" +
          "Voulez-vous quand m√™me enregistrer ce num√©ro ?"
        );
        if (!confirmSave) {
          return; // L'utilisateur annule
        }
      } else {
        // Si le format est correct, on sauvegarde le num√©ro nettoy√©
        sosPhone = cleaned;
        inputSosPhone.value = sosPhone;
      }
    }

    safeSetItem("sosPhone", sosPhone);
    safeSetItem("motionSensitivity", motionSensitivity);
    safeSetItem("pkOffset", pkOffset);

    updateOffsetInfo();
    
    // Message de confirmation
    alert("Param√®tres enregistr√©s avec succ√®s ‚úÖ");
  }

  function updatePkEstimateInSettings() {
    if (state.lastRawPk == null) {
      pkEstimateText.textContent = "En attente de position GPS‚Ä¶";
      if (pkCurrentValue) pkCurrentValue.textContent = "‚Äî";
      if (pkCurrentDetails) pkCurrentDetails.textContent = "";
      return;
    }

    const corrected = computePkWithCalibrations(state.lastRawPk, currentBranch);
    const pkText = "PK " + formatPk(corrected);
    let distText = state.lastDist != null
      ? "¬±" + Math.round(state.lastDist) + " m de la voie"
      : "";
    
    // V√©rifier si on est dans une zone de saut PK et ajouter un message UX/log
    const disc = findDiscontinuityForMetricPk(state.lastRawPk, currentBranch);
    if (disc && state.lastRawPk >= disc.pk_before - disc.window_m && state.lastRawPk < disc.pk_after) {
      const roundedPk = roundPkToDiscontinuityBounds(state.lastRawPk, currentBranch);
      if (distText) distText += " ¬∑ ";
      distText += `Zone de saut PK (${disc.pk_before}‚Üî${disc.pk_after}) ‚Äî position arrondie √† ${roundedPk}`;
    }

    // Mise √† jour du texte dans les param√®tres
    pkEstimateText.textContent = pkText + " " + distText;

    // Affichage sur la carte "PK actuel"
    if (pkCurrentValue) pkCurrentValue.textContent = pkText;
    if (pkCurrentDetails) pkCurrentDetails.textContent = distText || "";
  }

  let geolocActive = false;

  function updateGeolocButton() {
    if (!btnToggleGeoloc) return;
    if (geolocActive) {
      btnToggleGeoloc.innerHTML = '<span>üõë</span><span>Arr√™ter la g√©oloc</span>';
    } else {
      btnToggleGeoloc.innerHTML = '<span>üìç</span><span>Lancer la g√©oloc</span>';
    }
  }

  function setGpsStatus(status, message) {
    if (!gpsStatusBadge || !geolocText) return;

    const defaults = {
      off: {
        className: "status-badge status-badge--danger",
        label: "GPS OFF",
        message: "Pr√™t √† d√©marrer."
      },
      search: {
        className: "status-badge status-badge--warning",
        label: "GPS‚Ä¶",
        message: "Recherche du signal GPS‚Ä¶"
      },
      ok: {
        className: "status-badge status-badge--success",
        label: "GPS OK",
        message: "Signal GPS verrouill√©."
      },
      error: {
        className: "status-badge status-badge--danger",
        label: "GPS KO",
        message: "G√©olocalisation refus√©e. Active la g√©olocalisation dans les param√®tres de ton appareil."
      }
    };

    const conf = defaults[status] || defaults.off;
    gpsStatusBadge.className = conf.className;
    gpsStatusBadge.textContent = conf.label;
    geolocText.textContent = message || conf.message;
  }

  updateGeolocButton();
  setGpsStatus("off");

  function startGeoloc() {
    if (!navigator.geolocation) {
      setGpsStatus("error", "Ce navigateur ne supporte pas la g√©olocalisation.");
      return;
    }
    if (geolocActive) return;

    // S'assurer que les polylignes sont initialis√©es avant de d√©marrer la g√©olocalisation
    buildCalibrationPolylines();

    geolocActive = true;
    updateGeolocButton();
    setGpsStatus("search", "Recherche du signal GPS‚Ä¶");

    // Lancer directement watchPosition
    // La gestion des erreurs se fera dans handleGeolocError qui ignore les erreurs temporaires
    launchWatchPosition();
  }

  function launchWatchPosition() {
    // Optimisation batterie : augmenter maximumAge pour utiliser le cache GPS
    // et r√©duire la fr√©quence des mises √† jour
    state.watchId = navigator.geolocation.watchPosition(
      handlePosition,
      handleGeolocError,
      { 
        // Pour √©viter les timeouts au premier fix, on autorise une plus haute pr√©cision et un d√©lai plus long
        enableHighAccuracy: true,
        maximumAge: 10000,
        timeout: 60000
      }
    );
  }

  function stopGeoloc() {
    if (state.watchId != null) {
      navigator.geolocation.clearWatch(state.watchId);
      state.watchId = null;
    }
    geolocActive = false;
    updateGeolocButton();
    setGpsStatus("off");
    
    // D√©sactiver le mode "couvreur cheminant seul" si actif
    if (couvreurSeulActive) {
      stopCouvreurSeul();
    }
  }

  function handleGeolocError(err) {
    // Ne pas afficher d'erreur si la g√©olocalisation n'est pas active
    // (pour √©viter d'afficher "GPS KO" avant m√™me que l'utilisateur ait cliqu√©)
    if (!geolocActive) {
      return;
    }
    
    if (!err) {
      return;
    }
    
    // Ignorer les erreurs temporaires qui ne sont pas vraiment des erreurs
    // kCLErrorLocationUnknown (code 0) sur iOS/macOS = CoreLocation n'a pas encore de position, mais continue √† chercher
    const errorMessage = err.message ? String(err.message) : "";
    const errorString = JSON.stringify(err);
    // V√©rifier aussi dans toutes les propri√©t√©s de l'objet d'erreur
    const errorKeys = Object.keys(err || {});
    const errorValues = Object.values(err || {}).map(v => String(v));
    const allErrorText = [errorMessage, errorString, ...errorKeys, ...errorValues].join(" ").toLowerCase();
    
    // D√©tecter kCLErrorLocationUnknown sous toutes ses formes
    // Note: Le message "CoreLocationProvider: CoreLocation framework reported a kCLErrorLocationUnknown failure"
    // peut appara√Ætre dans la console syst√®me, mais l'objet d'erreur peut avoir une structure diff√©rente
    const isLocationUnknown = err.code === 0 || 
        errorMessage.includes("kCLErrorLocationUnknown") || 
        errorMessage.includes("LocationUnknown") ||
        errorMessage.toLowerCase().includes("location unknown") ||
        errorString.includes("kCLErrorLocationUnknown") ||
        allErrorText.includes("kclerrorlocationunknown") ||
        allErrorText.includes("locationunknown") ||
        (err.code === undefined && errorMessage === "") || // Certains navigateurs envoient une erreur vide pour LocationUnknown
        (err.code === undefined && err.message === undefined); // Erreur sans code ni message = probablement LocationUnknown
    
    if (isLocationUnknown) {
      // Ne pas afficher d'erreur pour cette erreur temporaire, juste logger en mode debug
      // Cette erreur est normale au d√©marrage de la g√©olocalisation sur macOS/Safari
      if (DEBUG_MODE) {
        console.log("Position GPS en cours d'acquisition... (erreur temporaire kCLErrorLocationUnknown ignor√©e)", {
          code: err.code,
          message: err.message,
          error: err
        });
      }
      return;
    }
    
    let userMessage = "Impossible d'obtenir la position.";
    
    // Traduire les messages d'erreur courants en fran√ßais
    if (err.code === 1 || (err.message && err.message.toLowerCase().includes("denied"))) {
      userMessage = "G√©olocalisation refus√©e. Active la g√©olocalisation dans les param√®tres de ton appareil.";
      // R√©initialiser geolocActive si permission refus√©e
      geolocActive = false;
      updateGeolocButton();
    } else if (err.code === 2 || (err.message && err.message.toLowerCase().includes("unavailable"))) {
      userMessage = "G√©olocalisation indisponible. V√©rifie que le GPS est activ√©.";
    } else if (err.code === 3 || (err.message && err.message.toLowerCase().includes("timeout"))) {
      userMessage = "D√©lai d'attente d√©pass√©. Extension du d√©lai et nouvelle tentative‚Ä¶";
      // En cas de timeout, relancer le watch avec un d√©lai plus long et haute pr√©cision
      try {
        if (state.watchId != null) {
          navigator.geolocation.clearWatch(state.watchId);
          state.watchId = null;
        }
        state.watchId = navigator.geolocation.watchPosition(
          handlePosition,
          handleGeolocError,
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 90000
          }
        );
      } catch (e) {
        console.warn("Relance watchPosition apr√®s timeout a √©chou√©:", e);
      }
    } else if (err.message) {
      // Pour les autres erreurs, v√©rifier si c'est une erreur LocationUnknown non d√©tect√©e
      const errMsgLower = String(err.message).toLowerCase();
      if (errMsgLower.includes("location") && (errMsgLower.includes("unknown") || errMsgLower.includes("unavailable"))) {
        // Probablement une variante de LocationUnknown, ignorer silencieusement
        if (DEBUG_MODE) {
          console.log("Erreur LocationUnknown d√©tect√©e (variante), ignor√©e:", err);
        }
        return;
      }
      // Pour les autres erreurs, utiliser le message par d√©faut
      userMessage = "Impossible d'obtenir la position. V√©rifie les autorisations.";
    } else {
      // Erreur sans message : probablement LocationUnknown sur certains navigateurs
      if (err.code === undefined || err.code === null) {
        if (DEBUG_MODE) {
          console.log("Erreur g√©olocalisation sans code/message (probablement LocationUnknown), ignor√©e:", err);
        }
        return;
      }
    }
    
    setGpsStatus("error", userMessage);
    console.error("Erreur g√©olocalisation:", err);
  }
  // Throttle pour limiter la fr√©quence des mises √† jour (√©conomie batterie)
  let lastUpdateTime = 0;
  const UPDATE_THROTTLE_MS = 1000; // Mise √† jour max toutes les 1 seconde (optimisation batterie)
  const HEADING_MIN_DISTANCE_M = 3; // Distance mini (m) avant de recalculer le cap (augment√© pour √©conomiser)
  
  // Fonction helper pour les logs de debug
  function debugLog(...args) {
    if (DEBUG_MODE) {
      console.log(...args);
    }
  }

  // === D√âTECTION PAR VILLE (REVERSE GEOCODING) ===
  // Cache pour √©viter trop d'appels API
  let cityDetectionCache = null;
  let cityDetectionCacheTime = 0;
  const CITY_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  async function detectCityFromCoordinates(lat, lon) {
    // Utiliser le cache si disponible
    const now = Date.now();
    if (cityDetectionCache && (now - cityDetectionCacheTime) < CITY_CACHE_DURATION) {
      return cityDetectionCache;
    }

    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`;
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'PK-Assistant-RER-A/1.0'
        }
      });
      
      if (!response.ok) {
        console.warn("Erreur reverse geocoding:", response.status);
        return null;
      }
      
      const data = await response.json();
      if (data && data.address) {
        const city = data.address.city || data.address.town || data.address.village || data.address.municipality;
        const cityLower = city ? city.toLowerCase() : "";
        
        // Normaliser les noms de villes
        let normalizedCity = null;
        if (cityLower.includes("nogent") && cityLower.includes("marne")) {
          normalizedCity = "Nogent-sur-Marne";
        } else if (cityLower.includes("fontenay")) {
          // Fontenay-sous-Bois ou Val de Fontenay - m√™me ville mais branches diff√©rentes
          if (cityLower.includes("val")) {
            normalizedCity = "Val de Fontenay";
          } else {
            normalizedCity = "Fontenay-sous-Bois";
          }
        }
        
        cityDetectionCache = normalizedCity;
        cityDetectionCacheTime = now;
        return normalizedCity;
      }
    } catch (error) {
      console.warn("Erreur lors du reverse geocoding:", error);
    }
    
    return null;
  }

  // Fonction pour obtenir le PK et la branche depuis la ville d√©tect√©e
  function getPkFromCity(cityName) {
    if (!cityName) return null;
    
    // Chercher dans la branche Boissy
    for (const station of brancheBoissy) {
      if (station.name === cityName) {
        return {
          pk: station.pk,
          branch: "boissy",
          station: station
        };
      }
    }
    
    // Chercher dans la branche Chessy
    for (const station of brancheChessy) {
      if (station.name === cityName) {
        return {
          pk: station.pk,
          branch: "chessy",
          station: station
        };
      }
    }
    
    return null;
  }

  /**
   * Helper pour d√©tecter la branche et le PK bas√© sur la proximit√© d'une ville/gare connue
   * @param {number} lat - Latitude GPS
   * @param {number} lon - Longitude GPS
   * @param {string|null} manualBranchOverride - Override manuel actif (null ou "auto" = mode Auto)
   * @returns {Object|null} - { pk: number, branch: string, name: string, distance: number } ou null
   */
  function findCityBasedPk(lat, lon, manualBranchOverride) {
    // Ne rien faire si override manuel actif
    if (manualBranchOverride && manualBranchOverride !== "auto") {
      return null;
    }

    // R√©cup√©rer les donn√©es des stations depuis brancheBoissy et brancheChessy
    const nogentStation = brancheBoissy.find(s => s.name === "Nogent-sur-Marne");
    const fontenayStation = brancheBoissy.find(s => s.name === "Fontenay-sous-Bois");
    const joinvilleStation = brancheBoissy.find(s => s.name === "Joinville-le-Pont");
    const saintMaurStation = brancheBoissy.find(s => s.name === "Saint-Maur ‚Äì Cr√©teil");
    const parcStation = brancheBoissy.find(s => s.name === "Parc de Saint-Maur");
    const varenneStation = brancheBoissy.find(s => s.name === "La Varenne ‚Äì Chennevi√®res");
    const sucyStation = brancheBoissy.find(s => s.name === "Sucy ‚Äì Bonneuil");
    const boissyStation = brancheBoissy.find(s => s.name === "Boissy-Saint-L√©ger");
    const valFontenayStation = brancheChessy.find(s => s.name === "Val de Fontenay");

    // Calculer les coordonn√©es approximatives pour Parc de Saint-Maur (interpolation entre Saint-Maur et La Varenne)
    let parcLat = null;
    let parcLon = null;
    if (parcStation && saintMaurStation && varenneStation && 
        saintMaurStation.lat && varenneStation.lat) {
      // Interpolation lin√©aire bas√©e sur les PK
      const pkDiff = varenneStation.pk - saintMaurStation.pk;
      const parcDiff = parcStation.pk - saintMaurStation.pk;
      const ratio = pkDiff > 0 ? parcDiff / pkDiff : 0.5;
      parcLat = saintMaurStation.lat + (varenneStation.lat - saintMaurStation.lat) * ratio;
      parcLon = saintMaurStation.lon + (varenneStation.lon - saintMaurStation.lon) * ratio;
    }

    // Tableau de r√®gles city-based (par ordre de priorit√©)
    const rules = [
      // R√®gles existantes (priorit√© 1-3)
      {
        name: "Nogent-sur-Marne",
        branch: "boissy",
        pk: nogentStation ? nogentStation.pk : 34000,
        lat: nogentStation ? nogentStation.lat : 48.8353972244,
        lon: nogentStation ? nogentStation.lon : 2.4716593319,
        radius: 1000,
        priority: 1
      },
      {
        name: "Val de Fontenay",
        branch: "chessy",
        pk: valFontenayStation ? valFontenayStation.pk : 34525,
        lat: valFontenayStation ? valFontenayStation.lat : 48.8544183594,
        lon: valFontenayStation ? valFontenayStation.lon : 2.4890884591,
        radius: 1000,
        priority: 2
      },
      {
        name: "Fontenay-sous-Bois",
        branch: "boissy",
        pk: fontenayStation ? fontenayStation.pk : 32750,
        lat: fontenayStation ? fontenayStation.lat : 48.84448287866945,
        lon: fontenayStation ? fontenayStation.lon : 2.464306353806553,
        radius: 1000,
        priority: 3
      },
      // Nouvelles r√®gles pour la branche Boissy (priorit√© 4-9)
      {
        name: "Joinville-le-Pont",
        branch: "boissy",
        pk: joinvilleStation ? joinvilleStation.pk : 35600,
        lat: joinvilleStation ? joinvilleStation.lat : 48.8211820545,
        lon: joinvilleStation ? joinvilleStation.lon : 2.4641431755,
        radius: 1200,
        priority: 4
      },
      {
        name: "Saint-Maur ‚Äì Cr√©teil",
        branch: "boissy",
        pk: saintMaurStation ? saintMaurStation.pk : 37500,
        lat: saintMaurStation ? saintMaurStation.lat : 48.8088207060,
        lon: saintMaurStation ? saintMaurStation.lon : 2.4708026167,
        radius: 1200,
        priority: 5
      },
      {
        name: "Parc de Saint-Maur",
        branch: "boissy",
        pk: parcStation ? parcStation.pk : 38500,
        lat: parcLat || 48.801, // Approximation si interpolation √©choue
        lon: parcLon || 2.492, // Approximation si interpolation √©choue
        radius: 1200,
        priority: 6
      },
      {
        name: "La Varenne ‚Äì Chennevi√®res",
        branch: "boissy",
        pk: varenneStation ? varenneStation.pk : 41800,
        lat: varenneStation ? varenneStation.lat : 48.7941968899,
        lon: varenneStation ? varenneStation.lon : 2.5135124577,
        radius: 1200,
        priority: 7
      },
      {
        name: "Sucy ‚Äì Bonneuil",
        branch: "boissy",
        pk: sucyStation ? sucyStation.pk : 44500,
        lat: sucyStation ? sucyStation.lat : 48.7709911746,
        lon: sucyStation ? sucyStation.lon : 2.5083777258,
        radius: 1200,
        priority: 8
      },
      {
        name: "Boissy-Saint-L√©ger",
        branch: "boissy",
        pk: boissyStation ? boissyStation.pk : 47200,
        lat: boissyStation ? boissyStation.lat : 48.7539872386,
        lon: boissyStation ? boissyStation.lon : 2.5059802969,
        radius: 1200,
        priority: 9
      }
    ];

    let best = null;

    for (const rule of rules) {
      // V√©rifier que les coordonn√©es sont valides
      if (!rule.lat || !rule.lon || !Number.isFinite(rule.lat) || !Number.isFinite(rule.lon)) {
        continue;
      }

      const d = distanceMeters(lat, lon, rule.lat, rule.lon);
      if (d <= rule.radius) {
        if (!best || rule.priority < best.priority || (rule.priority === best.priority && d < best.distance)) {
          best = {
            pk: rule.pk,
            branch: rule.branch,
            name: rule.name,
            distance: d
          };
        }
      }
    }

    return best;
  }

  function handlePosition(pos) {
    try {
      if (!pos || !pos.coords) {
        console.warn("‚ö†Ô∏è handlePosition: position invalide", pos);
        return;
      }
      
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const accuracy = pos.coords.accuracy; // AJOUT CALIBRAGE

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        console.warn("‚ö†Ô∏è handlePosition: coordonn√©es GPS invalides", { lat, lon });
        return;
      }

      state.lastAccuracy = accuracy;

    // Throttle : ne pas mettre √† jour trop souvent
    const now = Date.now();
    const timeSinceLastUpdate = now - lastUpdateTime;
    
    // Toujours mettre √† jour le statut GPS (l√©ger)
    const accuracyText = accuracy != null
      ? "Pr√©cision ¬±" + Math.round(accuracy) + " m"
      : undefined;
    setGpsStatus("ok", accuracyText);

    // Si moins de 0,4 seconde depuis la derni√®re mise √† jour, ignorer (sauf premi√®re position)
    if (timeSinceLastUpdate < UPDATE_THROTTLE_MS && state.lastPk != null) {
      return;
    }
    lastUpdateTime = now;

    // S'assurer que les polylignes sont construites
    if (!linePointsBoissy || !linePointsChessy) {
      buildCalibrationPolylines();
    }
    
    // V√©rifier que les polylignes sont bien construites
    if (!linePointsBoissy || linePointsBoissy.length < 2) {
      console.warn("‚ö†Ô∏è linePointsBoissy invalide, reconstruction...");
      buildCalibrationPolylines();
    }
    if (!linePointsChessy || linePointsChessy.length < 2) {
      console.warn("‚ö†Ô∏è linePointsChessy invalide, reconstruction...");
      buildCalibrationPolylines();
    }

    // === D√âTECTION PAR VILLE (bas√©e sur les coordonn√©es GPS) ===
    // Utiliser le helper g√©n√©rique pour d√©tecter la branche et le PK bas√© sur la proximit√© d'une ville/gare
    const cityResult = findCityBasedPk(lat, lon, manualBranchOverride);
    
    if (cityResult) {
      const { pk, branch, name, distance } = cityResult;
      
      // Mettre √† jour la branche et la PK brute projet√©e
      currentBranch = branch;
      
      // Configurer les linePoints selon la branche
      const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
      const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
      const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];
      
      if (branch === "boissy") {
        linePoints = linePointsBoissy || safeTroncCommun.concat(safeBrancheBoissy);
      } else if (branch === "chessy") {
        linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      } else if (branch === "central") {
        linePoints = safeTroncCommun.slice();
      }
      
      // Passer directement au calcul du PK corrig√©
      const rawPk = pk;
      const correctedPk = computePkWithCalibrations(rawPk, currentBranch);
      const nowSeconds = Date.now() / 1000;
      
      if (state.lastPk != null && state.lastPkTime != null) {
        const dPk = correctedPk - state.lastPk;
        const dt = nowSeconds - state.lastPkTime;
        if (dt > 0.4) {
          updateMovement(dPk, dt, lat, lon);
        }
      } else {
        state.direction = null;
        state.heading = null;
      }
      
      state.lastPk = correctedPk;
      state.lastPkTime = nowSeconds;
      state.lastLat = lat;
      state.lastLon = lon;
      state.lastDist = 0; // Distance suppos√©e nulle car on est dans la ville/gare
      state.lastRawPk = rawPk;
      
      updateLegendBranchUI();
      updatePkDisplay();
      updateNearestStation(correctedPk, null);
      updateNearestAccess();
      updateMapMarker(lat, lon, correctedPk);
      updateOrientationPanel();
      
      // Log de debug complet g√©oloc (city-based)
      console.log(`‚úÖ ${name} d√©tect√© (distance: ${Math.round(distance)} m) ‚Üí PK forc√© √† ${rawPk} (${branch})`);
      debugLog("DEBUG_GEO_CITY_BASED", {
        ...cityResult,
        correctedPk,
        displayPk: formatPk(correctedPk, branch),
        manualOverride: manualBranchOverride,
        timestamp: new Date().toISOString()
      });
      
      return; // On ne passe PAS dans la logique auto si une r√®gle city-based s'applique
    }
    
    // D√©tection asynchrone pour les autres villes (ne bloque pas, ne fait que logger)
    detectCityFromCoordinates(lat, lon).then(cityName => {
      if (cityName) {
        const cityPkInfo = getPkFromCity(cityName);
        if (cityPkInfo) {
          console.log("üèôÔ∏è Ville d√©tect√©e (async):", cityName, "‚Üí PK:", cityPkInfo.pk, "branche:", cityPkInfo.branch);
        }
      }
    }).catch(err => {
      // Ignorer les erreurs silencieusement
    });
    
    // === OVERRIDE MANUEL STRICT (prioritaire sur toute la logique auto) ===
    const hasManualOverride = !!manualBranchOverride && manualBranchOverride !== "auto";
    
    if (hasManualOverride) {
      // üîí OVERRIDE MANUEL STRICT : on projette uniquement sur la branche choisie
      const safeTroncCommun    = Array.isArray(troncCommun) ? troncCommun : [];
      const safeBrancheBoissy  = Array.isArray(brancheBoissy) ? brancheBoissy : [];
      const safeBrancheChessy  = Array.isArray(brancheChessy) ? brancheChessy : [];
      
      currentBranch = manualBranchOverride;
      
      if (manualBranchOverride === "boissy") {
        linePoints = linePointsBoissy || safeTroncCommun.concat(safeBrancheBoissy);
      } else if (manualBranchOverride === "chessy") {
        linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      } else if (manualBranchOverride === "central") {
        linePoints = safeTroncCommun.slice();
      }
      
      const projOverride = projectToLine(lat, lon);
      if (projOverride && projOverride.pkProj != null) {
        const rawPk = projOverride.pkProj;
        const correctedPk = computePkWithCalibrations(rawPk, currentBranch);
        const nowSeconds = Date.now() / 1000;
        
        if (state.lastPk != null && state.lastPkTime != null) {
          const dPk = correctedPk - state.lastPk;
          const dt = nowSeconds - state.lastPkTime;
          if (dt > 0.4) {
            updateMovement(dPk, dt, lat, lon);
          }
        } else {
          state.direction = null;
          state.heading = null;
        }
        
        state.lastPk = correctedPk;
        state.lastPkTime = nowSeconds;
        state.lastLat = lat;
        state.lastLon = lon;
        state.lastDist = projOverride.dist;
        state.lastRawPk = rawPk;
        
        updateLegendBranchUI();
        updatePkDisplay();
        updateNearestStation(correctedPk, null);
        updateNearestAccess();
        updateMapMarker(lat, lon, correctedPk);
        updateOrientationPanel();
        
        debugLog("‚úÖ Override manuel strict utilis√©", {
          manualOverride: manualBranchOverride,
          branchId: currentBranch,
          pkMetric: rawPk,
          correctedPk: correctedPk,
          distance: projOverride.dist,
        });
        
        // Log de debug complet g√©oloc (override manuel)
        debugLog("DEBUG_GEO", {
          manualOverride: manualBranchOverride,
          currentBranch,
          rawPk,
          correctedPk,
          displayPk: formatPk(correctedPk),
          lat,
          lon,
          timestamp: new Date().toISOString()
        });
        
        return; // Sortir de la fonction, override strict appliqu√©
      } else {
        console.warn("‚ö†Ô∏è Override manuel actif mais projection √©chou√©e, fallback sur logique auto");
        // Si la projection √©choue, on continue avec la logique auto (fallback)
      }
    }
    
    // === LOGIQUE AUTO (uniquement si pas d'override manuel) ===
    // D'abord, projeter sur les deux branches pour obtenir les PKs
    // On a besoin des PKs pour appliquer la r√®gle absolue : PK >= 34000 = Chessy (Val de Fontenay)
    const savedLinePoints = linePoints;
    const safeTroncCommun = Array.isArray(troncCommun) ? troncCommun : [];
    const safeBrancheBoissy = Array.isArray(brancheBoissy) ? brancheBoissy : [];
    const safeBrancheChessy = Array.isArray(brancheChessy) ? brancheChessy : [];
    
    // Utiliser les polylignes calibr√©es si disponibles, sinon les polylignes de base
    linePoints = linePointsBoissy || safeTroncCommun.concat(safeBrancheBoissy);
    if (!linePoints || linePoints.length < 2) {
      console.warn("‚ö†Ô∏è linePoints Boissy invalide pour projection");
      linePoints = safeTroncCommun.concat(safeBrancheBoissy);
    }
    const projBoissyTemp = projectToLine(lat, lon);
    
    linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
    if (!linePoints || linePoints.length < 2) {
      console.warn("‚ö†Ô∏è linePoints Chessy invalide pour projection");
      linePoints = safeTroncCommun.concat(safeBrancheChessy);
    }
    const projChessyTemp = projectToLine(lat, lon);
    linePoints = savedLinePoints;
    
    // Variables pour stocker les projections
    let bestProj = null;
    let bestBranch = null;
    
    // R√àGLE ABSOLUE : Si le PK projet√© est >= 34000, on est FORC√âMENT sur Chessy
    // (uniquement en mode Auto, pas d'override manuel)
    if (projChessyTemp && projChessyTemp.pkProj != null && projChessyTemp.pkProj >= BRANCH_CHESSY_MIN) {
      debugLog("üî¥ R√àGLE ABSOLUE : PK", projChessyTemp.pkProj, ">= 34000 ‚Üí FORC√âMENT Chessy (ex: Val de Fontenay, Noisy-Champs)");
      currentBranch = "chessy";
      linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      bestProj = projChessyTemp;
      bestBranch = "chessy";
      console.log("‚úÖ Branche Chessy forc√©e, PK:", bestProj.pkProj);
    }
    
    // Si pas de r√®gle absolue appliqu√©e, d√©tecter automatiquement
    if (!bestProj) {
      // Utiliser les projections d√©j√† calcul√©es
      const projBoissy = projBoissyTemp;
      const projChessy = projChessyTemp;
      
      // Choisir la meilleure branche selon :
      // 1. La distance √† la voie (plus proche = mieux)
      // 2. La coh√©rence du PK avec les gares de la branche
      bestBranch = "chessy"; // Par d√©faut
      bestProj = projChessy || projBoissy;
      
      if (projBoissy && projBoissy.pkProj != null && projChessy && projChessy.pkProj != null) {
        const pkBoissy = projBoissy.pkProj;
        const pkChessy = projChessy.pkProj;
        
        // Si le PK est > 30000, on est forc√©ment sur une branche
        if (pkBoissy > BRANCH_COMMON_MAX && pkChessy > BRANCH_COMMON_MAX) {
          // PRIORIT√â 1 : Si le PK Chessy est >= 34000, on est sur Chessy (r√®gle absolue)
          // Val de Fontenay est √† PK 34000, Noisy-Champs √† PK 41000, donc Chessy
          if (pkChessy >= BRANCH_CHESSY_MIN) {
            bestBranch = "chessy";
            bestProj = projChessy;
            debugLog("‚úÖ Chessy choisi : PK", pkChessy, ">= 34000 (branche Chessy) - Ex: Val de Fontenay, Noisy-Champs");
          } else if (pkBoissy < BRANCH_CHESSY_MIN && pkChessy < BRANCH_CHESSY_MIN) {
            // PK entre 30000 et 34000 (zone de transition apr√®s Vincennes), utiliser la distance √† la voie
            if (projChessy.dist < projBoissy.dist) {
              bestBranch = "chessy";
              bestProj = projChessy;
              const distDiff = projBoissy.dist - projChessy.dist;
              debugLog("‚úÖ Chessy choisi : plus proche de la voie (", projChessy.dist, "m vs", projBoissy.dist, "m, diff:", distDiff.toFixed(1), "m)");
            } else {
              bestBranch = "boissy";
              bestProj = projBoissy;
              const distDiff = projChessy.dist - projBoissy.dist;
              debugLog("‚úÖ Boissy choisi : plus proche de la voie (", projBoissy.dist, "m vs", projChessy.dist, "m, diff:", distDiff.toFixed(1), "m)");
            }
          } else {
            // PK Boissy < 34000 mais Chessy >= 34000 : on choisit Chessy
            // Ou PK Boissy >= 32750 : Boissy (Fontenay-sous-Bois)
            if (pkBoissy >= BRANCH_BOISSY_MIN) {
              bestBranch = "boissy";
              bestProj = projBoissy;
              debugLog("‚úÖ Boissy choisi : PK", pkBoissy, ">= 32750 (branche Boissy - Fontenay-sous-Bois)");
            } else {
              bestBranch = "chessy";
              bestProj = projChessy;
              debugLog("‚úÖ Chessy choisi : PK", pkChessy, ">= 34000 (branche Chessy)");
            }
          }
        } else if (pkBoissy > BRANCH_COMMON_MAX && pkChessy <= BRANCH_COMMON_MAX) {
          // Boissy est coh√©rent, Chessy non
          bestBranch = "boissy";
          bestProj = projBoissy;
        } else if (pkChessy > BRANCH_COMMON_MAX && pkBoissy <= BRANCH_COMMON_MAX) {
          // Chessy est coh√©rent, Boissy non
          // Si le PK est >= 34000, on est sur Chessy
          if (pkChessy >= BRANCH_CHESSY_MIN) {
            bestBranch = "chessy";
            bestProj = projChessy;
            debugLog("‚úÖ Chessy choisi : PK", pkChessy, ">= 34000 (branche Chessy - Val de Fontenay)");
          } else {
            bestBranch = "chessy";
            bestProj = projChessy;
          }
        } else {
          // Les deux sont <= 30000, on est sur le tronc commun
          // Comparer les distances pour choisir la meilleure projection
          if (projChessy.dist < projBoissy.dist) {
            bestBranch = "central";
            linePoints = safeTroncCommun.slice();
            bestProj = projectToLine(lat, lon);
            debugLog("‚úÖ Tronc commun choisi (PK <= 30000), Chessy plus proche (", projChessy.dist, "m vs", projBoissy.dist, "m)");
          } else {
            bestBranch = "central";
            linePoints = safeTroncCommun.slice();
            bestProj = projectToLine(lat, lon);
            debugLog("‚úÖ Tronc commun choisi (PK <= 30000), Boissy plus proche (", projBoissy.dist, "m vs", projChessy.dist, "m)");
          }
        }
      } else if (projBoissy && projBoissy.pkProj != null) {
        bestBranch = "boissy";
        bestProj = projBoissy;
      } else if (projChessy && projChessy.pkProj != null) {
        bestBranch = "chessy";
        bestProj = projChessy;
      } else {
        // Aucune projection valide, utiliser la d√©tection GPS
        const detectedBranch = detectBranch(lat, lon);
        bestBranch = detectedBranch === "both" ? "central" : detectedBranch;
        console.log("Aucune projection valide, utilisation de la d√©tection GPS:", bestBranch);
      }
      
      if (bestBranch) {
        currentBranch = bestBranch;
        console.log("Branche d√©termin√©e par comparaison des projections:", currentBranch, 
                    "PK Boissy:", projBoissyTemp?.pkProj, "dist:", projBoissyTemp?.dist,
                    "PK Chessy:", projChessyTemp?.pkProj, "dist:", projChessyTemp?.dist);
      }
    }
    
    // S'assurer que currentBranch est d√©fini m√™me si bestBranch n'a pas √©t√© d√©fini
    if (!currentBranch || (bestProj && !bestBranch)) {
      // Si on a une projection mais pas de branche, d√©terminer la branche depuis la projection
      if (bestProj && bestProj.pkProj != null) {
        if (bestProj.pkProj >= BRANCH_CHESSY_MIN) {
          currentBranch = "chessy";
        } else if (bestProj.pkProj >= BRANCH_BOISSY_MIN) {
          currentBranch = "boissy";
        } else if (bestProj.pkProj <= BRANCH_COMMON_MAX) {
          currentBranch = "central";
        } else {
          currentBranch = "chessy"; // Par d√©faut
        }
      } else if (!currentBranch) {
        currentBranch = "chessy"; // Par d√©faut
      }
    }

    // On choisit la bonne poly-ligne pour la projection PK finale
    if (currentBranch === "boissy") {
      linePoints = linePointsBoissy || safeTroncCommun.concat(safeBrancheBoissy);
      debugLog("Utilisation de la polyligne Boissy, longueur:", linePoints.length);
    } else if (currentBranch === "chessy") {
      linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      debugLog("Utilisation de la polyligne Chessy, longueur:", linePoints.length);
    } else if (currentBranch === "central") {
      linePoints = safeTroncCommun.slice();
      debugLog("Utilisation du tronc commun uniquement, longueur:", linePoints.length);
    } else {
      // S√©curit√© : si "both" ou autre, on reste sur Chessy par d√©faut
      linePoints = linePointsChessy || safeTroncCommun.concat(safeBrancheChessy);
      debugLog("Branche inconnue, utilisation de Chessy par d√©faut, longueur:", linePoints.length);
    }
    updateLegendBranchUI();

    // Utiliser la projection d√©j√† calcul√©e si disponible, sinon recalculer
    // Note: l'override manuel strict sort d√©j√† de la fonction plus haut, donc on est forc√©ment en mode Auto ici
    let proj;
    if (bestProj) {
      // Utiliser la projection d√©j√† calcul√©e (d√©tection automatique)
      proj = bestProj;
      debugLog("‚úÖ Utilisation de la projection d√©j√† calcul√©e:", proj.pkProj, "branche:", currentBranch);
    } else {
      // Utiliser la meilleure projection d√©j√† calcul√©e ou recalculer
      proj = bestProj || projectToLine(lat, lon);
    }
    if (proj.pkProj == null) {
      console.warn("projectToLine a retourn√© null. linePoints:", linePoints ? linePoints.length : 0, "currentBranch:", currentBranch);
      return;
    }
    
    // V√©rification : si le PK projet√© est exactement 35000, c'est suspect (point d'acc√®s sans GPS)
    if (proj.pkProj === 35000) {
      console.warn("‚ö†Ô∏è PK projet√© = 35000 (point d'acc√®s suspect). V√©rification de la projection...");
      console.warn("  linePoints.length:", linePoints ? linePoints.length : 0);
      console.warn("  currentBranch:", currentBranch);
      console.warn("  proj.dist:", proj.dist);
      // Forcer un recalcul si la distance est trop grande
      if (proj.dist > 1000) {
        console.warn("  Distance trop grande, projection probablement incorrecte");
      }
    }
    
    debugLog("Projection r√©ussie - PK:", proj.pkProj, "distance:", proj.dist, "branche:", currentBranch);

    // === DEBUG G√âOLOCALISATION : Log du r√©sultat avec branchId et pkMetric ===
    console.log('DEBUG_GEO_RESULT', {
      branchId: currentBranch,
      pkMetric: proj.pkProj,
      lat: lat,
      lon: lon,
      distance: proj.dist,
      correctedPk: null // Sera mis √† jour apr√®s computePkWithCalibrations
    });

    const rawPk = proj.pkProj;
    const correctedPk = computePkWithCalibrations(rawPk, currentBranch);
    
    // Mettre √† jour le log avec le PK corrig√©
    console.log('DEBUG_GEO_RESULT (corrig√©)', {
      branchId: currentBranch,
      pkMetric: correctedPk,
      rawPk: rawPk,
      lat: lat,
      lon: lon
    });
    const nowSeconds = Date.now() / 1000;

    if (state.lastPk != null && state.lastPkTime != null) {
      const dPk = correctedPk - state.lastPk;
      const dt = nowSeconds - state.lastPkTime;
      if (dt > 0.4) {
        updateMovement(dPk, dt, lat, lon);
      }
    } else {
      movementTitle.textContent = "D√©tection en cours";
      movementDetails.textContent = "";
    }

    state.lastRawPk   = rawPk;
    state.lastPk      = correctedPk;
    state.lastPkTime  = nowSeconds;
    state.lastLat     = lat;
    state.lastLon     = lon;
    state.lastDist    = proj.dist;
    
    // Log de debug complet g√©oloc
    debugLog("DEBUG_GEO", {
      manualOverride: manualBranchOverride,
      currentBranch,
      rawPk,
      correctedPk,
      displayPk: formatPk(correctedPk),
      lat,
      lon,
      timestamp: new Date().toISOString()
    });
    
    // V√©rifier le mouvement pour le mode "couvreur cheminant seul"
    if (couvreurSeulActive) {
      checkCouvreurMovement();
    }

    // IMPORTANT : correctedPk est TOUJOURS en absolu (m√™me si l'utilisateur voit du relatif √† l'√©cran)
    // Tous les calculs internes utilisent des PK absolus
    // Seuls les affichages utilisent des PK relatifs (via formatPk())
    const nearest       = findNearestStation(correctedPk, currentBranch);
    
    // PRIORIT√â : Chercher d'abord les acc√®s de la gare la plus proche
    // IMPORTANT : nearest.pk est TOUJOURS en absolu (comme tous les PK des stations)
    let nearestAccess = null;
    if (nearest && nearest.name) {
      // √âtape 1 : Chercher les acc√®s qui correspondent au nom de la gare (priorit√© absolue)
      const stationNameLower = nearest.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      const stationWords = stationNameLower.split(/[\s-‚Äì‚Äî]+/).filter(w => w.length > 2);
      
      // Mots distinctifs (exclure les mots communs)
      const distinctiveWords = stationWords.filter(w => 
        !["de", "le", "la", "les", "du", "des", "et", "en", "sur", "sous", "noisy", "grand", "saint", "paris", "l", "gare"].includes(w)
      );
      
      let matchingAccesses = [];
      for (const acc of accessPoints) {
        if (!acc.name) continue;
        const accNameLower = acc.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        
        // V√©rifier si l'acc√®s contient "gare" et correspond au nom de la gare
        if (!accNameLower.includes("gare")) {
          // Pour les acc√®s non-gare, v√©rifier s'ils correspondent vraiment √† la gare
          let matches = false;
          if (distinctiveWords.length > 0) {
            // V√©rifier si les mots distinctifs de la gare sont pr√©sents dans l'acc√®s
            matches = distinctiveWords.some(distWord => {
              return accNameLower.includes(distWord);
            });
          } else {
            // Si pas de mots distinctifs, v√©rifier au moins un mot commun
            matches = stationWords.some(stWord => {
              return accNameLower.includes(stWord);
            });
          }
          if (!matches) continue;
        }
        
        // V√©rifier la correspondance avec le nom de la gare
        let nameMatches = false;
        if (accNameLower.includes("gare")) {
          // Pour les acc√®s "gare", extraire le nom de la gare
          const accStationName = accNameLower.replace(/^gare\s+(de\s+)?/i, "").trim();
          nameMatches = accStationName.includes(stationNameLower) || 
                       stationNameLower.includes(accStationName) ||
                       (distinctiveWords.length > 0 && distinctiveWords.some(distWord => accStationName.includes(distWord)));
        } else {
          // Pour les autres acc√®s, v√©rifier les mots distinctifs
          if (distinctiveWords.length > 0) {
            nameMatches = distinctiveWords.some(distWord => accNameLower.includes(distWord));
          } else {
            nameMatches = stationWords.some(stWord => accNameLower.includes(stWord));
          }
        }
        
        if (nameMatches) {
          matchingAccesses.push(acc);
        }
      }
      
      // Si on a trouv√© des acc√®s correspondant au nom, choisir le plus proche (GPS ou PK)
      if (matchingAccesses.length > 0) {
        if (lat != null && lon != null) {
          let bestGeoAccess = null;
          let bestGeoDist = Infinity;
          for (const acc of matchingAccesses) {
            if (acc.lat != null && acc.lon != null) {
              const d = distanceMeters(lat, lon, acc.lat, acc.lon);
              if (d < bestGeoDist) {
                bestGeoDist = d;
                bestGeoAccess = acc;
              }
            }
          }
          if (bestGeoAccess) {
            nearestAccess = bestGeoAccess;
            debugLog("‚úÖ Acc√®s trouv√© pour la gare", nearest.name, "par nom et GPS:", bestGeoAccess.name);
          }
        }
        
        // Si pas de GPS ou pas d'acc√®s avec GPS, choisir le plus proche en PK
        // IMPORTANT : Tous les PK sont en absolu (acc.pk et nearest.pk sont toujours en absolu)
        if (!nearestAccess && nearest.pk != null) {
          let bestPkAccess = null;
          let bestPkDiff = Infinity;
          for (const acc of matchingAccesses) {
            if (acc.pk != null) {
              // Comparaison absolu vs absolu (toujours correct)
              const pkDiff = Math.abs(acc.pk - nearest.pk);
              if (pkDiff < bestPkDiff) {
                bestPkDiff = pkDiff;
                bestPkAccess = acc;
              }
            }
          }
          if (bestPkAccess) {
            nearestAccess = bestPkAccess;
            debugLog("‚úÖ Acc√®s trouv√© pour la gare", nearest.name, "par nom et PK:", bestPkAccess.name, "PK abs:", bestPkAccess.pk, "vs gare PK abs:", nearest.pk);
          }
        }
      }
      
      // √âtape 2 : Si aucun acc√®s trouv√© par nom, chercher par PK (rayon 300m)
      // IMPORTANT : Tous les PK sont en absolu (acc.pk et nearest.pk sont toujours en absolu)
      if (!nearestAccess && nearest.pk != null) {
        const STATION_ACCESS_RADIUS = 300; // m√®tres
        let bestStationAccess = null;
        let bestPkDiff = Infinity;
        
        for (const acc of accessPoints) {
          if (acc.pk == null) continue;
          // Comparaison absolu vs absolu (toujours correct)
          const pkDiff = Math.abs(acc.pk - nearest.pk);
          if (pkDiff <= STATION_ACCESS_RADIUS && pkDiff < bestPkDiff) {
            bestPkDiff = pkDiff;
            bestStationAccess = acc;
          }
        }
        
        if (bestStationAccess) {
          nearestAccess = bestStationAccess;
          debugLog("‚úÖ Acc√®s trouv√© pour la gare", nearest.name, "par PK uniquement:", bestStationAccess.name, "PK abs:", bestStationAccess.pk, "vs gare PK abs:", nearest.pk);
        }
      }
    }
    
    // Fallback : Si aucun acc√®s trouv√© pour la gare, utiliser la m√©thode GPS ou PK
    if (!nearestAccess) {
      if (lat != null && lon != null) {
        nearestAccess = findNearestAccessGeo(lat, lon);
        debugLog("‚ö†Ô∏è Aucun acc√®s trouv√© pour la gare, utilisation GPS:", nearestAccess ? nearestAccess.name : "aucun");
      } else if (correctedPk != null) {
        nearestAccess = findNearestAccess(correctedPk, currentBranch);
        debugLog("‚ö†Ô∏è Aucun acc√®s trouv√© pour la gare, utilisation PK:", nearestAccess ? nearestAccess.name : "aucun");
      }
    }

    state.nearestStation = nearest;
    state.nearestAccess  = nearestAccess;

    // Mettre √† jour le PK actuel dans l'interface principale
    if (pkCurrentValue) {
      const pkText = "PK " + formatPk(correctedPk);
      pkCurrentValue.textContent = pkText;
      debugLog("PK actuel mis √† jour dans l'interface:", pkText);
    }
    if (pkCurrentDetails) {
      let distText = proj.dist != null ? "¬±" + Math.round(proj.dist) + " m de la voie" : "";
      // V√©rifier si on est dans une zone de saut PK et ajouter un message UX/log
      const disc = findDiscontinuityForMetricPk(proj.pkProj, currentBranch);
      if (disc && proj.pkProj >= disc.pk_before - disc.window_m && proj.pkProj < disc.pk_after) {
        const roundedPk = roundPkToDiscontinuityBounds(proj.pkProj, currentBranch);
        if (distText) distText += " ¬∑ ";
        distText += `Zone de saut PK (${disc.pk_before}‚Üî${disc.pk_after}) ‚Äî position arrondie √† ${roundedPk}`;
      }
      pkCurrentDetails.textContent = distText;
    }

    updateNearestStation(correctedPk, nearest);
    updateNextStation(correctedPk);
    updateNearestAccess(correctedPk);
    updatePkTargetView();
    updateSmsPreview();
    updatePkEstimateInSettings();
    updateOrientationPanel();
    } catch (error) {
      // Capturer toute erreur dans handlePosition pour √©viter de bloquer la g√©olocalisation
      console.error("‚ö†Ô∏è Erreur dans handlePosition:", error);
      console.error("Stack:", error.stack);
      // Ne pas afficher d'erreur √† l'utilisateur car c'est une erreur interne
      // La g√©olocalisation continuera √† fonctionner pour les prochaines positions
    }
  }
  function updateMovement(dPk, dt, lat, lon) {
    const profile = sensitivityProfiles[motionSensitivity] || sensitivityProfiles.normal;
    const speed = Math.abs(dPk) / dt;

    if (dPk > 0) state.direction = "est";
    else if (dPk < 0) state.direction = "ouest";

    if (state.lastLat != null && state.lastLon != null) {
      const travel = distanceMeters(state.lastLat, state.lastLon, lat, lon);
      if (travel >= HEADING_MIN_DISTANCE_M) {
        const heading = computeBearing(state.lastLat, state.lastLon, lat, lon);
        if (Number.isFinite(heading)) {
          state.heading = heading;
        }
      }
    }

    const dirLabel = state.direction === "est" ? "vers Chessy / Boissy"
                    : state.direction === "ouest" ? "vers St-Germain / Paris"
                    : "";

    const distText = "ŒîPK " + Math.round(Math.abs(dPk)) +
      " m en " + Math.round(dt) + " s";

    if (speed < profile.idle) {
      movementTitle.textContent = "Quasi immobile";
      movementDetails.textContent = distText;
    } else if (speed < profile.walk) {
      movementTitle.textContent = "√Ä pied " + dirLabel;
      movementDetails.textContent = distText + " ¬∑ " + speed.toFixed(1) + " m/s";
    } else {
      movementTitle.textContent = "Train " + dirLabel;
      movementDetails.textContent = distText + " ¬∑ " + speed.toFixed(1) + " m/s";
    }
  }

  function updateNearestStation(pk, nearest) {
    if (!nearest || pk == null) {
      nearestStationName.textContent = "‚Äî";
      nearestStationInfo.textContent = "";
      return;
    }
    nearestStationName.textContent = nearest.name;
    const delta = Math.round(Math.abs(nearest.pk - pk));
    
    // D√©terminer la branche de la station pour l'affichage correct du PK relatif
    let stationBranch = null;
    if (nearest.pk != null) {
      if (nearest.pk <= BRANCH_COMMON_MAX) {
        stationBranch = "central";
      } else if (nearest.pk >= BRANCH_CHESSY_MIN && nearest.pk <= BRANCH_CHESSY_MAX) {
        stationBranch = "chessy";
      } else if (nearest.pk >= BRANCH_BOISSY_MIN && nearest.pk <= BRANCH_BOISSY_MAX) {
        stationBranch = "boissy";
      }
    }
    
    nearestStationInfo.textContent =
      "PK " + formatPk(nearest.pk, stationBranch) + " ¬∑ ŒîPK ‚âà " + delta + " m";
  }

  function updateNextStation(pk) {
    if (pk == null) {
      nextStationName.textContent = "‚Äî";
      nextStationInfo.textContent = "";
      return;
    }
    const next = findNextStation(pk, state.direction, currentBranch);
    if (!next) {
      nextStationName.textContent = "‚Äî";
      nextStationInfo.textContent = "";
      return;
    }
    nextStationName.textContent = next.name;
    const delta = Math.round(Math.abs(next.pk - pk));
    
    // D√©terminer la direction de mani√®re plus pr√©cise selon la branche
    let dir;
    if (next.pk >= pk) {
      // On va vers l'est
      if (pk >= BRANCH_CHESSY_MIN || (currentBranch === "chessy" && pk > BRANCH_COMMON_MAX)) {
        dir = "vers Chessy";
      } else if (pk >= BRANCH_BOISSY_MIN || (currentBranch === "boissy" && pk > BRANCH_COMMON_MAX)) {
        dir = "vers Boissy";
      } else {
        dir = "vers Chessy / Boissy";
      }
    } else {
      // On va vers l'ouest
      dir = "vers St-Germain / Paris";
    }
    
    nextStationInfo.textContent =
      "PK " + formatPk(next.pk) + " ¬∑ ‚âà " + delta + " m " + dir;
  }

  function updateNearestAccess(pk) {
    if (!nearestAccessName || !nearestAccessInfo) return;
    
    if (pk == null || !state.nearestAccess) {
      nearestAccessName.textContent = "‚Äî";
      nearestAccessInfo.textContent = "";
      return;
    }
    
    const access = state.nearestAccess;
    nearestAccessName.textContent = access.name;
    const delta = Math.round(Math.abs(access.pk - pk));
    nearestAccessInfo.textContent =
      "PK " + formatPk(access.pk) + " ¬∑ ŒîPK ‚âà " + delta + " m";
  }
 function updatePkTargetView() {
  if (!pkTarget) {
    if (pkTargetInfo) {
      pkTargetInfo.textContent = "Aucun PK cible d√©fini pour le moment.";
    }
    return;
  }

  if (state.lastPk == null) {
    if (pkTargetInfo) pkTargetInfo.textContent = "En attente de position GPS‚Ä¶";
    return;
  }
  const delta = pkTarget - state.lastPk;
  const dist = Math.round(Math.abs(delta));
  const dir = delta >= 0 ? "vers Chessy / Boissy" : "vers St-Germain / Paris";
  if (pkTargetInfo) {
    const branchLabel = getBranchLabel(pkTargetBranch || currentBranch);
    pkTargetInfo.textContent = "PK " + formatPk(pkTarget) + " ¬∑ ‚âà " + dist + " m " + dir + " ¬∑ " + branchLabel;
  }
}
  // Variables globales pour la carte Leaflet
  let orientationMap = null;
  let pkActuelMarker = null;
  let gareMarker = null;
  let accesMarkers = [];
  let directionMarker = null;
  let pkTargetMarker = null; // Marqueur du PK cible
  let allGareMarkers = []; // Tous les marqueurs de gares
  let allAccesMarkers = []; // Tous les marqueurs d'acc√®s
  let coverageSamMarkers = []; // Marqueurs SAM (feux rouges)
  let coveragePetardMarkers = []; // Marqueurs p√©tards (carr√©s verts)
  let coverageLegendEntries = [];
  let currentNearestStationData = null;
  let currentNearestAccessesData = [];
  let currentNearestAccessMarkers = [];
  let manualMapFocusUntil = 0;

  // Initialisation de la carte Leaflet
  function initOrientationMap() {
    const mapElement = document.getElementById("orientationMap");
    if (!mapElement || orientationMap) return;

    // Cr√©er la carte avec un th√®me sombre (CartoDB Dark Matter)
    orientationMap = L.map("orientationMap", {
      zoomControl: true,
      attributionControl: true,
    });

    // Ajouter une couche de tuiles sombre (CartoDB Dark Matter)
    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: "abcd",
      maxZoom: 19,
    }).addTo(orientationMap);

    // Centrer la carte sur Paris (RER A)
    orientationMap.setView([48.85, 2.35], 12);

    // √âcouter les √©v√©nements de zoom et de d√©placement pour mettre √† jour les marqueurs
    orientationMap.on("zoomend moveend", updateVisibleMarkers);
  }

  // Fonction pour mettre √† jour les marqueurs visibles selon la zone et le zoom
  function updateVisibleMarkers() {
    if (!orientationMap) return;

    const bounds = orientationMap.getBounds();
    const zoom = orientationMap.getZoom();

    // Seuil de zoom pour afficher les gares et acc√®s
    // Zoom < 13 : afficher seulement les gares principales
    // Zoom >= 13 : afficher toutes les gares et acc√®s dans la zone visible
    const minZoomForGares = 12;
    const minZoomForAcces = 13;

    // Filtrer et afficher les gares dans la zone visible
    if (allGareMarkers && Array.isArray(allGareMarkers)) {
      allGareMarkers.forEach(marker => {
        if (!marker) return;
        try {
          const latlng = marker.getLatLng();
          const isVisible = bounds.contains(latlng);
          const shouldShow = zoom >= minZoomForGares && isVisible;
          
          if (shouldShow && !orientationMap.hasLayer(marker)) {
            orientationMap.addLayer(marker);
          } else if (!shouldShow && orientationMap.hasLayer(marker)) {
            orientationMap.removeLayer(marker);
          }
        } catch (e) {
          console.warn("Erreur lors de la mise √† jour du marqueur de gare :", e);
        }
      });
    }

    // Filtrer et afficher les acc√®s dans la zone visible
    if (allAccesMarkers && Array.isArray(allAccesMarkers)) {
      allAccesMarkers.forEach(marker => {
        if (!marker) return;
        try {
          const latlng = marker.getLatLng();
          const isVisible = bounds.contains(latlng);
          const shouldShow = zoom >= minZoomForAcces && isVisible;
          
          if (shouldShow && !orientationMap.hasLayer(marker)) {
            orientationMap.addLayer(marker);
          } else if (!shouldShow && orientationMap.hasLayer(marker)) {
            orientationMap.removeLayer(marker);
          }
        } catch (e) {
          console.warn("Erreur lors de la mise √† jour du marqueur d'acc√®s :", e);
        }
      });
    }
  }

  // Fonction principale pour mettre √† jour la carte du plan
    function updateOrientationPanel() {
    const card = document.getElementById("orientationCard");
    const pkValue = document.getElementById("orientPkValue");
    const dirValue = document.getElementById("orientDirValue");
    const gareValue = document.getElementById("orientGareValue");
    const accessValue = document.getElementById("orientAccessValue");
    const infoPanel = document.getElementById("orientationInfoPanel");

    if (!card || !pkValue || !dirValue || !gareValue || !accessValue || !infoPanel) return;

    const panel = card.closest(".tab-panel");
    if (panel && !panel.classList.contains("is-active")) {
      return;
    }

    // Initialiser la carte si n√©cessaire
    if (!orientationMap) {
      initOrientationMap();
    }

  // Pas encore de GPS
    if (state.lastPk == null || state.lastLat == null || state.lastLon == null) {
      pkValue.textContent = "‚Äî";
      dirValue.textContent = "En attente de position‚Ä¶";
      gareValue.textContent = "‚Äî";
      accessValue.textContent = "‚Äî";
      infoPanel.style.display = "none";
      card.classList.remove("is-live");
    return;
  }

    // Afficher le panneau d'information
    infoPanel.style.display = "block";
    card.classList.add("is-live");

    // Coordonn√©es GPS actuelles
    const currentLat = state.lastLat;
    const currentLon = state.lastLon;

  // PK actuel + cible
    let txtPk = formatPk(state.lastPk);
  if (pkTarget) {
    txtPk += " ¬∑ cible " + formatPk(pkTarget);
  }
    pkValue.textContent = txtPk;

  // Sens
  let dirLabel = "ind√©termin√©";
    let directionAngle = null; // Angle en degr√©s pour la fl√®che (0 = Nord, 90 = Est, etc.)
    
  if (state.direction === "est") {
    dirLabel = "vers Chessy / Boissy";
      directionAngle = 90; // Est
  } else if (state.direction === "ouest") {
    dirLabel = "vers St-Germain / Paris";
      directionAngle = 270; // Ouest
  }

  if (pkTarget && state.lastPk != null) {
    const delta = pkTarget - state.lastPk;
      if (delta > 0) {
        dirLabel = "vers le PK cible (Chessy / Boissy)";
        directionAngle = 90;
      } else if (delta < 0) {
        dirLabel = "vers le PK cible (St-Germain / Paris)";
        directionAngle = 270;
      }
    }
    dirValue.textContent = dirLabel;
  // Gare la plus proche
    if (state.nearestStation && state.nearestStation.lat != null && state.nearestStation.lon != null) {
      currentNearestStationData = state.nearestStation;
      // D√©terminer la branche de la station pour l'affichage correct du PK relatif
      let stationBranch = null;
      if (state.nearestStation.pk != null) {
        if (state.nearestStation.pk <= BRANCH_COMMON_MAX) {
          stationBranch = "central";
        } else if (state.nearestStation.pk >= BRANCH_CHESSY_MIN && state.nearestStation.pk <= BRANCH_CHESSY_MAX) {
          stationBranch = "chessy";
        } else if (state.nearestStation.pk >= BRANCH_BOISSY_MIN && state.nearestStation.pk <= BRANCH_BOISSY_MAX) {
          stationBranch = "boissy";
        }
      }
      gareValue.textContent = state.nearestStation.name + " (PK " + formatPk(state.nearestStation.pk, stationBranch) + ")";
      gareValue.classList.add("is-clickable");
      gareValue.setAttribute("data-orient-action", "station");
      gareValue.setAttribute("role", "button");
      gareValue.setAttribute("tabindex", "0");
    } else if (state.nearestStation) {
      currentNearestStationData = state.nearestStation;
      // D√©terminer la branche de la station pour l'affichage correct du PK relatif
      let stationBranch = null;
      if (state.nearestStation.pk != null) {
        if (state.nearestStation.pk <= BRANCH_COMMON_MAX) {
          stationBranch = "central";
        } else if (state.nearestStation.pk >= BRANCH_CHESSY_MIN && state.nearestStation.pk <= BRANCH_CHESSY_MAX) {
          stationBranch = "chessy";
        } else if (state.nearestStation.pk >= BRANCH_BOISSY_MIN && state.nearestStation.pk <= BRANCH_BOISSY_MAX) {
          stationBranch = "boissy";
        }
      }
      gareValue.textContent = state.nearestStation.name + " (PK " + formatPk(state.nearestStation.pk, stationBranch) + ")";
      gareValue.classList.remove("is-clickable");
      gareValue.removeAttribute("data-orient-action");
      gareValue.removeAttribute("role");
      gareValue.removeAttribute("tabindex");
  } else {
      currentNearestStationData = null;
      gareValue.textContent = "‚Äî";
      gareValue.classList.remove("is-clickable");
      gareValue.removeAttribute("data-orient-action");
      gareValue.removeAttribute("role");
      gareValue.removeAttribute("tabindex");
  }

  // 2 acc√®s les plus proches autour de moi
  const list = getNearestAccessesGeo(state.lastLat, state.lastLon, state.lastPk, 2);
    currentNearestAccessesData = Array.isArray(list) ? list : [];
    state.nearestAccess = currentNearestAccessesData.length ? currentNearestAccessesData[0].acc : null;
    currentNearestAccessMarkers = [];

    if (currentNearestAccessesData.length) {
      accessValue.textContent = "";
      currentNearestAccessesData.forEach((item, index) => {
        const acc = item.acc;
        const label = acc.name + " (PK " + formatPk(acc.pk) + ")";
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "orient-access-chip";
        chip.setAttribute("data-access-index", String(index));
        chip.textContent = label;
        accessValue.appendChild(chip);
        if (index < currentNearestAccessesData.length - 1) {
          accessValue.appendChild(document.createElement("br"));
        }
      });
  } else {
      accessValue.textContent = "‚Äî";
    }

    // Centrer la carte sur la position actuelle
    orientationMap.setView([currentLat, currentLon], 15);

    // Supprimer les anciens marqueurs dynamiques (PK actuel, gare la plus proche, direction, PK cible)
    if (pkActuelMarker) {
      orientationMap.removeLayer(pkActuelMarker);
    }
    if (gareMarker) {
      orientationMap.removeLayer(gareMarker);
    }
    accesMarkers.forEach(marker => {
      orientationMap.removeLayer(marker);
    });
    accesMarkers = [];
    currentNearestAccessMarkers = [];
    if (directionMarker) {
      orientationMap.removeLayer(directionMarker);
    }
    if (pkTargetMarker) {
      orientationMap.removeLayer(pkTargetMarker);
      pkTargetMarker = null;
    }
    // Note: Les marqueurs de couverture (SAM et p√©tards) ne sont pas supprim√©s ici
    // Ils restent visibles jusqu'√† ce que l'utilisateur clique sur "Effacer les marqueurs"

    // Cr√©er tous les marqueurs de gares une seule fois (si pas d√©j√† cr√©√©s)
    if (allGareMarkers.length === 0) {
      const allStations = troncCommun.concat(brancheBoissy, brancheChessy);
      allStations.forEach(station => {
        if (station.lat && station.lon) {
          const gareIcon = L.divIcon({
            className: "leaflet-marker-gare",
            html: "üöâ",
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });
          const stationMarker = L.marker([station.lat, station.lon], {
            icon: gareIcon,
            zIndexOffset: 900,
          });
          stationMarker.bindPopup(
            "Gare : " + station.name + "<br>PK : " + formatPk(station.pk)
          );
          allGareMarkers.push(stationMarker);
        }
      });
    }

    // Cr√©er tous les marqueurs d'acc√®s une seule fois (si pas d√©j√† cr√©√©s)
    if (allAccesMarkers.length === 0) {
      accessPoints.forEach(access => {
        if (access.lat && access.lon) {
          const accesIcon = L.divIcon({
            className: "leaflet-marker-acces",
            html: "üö™",
            iconSize: [18, 18],
            iconAnchor: [9, 9],
          });
          const accessMarker = L.marker([access.lat, access.lon], {
            icon: accesIcon,
            zIndexOffset: 800,
          });
          accessMarker.bindPopup(
            "Acc√®s : " + access.name + "<br>PK : " + (access.pk ? formatPk(access.pk) : "‚Äî")
          );
          allAccesMarkers.push(accessMarker);
        }
      });
    }

    // Ajouter le marqueur PK actuel (point central) - toujours visible
    const pkActuelIcon = L.divIcon({
      className: "leaflet-marker-pk-actuel",
      html: "",
      iconSize: [20, 20],
      iconAnchor: [10, 10],
    });
    pkActuelMarker = L.marker([currentLat, currentLon], {
      icon: pkActuelIcon,
      zIndexOffset: 1000,
    }).addTo(orientationMap);
    pkActuelMarker.bindPopup("PK actuel : " + formatPk(state.lastPk));

    // Ajouter le marqueur de la gare la plus proche (toujours visible)
    if (state.nearestStation && state.nearestStation.lat && state.nearestStation.lon) {
      const gareIcon = L.divIcon({
        className: "leaflet-marker-gare",
        html: "üöâ",
        iconSize: [24, 24],
        iconAnchor: [12, 12],
      });
      gareMarker = L.marker([state.nearestStation.lat, state.nearestStation.lon], {
        icon: gareIcon,
        zIndexOffset: 950,
      }).addTo(orientationMap);
      // D√©terminer la branche de la station pour l'affichage correct du PK relatif
      let stationBranch = null;
      if (state.nearestStation.pk != null) {
        if (state.nearestStation.pk <= BRANCH_COMMON_MAX) {
          stationBranch = "central";
        } else if (state.nearestStation.pk >= BRANCH_CHESSY_MIN && state.nearestStation.pk <= BRANCH_CHESSY_MAX) {
          stationBranch = "chessy";
        } else if (state.nearestStation.pk >= BRANCH_BOISSY_MIN && state.nearestStation.pk <= BRANCH_BOISSY_MAX) {
          stationBranch = "boissy";
        }
      }
      gareMarker.bindPopup(
        "Gare la plus proche : " + state.nearestStation.name + "<br>PK : " + formatPk(state.nearestStation.pk, stationBranch)
      );
    }

    if (currentNearestAccessesData.length) {
      currentNearestAccessesData.forEach((item, index) => {
      const acc = item.acc;
        if (!acc || acc.lat == null || acc.lon == null) {
          currentNearestAccessMarkers[index] = null;
          return;
        }
        const accesIcon = L.divIcon({
          className: "leaflet-marker-acces",
          html: "üö™",
          iconSize: [18, 18],
          iconAnchor: [9, 9],
        });
        const marker = L.marker([acc.lat, acc.lon], {
          icon: accesIcon,
          zIndexOffset: 920,
        }).addTo(orientationMap);
        marker.bindPopup(
          "Acc√®s : " + acc.name +
          (acc.pk != null ? "<br>PK : " + formatPk(acc.pk) : "") +
          (acc.address ? "<br>" + acc.address : "") +
          createNavigationButtonsHTML(acc.lat, acc.lon, { compact: true })
        );
        accesMarkers.push(marker);
        currentNearestAccessMarkers[index] = marker;
      });
    }

    // Mettre √† jour les marqueurs visibles selon la zone et le zoom
    updateVisibleMarkers();

    // Ajouter la fl√®che de direction qui avance en temps r√©el
    const arrowHeading = Number.isFinite(state.heading)
      ? state.heading
      : (Number.isFinite(directionAngle) ? directionAngle : null);

    if (Number.isFinite(arrowHeading)) {
      const forwardPoint = projectForward(currentLat, currentLon, ARROW_DISTANCE_METERS, arrowHeading);
      const arrowHtml = '<div class="direction-arrow direction-arrow-moving" style="--arrow-rotation: ' + arrowHeading + 'deg;"></div>';
      const directionIcon = L.divIcon({
        className: "leaflet-marker-direction",
        html: arrowHtml,
        iconSize: [44, 44],
        iconAnchor: [22, 22],
      });
      directionMarker = L.marker([forwardPoint.lat, forwardPoint.lon], {
        icon: directionIcon,
        zIndexOffset: 1100,
      }).addTo(orientationMap);
      const popupLabel = dirLabel && dirLabel.trim().length ? dirLabel : "Direction";
      directionMarker.bindPopup("Sens : " + popupLabel + "<br>Position : " + formatPk(state.lastPk));
    } else {
      const arrowHtml = '<div class="direction-arrow direction-arrow-indetermine" style="--arrow-rotation: 0deg;"></div>';
      const directionIcon = L.divIcon({
        className: "leaflet-marker-direction",
        html: arrowHtml,
        iconSize: [44, 44],
        iconAnchor: [22, 22],
      });
      const fallbackPoint = {
        lat: currentLat + 0.0003,
        lon: currentLon
      };
      directionMarker = L.marker([fallbackPoint.lat, fallbackPoint.lon], {
        icon: directionIcon,
        zIndexOffset: 1100,
      }).addTo(orientationMap);
      directionMarker.bindPopup("Sens : ind√©termin√©");
    }

    // Ajouter le marqueur du PK cible (croix rouge) si d√©fini
    if (pkTarget) {
      const targetGps = getGpsFromPk(pkTarget);
      if (targetGps && targetGps.lat && targetGps.lon) {
        const pkTargetIcon = L.divIcon({
          className: "leaflet-marker-pk-target",
          html: "",
          iconSize: [30, 30],
          iconAnchor: [15, 15],
        });
        pkTargetMarker = L.marker([targetGps.lat, targetGps.lon], {
          icon: pkTargetIcon,
          zIndexOffset: 1050,
        }).addTo(orientationMap);
        pkTargetMarker.bindPopup("PK cible : " + formatPk(pkTarget));
      }
    }

    // Ajuster la vue pour inclure tous les marqueurs
    const group = new L.featureGroup([pkActuelMarker]);
    if (gareMarker) group.addLayer(gareMarker);
    accesMarkers.forEach(marker => group.addLayer(marker));
    if (directionMarker) group.addLayer(directionMarker);
    if (pkTargetMarker) group.addLayer(pkTargetMarker);
    coverageSamMarkers.forEach(marker => group.addLayer(marker));
    coveragePetardMarkers.forEach(marker => group.addLayer(marker));

    if (orientationMap && group.getLayers().length) {
      const nowTs = Date.now();
      if (manualMapFocusUntil && nowTs >= manualMapFocusUntil) {
        manualMapFocusUntil = 0;
      }
      if (manualMapFocusUntil === 0) {
        orientationMap.fitBounds(group.getBounds().pad(0.1), {
          maxZoom: 16,
        });
      }
    }
  }

  // Fonction updateOrientation pour rafra√Æchir la carte du plan (bonus)
  function updateOrientation(pk, sens) {
    // Cette fonction peut √™tre appel√©e manuellement pour rafra√Æchir la carte
    // Elle utilise les valeurs actuelles de state
    updateOrientationPanel();
  }

  function updateSmsPreview() {
    if (!smsPreview) return;
    if (state.lastPk == null || state.lastLat == null) {
      smsPreview.textContent =
        "En attente de position GPS pour pr√©parer le SMS.";
      return;
    }
    const pkText = "PK " + formatPk(state.lastPk);
    const nearestName = state.nearestStation ? state.nearestStation.name : "inconnue";
    const branchLabel = currentBranch === "boissy" ? "branche Boissy-Saint-L√©ger"
                     : currentBranch === "chessy" ? "branche Marne-la-Vall√©e ‚Äì Chessy"
                     : currentBranch === "central" || currentBranch === "both" ? "tron√ßon central"
                     : "branche inconnue";
    let base =
      pkText + " (" + branchLabel + "), gare la plus proche : " + nearestName +
      ", lat " + state.lastLat.toFixed(5) +
      ", lon " + state.lastLon.toFixed(5) + ".";

    if (state.nearestAccess) {
      base += " Acc√®s le plus proche : " + state.nearestAccess.name +
        " (" + state.nearestAccess.address + ").";
    }

    const numPart = " Num√©ro utilis√© : " +
      (sosPhone ? sosPhone : "aucun (√† d√©finir dans Param√®tres).");
    smsPreview.textContent = base + numPart;
  }
  function sendSms() {
    if (state.lastPk == null || state.lastLat == null) {
      alert("Position GPS insuffisante pour pr√©parer le SMS.");
      return;
    }
    const pkText = "PK " + formatPk(state.lastPk);
    const nearestName = state.nearestStation ? state.nearestStation.name : "inconnue";
    const branchLabel = currentBranch === "boissy" ? "branche Boissy-Saint-L√©ger"
                     : currentBranch === "chessy" ? "branche Marne-la-Vall√©e ‚Äì Chessy"
                     : "branche inconnue";
    let message =
      "J'ai eu un accident, je suis bless√©, venez me secourir.\n\n" +
      "PK : " + pkText + " (" + branchLabel + ")\n" +
      "Gare la plus proche : " + nearestName + "\n";

    if (state.nearestAccess) {
      message +=
        "Acc√®s le plus proche : " + state.nearestAccess.name +
        " (" + state.nearestAccess.address + ")\n";
    }

    message +=
      "Coordonn√©es : " + state.lastLat.toFixed(5) + ", " + state.lastLon.toFixed(5) + "\n";

    const body = encodeURIComponent(message);
    const numberPart = sosPhone ? encodeURIComponent(sosPhone) : "";
    const url = numberPart
      ? "sms:" + numberPart + "?&body=" + body
      : "sms:?&body=" + body;

    window.location.href = url;
  }
  // === MODE COUVREUR CHEMINANT SEUL ===
  // Fonction pour ouvrir automatiquement l'application SMS avec le message pr√©-rempli
  // Note : Pour un envoi vraiment automatique sans action, il faudrait un backend/service SMS
  // Cette solution ouvre l'app SMS automatiquement, mais n√©cessite un appui sur "Envoyer"
  function sendSmsAuto() {
    if (state.lastPk == null || state.lastLat == null) {
      console.warn("Impossible d'envoyer le SMS automatique : position GPS insuffisante.");
      return;
    }
    
    if (!sosPhone) {
      console.warn("Impossible d'envoyer le SMS automatique : num√©ro SOS non configur√©.");
      if (couvreurStatus) {
        couvreurStatus.textContent = '‚ö†Ô∏è Num√©ro SOS non configur√©';
        couvreurStatus.style.color = '#f44336';
      }
      return;
    }
    
    const pkText = "PK " + formatPk(state.lastPk);
    const nearestName = state.nearestStation ? state.nearestStation.name : "inconnue";
    const branchLabel = currentBranch === "boissy" ? "branche Boissy-Saint-L√©ger"
                     : currentBranch === "chessy" ? "branche Marne-la-Vall√©e ‚Äì Chessy"
                     : "branche inconnue";
    let message =
      "J'ai eu un accident, je suis bless√©, venez me secourir.\n\n" +
      "PK : " + pkText + " (" + branchLabel + ")\n" +
      "Gare la plus proche : " + nearestName + "\n";

    if (state.nearestAccess) {
      message +=
        "Acc√®s le plus proche : " + state.nearestAccess.name +
        " (" + state.nearestAccess.address + ")\n";
    }

    message +=
      "Coordonn√©es : " + state.lastLat.toFixed(5) + ", " + state.lastLon.toFixed(5) + "\n";

    // Ouvrir automatiquement l'application SMS avec le message pr√©-rempli
    // L'utilisateur devra appuyer sur "Envoyer" (ou quelqu'un d'autre peut le faire)
    const body = encodeURIComponent(message);
    const url = "sms:" + encodeURIComponent(sosPhone) + "?&body=" + body;
    window.location.href = url;
    
    // D√©marrer le timer pour mesurer le temps avant envoi du SMS
    startSmsTimer();
    
    // Mettre √† jour le statut
    if (couvreurStatus) {
      couvreurStatus.textContent = '‚ö†Ô∏è Application SMS ouverte - Appuyez sur "Envoyer"';
      couvreurStatus.style.color = '#ff9800';
    }
  }

  // Fonction pour mettre √† jour l'affichage du timer SMS
  function updateSmsTimerDisplay() {
    if (!smsTimerStartTime || smsSent) return;
    
    // Utiliser Date.now() pour calculer le temps √©coul√© r√©el, m√™me si les timers sont suspendus
    const now = Date.now();
    const elapsed = now - smsTimerStartTime;
    const seconds = Math.floor(elapsed / 1000);
    
    // D√©marrer l'alarme d√®s l'ouverture du SMS si pas d√©j√† active
    if (!alarmOscillator && !alarmActive) {
      startAlarm();
    }
    
    // Mettre √† jour le statut avec le temps √©coul√©
    if (couvreurStatus) {
      couvreurStatus.textContent =
        `üö® SONNERIE ACTIVE - ${seconds}s √©coul√©es depuis l'ouverture du SMS - Envoyez le SMS pour arr√™ter`;
      couvreurStatus.style.color = '#f44336';
    }
  }

  function startSmsTimer() {
    smsTimerStartTime = Date.now();
    smsTimerEndTime = null;
    smsSent = false;
    
    // Mettre √† jour l'affichage du timer toutes les secondes
    if (smsTimerInterval) {
      clearInterval(smsTimerInterval);
    }
    
    // Variables pour d√©tecter le retour de l'utilisateur
    let lastBlurTime = Date.now();
    let blurListener = null;
    let focusListener = null;
    let visibilityListener = null;
    
    // √âcouter le blur (quand l'utilisateur quitte la page)
    blurListener = () => {
      lastBlurTime = Date.now();
    };
    window.addEventListener('blur', blurListener);
    
    // √âcouter le focus (quand l'utilisateur revient sur la page)
    focusListener = () => {
      // Si l'utilisateur revient apr√®s avoir √©t√© absent, on peut supposer qu'il a envoy√© le SMS
      const timeAway = Date.now() - lastBlurTime;
      if (timeAway > 3000 && !smsSent) { // S'il a √©t√© absent plus de 3 secondes et le SMS n'a pas encore √©t√© marqu√© comme envoy√©
        markSmsAsSent();
        // Nettoyer les listeners
        if (blurListener) window.removeEventListener('blur', blurListener);
        if (focusListener) window.removeEventListener('focus', focusListener);
        if (visibilityListener) document.removeEventListener('visibilitychange', visibilityListener);
      } else {
        // Mettre √† jour imm√©diatement l'affichage quand on revient au premier plan
        updateSmsTimerDisplay();
        // Reprendre l'audio context si n√©cessaire
        if (alarmOscillator && audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(err => console.error('Erreur reprise AudioContext:', err));
        }
      }
    };
    window.addEventListener('focus', focusListener);
    
    // √âcouter les changements de visibilit√© (Page Visibility API) pour g√©rer les cas o√π la page passe en arri√®re-plan
    visibilityListener = () => {
      if (!document.hidden) {
        // La page revient au premier plan : mettre √† jour imm√©diatement l'affichage
        updateSmsTimerDisplay();
        // Reprendre l'audio context et l'alarme si n√©cessaire
        if (alarmActive && audioContext) {
          if (audioContext.state === 'suspended') {
            audioContext.resume().catch(err => console.error('Erreur reprise AudioContext:', err));
          }
          // S'assurer que l'oscillateur continue de fonctionner
          if (alarmActive) {
            maintainAlarmOscillator();
          }
        }
      }
    };
    document.addEventListener('visibilitychange', visibilityListener);
    
    // Mettre √† jour imm√©diatement
    updateSmsTimerDisplay();
    
    // Mettre √† jour toutes les secondes (m√™me si suspendu en arri√®re-plan, le calcul sera correct au retour)
    smsTimerInterval = setInterval(() => {
      updateSmsTimerDisplay();
    }, 1000); // Mise √† jour toutes les secondes
  }
  // Fonction pour marquer le SMS comme envoy√© et arr√™ter le timer
  function markSmsAsSent() {
    if (smsSent) return; // D√©j√† marqu√© comme envoy√©
    
    smsSent = true;
    smsTimerEndTime = Date.now();
    
    // Arr√™ter le timer et la sonnerie
    stopSmsTimer();
    stopAlarm();
    
    // Calculer le temps total qu'il a fallu pour envoyer le SMS
    const totalTime = smsTimerEndTime - smsTimerStartTime;
    const totalSeconds = Math.floor(totalTime / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    
    // Afficher l'information et la garder affich√©e
    if (couvreurStatus) {
      let timeText = '';
      if (minutes > 0) {
        timeText = `${minutes} min ${seconds} s`;
      } else {
        timeText = `${seconds} s`;
      }
      couvreurStatus.textContent = `‚úÖ SMS envoy√© en ${timeText} - Mode d√©sactiv√©`;
      couvreurStatus.style.color = '#4caf50';
    }
    
    // D√©sactiver le mode couvreur apr√®s un court d√©lai
    setTimeout(() => {
      stopCouvreurSeul();
    }, 5000); // Garder l'info affich√©e pendant 5 secondes avant de d√©sactiver
  }

  // Fonction pour arr√™ter le timer SMS
  function stopSmsTimer() {
    if (smsTimerInterval) {
      clearInterval(smsTimerInterval);
      smsTimerInterval = null;
    }
    // Ne pas r√©initialiser smsTimerStartTime et smsTimerEndTime pour garder l'information
  }
  // Fonction pour maintenir l'oscillateur actif (sonnerie continue)
  function maintainAlarmOscillator() {
    if (!alarmActive || !audioContext) return;
    
    try {
      // Reprendre l'audio context s'il est suspendu
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(err => console.error('Erreur reprise AudioContext:', err));
      }
      
      // Si l'oscillateur existe et que l'audio context est actif, v√©rifier qu'il fonctionne toujours
      // Note: les oscillateurs Web Audio continuent ind√©finiment jusqu'√† stop(), donc on ne recr√©e que si n√©cessaire
      if (alarmOscillator && audioContext.state === 'running') {
        // L'oscillateur existe et l'audio context est actif, il devrait continuer
        // On ne fait rien sauf si on d√©tecte un probl√®me
        return;
      }
      
      // Arr√™ter l'oscillateur pr√©c√©dent s'il existe
      if (alarmOscillator) {
        try {
          alarmOscillator.stop();
          alarmOscillator.disconnect();
        } catch (e) {
          // Ignorer les erreurs
        }
        alarmOscillator = null;
      }
      
      // Cr√©er un nouvel oscillateur pour une sonnerie continue
      alarmOscillator = audioContext.createOscillator();
      alarmGainNode = audioContext.createGain();
      
      // Configurer l'oscillateur (son aigu et fort)
      alarmOscillator.type = 'sine';
      const currentTime = audioContext.currentTime;
      
      // Faire varier la fr√©quence pour un son plus per√ßant (bip-bip continu)
      alarmOscillator.frequency.setValueAtTime(ALARM_FREQUENCY, currentTime);
      
      // Volume maximum (1.0 = 100%)
      alarmGainNode.gain.setValueAtTime(1.0, currentTime);
      
      // Connecter les n≈ìuds
      alarmOscillator.connect(alarmGainNode);
      alarmGainNode.connect(audioContext.destination);
      
      // D√©marrer la sonnerie (continue, ne s'arr√™te jamais sauf si alarmActive devient false)
      alarmOscillator.start(currentTime);
      
      // Faire varier la fr√©quence p√©riodiquement pour un effet bip-bip continu
      let frequency = ALARM_FREQUENCY;
      const frequencyVariation = 200;
      
      if (smsAlarmInterval) {
        clearInterval(smsAlarmInterval);
      }
      
      smsAlarmInterval = setInterval(() => {
        if (alarmActive && alarmOscillator && audioContext) {
          // Reprendre l'audio context s'il est suspendu
          if (audioContext.state === 'suspended') {
            audioContext.resume().catch(err => console.error('Erreur reprise AudioContext dans interval:', err));
          }
          
          // Alterner entre deux fr√©quences pour un effet bip-bip continu
          frequency = frequency === ALARM_FREQUENCY 
            ? ALARM_FREQUENCY + frequencyVariation 
            : ALARM_FREQUENCY;
          try {
            alarmOscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
          } catch (e) {
            // Si l'oscillateur a √©t√© arr√™t√©, le recr√©er
            if (alarmActive) {
              maintainAlarmOscillator();
            }
          }
        }
      }, 500); // Changer de fr√©quence toutes les 500ms pour effet bip-bip
      
      // Vibration continue si disponible (pour mobile)
      if (navigator.vibrate) {
        // Vibration continue : 200ms ON, 100ms OFF, r√©p√©t√© ind√©finiment
        const vibratePattern = [200, 100];
        navigator.vibrate(vibratePattern);
        // Relancer la vibration p√©riodiquement car certains navigateurs l'arr√™tent
        setInterval(() => {
          if (alarmActive && navigator.vibrate) {
            navigator.vibrate(vibratePattern);
          }
        }, 2000);
      }
    } catch (error) {
      console.error('Erreur lors de la cr√©ation de l\'oscillateur:', error);
      // R√©essayer apr√®s un court d√©lai
      if (alarmActive) {
        setTimeout(() => maintainAlarmOscillator(), 100);
      }
    }
  }

  // Fonction pour demander la permission de notifications
  async function requestNotificationPermission() {
    if (!('Notification' in window)) {
      return false;
    }
    
    if (Notification.permission === 'granted') {
      notificationPermission = 'granted';
      return true;
    }
    
    if (Notification.permission !== 'denied') {
      try {
        const permission = await Notification.requestPermission();
        notificationPermission = permission;
        return permission === 'granted';
      } catch (error) {
        console.error('Erreur lors de la demande de permission:', error);
        return false;
      }
    }
    
    return false;
  }

  // Fonction pour envoyer une notification
  function sendAlarmNotification() {
    if (Notification.permission === 'granted' && alarmActive) {
      try {
        const notification = new Notification('üö® ALARME COUVREUR', {
          body: 'SMS ouvert depuis plus de 30 secondes - Envoyez le SMS pour arr√™ter',
          icon: 'üö®',
          tag: 'couvreur-alarm',
          requireInteraction: true, // N√©cessite une interaction pour fermer
          silent: false // Ne pas √™tre silencieux
        });
        
        // Fermer la notification apr√®s 5 secondes pour √©viter l'accumulation
        setTimeout(() => {
          notification.close();
        }, 5000);
      } catch (error) {
        console.error('Erreur lors de l\'envoi de la notification:', error);
      }
    }
  }

  // Fonction pour d√©marrer la sonnerie forte (continue, ne s'arr√™te jamais sauf si le mode couvreur est d√©sactiv√©)
  function startAlarm() {
    if (alarmActive) return; // D√©j√† active
    
    alarmActive = true;
    
    try {
      // Demander la permission de notifications
      requestNotificationPermission();
      
      // Cr√©er ou r√©utiliser le contexte audio
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      // Reprendre le contexte audio s'il est suspendu
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(err => console.error('Erreur reprise AudioContext:', err));
      }
      
      // Cr√©er l'oscillateur continu imm√©diatement
      maintainAlarmOscillator();
      
      // Envoyer une notification imm√©diatement
      sendAlarmNotification();
      
      // V√©rifier et reprendre l'audio context tr√®s fr√©quemment (toutes les 100ms)
      if (smsAlarmKeepAliveInterval) {
        clearInterval(smsAlarmKeepAliveInterval);
      }
      
      smsAlarmKeepAliveInterval = setInterval(() => {
        if (alarmActive && audioContext) {
          // Reprendre l'audio context s'il est suspendu
          if (audioContext.state === 'suspended') {
            audioContext.resume().catch(err => console.error('Erreur reprise AudioContext keep-alive:', err));
          }
          
          // V√©rifier que l'oscillateur fonctionne toujours, sinon le recr√©er
          if (!alarmOscillator || audioContext.state !== 'running') {
            maintainAlarmOscillator();
          }
          
          // Envoyer une notification p√©riodiquement (toutes les 5 secondes) pour alerter m√™me en arri√®re-plan
          if (Date.now() % 5000 < 100) { // Approximativement toutes les 5 secondes
            sendAlarmNotification();
          }
        }
      }, 100); // V√©rifier toutes les 100ms
      
      console.log('üö® Sonnerie d\'alarme d√©marr√©e (continue, ne s\'arr√™te jamais)');
    } catch (error) {
      console.error('Erreur lors du d√©marrage de la sonnerie:', error);
      // En cas d'erreur, essayer une m√©thode alternative (alerte visuelle)
      if (couvreurStatus) {
        couvreurStatus.style.animation = 'blink 0.5s infinite';
      }
      // R√©essayer apr√®s un court d√©lai
      if (alarmActive) {
        setTimeout(() => startAlarm(), 100);
      }
    }
  }
  // Fonction pour arr√™ter la sonnerie
  function stopAlarm() {
    alarmActive = false;
    
    if (alarmOscillator) {
      try {
        alarmOscillator.stop();
        alarmOscillator.disconnect();
        alarmOscillator = null;
      } catch (e) {
        console.warn('Erreur lors de l\'arr√™t de la sonnerie:', e);
      }
    }
    
    if (alarmGainNode) {
      try {
        alarmGainNode.disconnect();
        alarmGainNode = null;
      } catch (e) {
        // Ignorer les erreurs
      }
    }
    
    // Ne pas fermer l'audio context, juste le suspendre pour pouvoir le r√©utiliser
    if (audioContext && audioContext.state !== 'closed') {
      try {
        audioContext.suspend();
      } catch (e) {
        console.warn('Erreur lors de la suspension du contexte audio:', e);
      }
    }
    
    if (smsAlarmInterval) {
      clearInterval(smsAlarmInterval);
      smsAlarmInterval = null;
    }
    
    if (smsAlarmKeepAliveInterval) {
      clearInterval(smsAlarmKeepAliveInterval);
      smsAlarmKeepAliveInterval = null;
    }
    
    // Arr√™ter la vibration
    if (navigator.vibrate) {
      navigator.vibrate(0);
    }
    
    // Arr√™ter l'animation de clignotement
    if (couvreurStatus) {
      couvreurStatus.style.animation = '';
    }
    
    // Fermer toutes les notifications
    if ('Notification' in window) {
      // Les notifications se ferment automatiquement, mais on peut forcer
    }
    
    console.log('üîá Sonnerie d\'alarme arr√™t√©e');
  }
  // Fonction pour v√©rifier le mouvement et d√©clencher l'alerte si n√©cessaire
  function checkCouvreurMovement() {
    if (!couvreurSeulActive) return;
    
    if (state.lastLat == null || state.lastLon == null) {
      // Pas de position GPS, on ne peut pas v√©rifier
      return;
    }

    const now = Date.now();
    
    // Si on a une derni√®re position avec mouvement, v√©rifier la distance
    if (couvreurLastPosition != null) {
      const dist = distanceMeters(
        state.lastLat, state.lastLon,
        couvreurLastPosition.lat, couvreurLastPosition.lon
      );
      
      // Si on a boug√© de plus de 3m, mettre √† jour la derni√®re position avec mouvement
      if (dist > COUVREUR_NO_MOVEMENT_THRESHOLD) {
        couvreurLastPosition = {
          lat: state.lastLat,
          lon: state.lastLon,
          time: now
        };
        couvreurLastMovementTime = now;
        updateCouvreurStatus();
        return;
      }
    } else {
      // Premi√®re position : initialiser
      couvreurLastPosition = {
        lat: state.lastLat,
        lon: state.lastLon,
        time: now
      };
      couvreurLastMovementTime = now;
      updateCouvreurStatus();
      return;
    }

    // Si on est ici, on n'a pas boug√© de plus de 3m
    // V√©rifier si on est rest√© immobile pendant 1 minute
    if (couvreurLastMovementTime != null) {
      const timeSinceLastMovement = now - couvreurLastMovementTime;
      if (timeSinceLastMovement >= COUVREUR_ALERT_DELAY) {
        // 1 minute sans mouvement : d√©clencher le SMS auto une seule fois
        if (!smsTimerStartTime && !smsSent) {
          console.log("Alerte couvreur cheminant seul : pas de mouvement depuis 1 minute, envoi du SMS automatique.");
          sendSmsAuto(); // ouvre l'app SMS + d√©marre le timer
        }
        // NE PAS d√©sactiver le mode ici : on attend l'envoi du SMS (markSmsAsSent)
      } else {
        // Mettre √† jour le statut avec le temps restant avant d√©clenchement
        updateCouvreurStatus();
      }
    }
  }
  // Fonction pour mettre √† jour l'affichage du statut
  function updateCouvreurStatus() {
    if (!couvreurStatus) return;
    
    if (!couvreurSeulActive) {
      couvreurStatus.style.display = "none";
      return;
    }

    // Si le timer SMS est actif, ne pas √©craser son affichage
    if (smsTimerStartTime && !smsSent) {
      // Le timer SMS g√®re son propre affichage
      return;
    }

    couvreurStatus.style.display = "block";
    
    if (couvreurLastMovementTime == null) {
      couvreurStatus.textContent = "Mode actif : en attente de position GPS...";
      return;
    }

    const now = Date.now();
    const timeSinceLastMovement = now - couvreurLastMovementTime;
    const timeRemaining = COUVREUR_ALERT_DELAY - timeSinceLastMovement;
    
    if (timeRemaining <= 0) {
      couvreurStatus.textContent = "‚ö†Ô∏è Alerte : envoi du SMS en cours...";
    } else {
      const minutes = Math.floor(timeRemaining / 60000);
      const seconds = Math.floor((timeRemaining % 60000) / 1000);
      couvreurStatus.textContent = `Mode actif : ${minutes} min ${seconds} s avant alerte automatique`;
    }
  }
  // Fonction pour d√©marrer le mode "couvreur cheminant seul"
  function startCouvreurSeul() {
    if (!geolocActive) {
      alert("‚ö†Ô∏è Active d'abord la g√©olocalisation pour utiliser le mode 'Couvreur cheminant seul'.");
      return;
    }
    
    couvreurSeulActive = true;
    couvreurLastMovementTime = Date.now();
    couvreurLastPosition = state.lastLat != null && state.lastLon != null ? {
      lat: state.lastLat,
      lon: state.lastLon,
      time: Date.now()
    } : null;
    
    // D√©marrer la v√©rification p√©riodique
    if (couvreurCheckInterval) {
      clearInterval(couvreurCheckInterval);
    }
    couvreurCheckInterval = setInterval(checkCouvreurMovement, COUVREUR_CHECK_INTERVAL);
    
    // D√©marrer la mise √† jour du statut toutes les secondes
    if (couvreurStatusInterval) {
      clearInterval(couvreurStatusInterval);
    }
    couvreurStatusInterval = setInterval(updateCouvreurStatus, COUVREUR_STATUS_UPDATE_INTERVAL);
    
    // V√©rifier imm√©diatement
    checkCouvreurMovement();
    updateCouvreurStatus();
    
    if (btnCouvreurSeul) {
      btnCouvreurSeul.innerHTML = "<span>üö∂</span><span>D√©sactiver couvreur cheminant seul</span>";
      btnCouvreurSeul.classList.remove("btn-warning");
      btnCouvreurSeul.classList.add("btn-secondary");
    }
  }

  // Fonction pour arr√™ter le mode "couvreur cheminant seul"
  function stopCouvreurSeul() {
    couvreurSeulActive = false;
    couvreurLastMovementTime = null;
    couvreurLastPosition = null;
    
    if (couvreurCheckInterval) {
      clearInterval(couvreurCheckInterval);
      couvreurCheckInterval = null;
    }
    
    if (couvreurStatusInterval) {
      clearInterval(couvreurStatusInterval);
      couvreurStatusInterval = null;
    }
    
    // Arr√™ter le timer SMS et la sonnerie
    stopSmsTimer();
    stopAlarm();
    
    updateCouvreurStatus();
    
    if (btnCouvreurSeul) {
      btnCouvreurSeul.innerHTML = "<span>üö∂</span><span>Couvreur cheminant seul</span>";
      btnCouvreurSeul.classList.remove("btn-secondary");
      btnCouvreurSeul.classList.add("btn-warning");
    }
  }

  const PK_LOOKUP_SUGGESTION_LIMIT = 6;

  function normalizeTextForSearch(str) {
    if (!str) return "";
    return str
      .toString()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-z0-9\s]/gi, " ")
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }

  function levenshteinDistance(a, b) {
    if (a === b) return 0;
    if (!a) return b ? b.length : 0;
    if (!b) return a.length;
    const lenA = a.length;
    const lenB = b.length;
    const prev = new Array(lenB + 1);
    const curr = new Array(lenB + 1);
    for (let j = 0; j <= lenB; j++) prev[j] = j;
    for (let i = 1; i <= lenA; i++) {
      curr[0] = i;
      const charA = a.charAt(i - 1);
      for (let j = 1; j <= lenB; j++) {
        const cost = charA === b.charAt(j - 1) ? 0 : 1;
        curr[j] = Math.min(
          prev[j] + 1,
          curr[j - 1] + 1,
          prev[j - 1] + cost
        );
      }
      for (let j = 0; j <= lenB; j++) prev[j] = curr[j];
    }
    return curr[lenB];
  }

  function computeTokenScore(token, target) {
    if (!token || !target) return 0;
    if (target.includes(token)) {
      const idx = target.indexOf(token);
      return 90 - Math.min(idx, 60);
    }
    let bestRatio = 0;
    const parts = target.split(/[\s,/'"()\-]+/);
    for (const part of parts) {
      if (!part) continue;
      const maxLen = Math.max(token.length, part.length);
      const dist = levenshteinDistance(token, part.slice(0, token.length + 2));
      const ratio = 1 - dist / Math.max(maxLen, 1);
      if (ratio > bestRatio) bestRatio = ratio;
    }
    if (bestRatio === 0) {
      const maxLen = Math.max(token.length, target.length);
      const dist = levenshteinDistance(token, target.slice(0, token.length + 4));
      bestRatio = 1 - dist / Math.max(maxLen, 1);
    }
    return Math.max(0, bestRatio * 75);
  }
  function computeFieldScore(queryTokens, field) {
    const target = normalizeTextForSearch(field);
    if (!target) return 0;
    let score = 0;
    for (const token of queryTokens) {
      score += computeTokenScore(token, target);
    }
    if (target.startsWith(queryTokens[0] || "")) {
      score += 20;
    }
    return score;
  }

  function formatDistanceLabel(distance) {
    if (!Number.isFinite(distance)) return null;
    if (distance < 1000) {
      return Math.round(distance) + " m";
    }
    const km = distance / 1000;
    return km.toLocaleString("fr-FR", { maximumFractionDigits: 1 }) + " km";
  }

  function searchAccessPointsByText(query) {
    if (!accessPoints || !Array.isArray(accessPoints)) {
      console.error("‚ùå accessPoints n'est pas d√©fini ou n'est pas un tableau");
      return [];
    }
    const normalizedQuery = normalizeTextForSearch(query);
    if (!normalizedQuery) return [];
    const tokens = normalizedQuery.split(" ").filter(Boolean);
    if (!tokens.length) return [];
    const results = [];
    const seen = new Set();
    for (const acc of accessPoints) {
      const fields = [acc.name, acc.address];
      if (Array.isArray(acc.aliases)) {
        for (const alias of acc.aliases) fields.push(alias);
      }
      let bestScore = -Infinity;
      for (const field of fields) {
        const score = computeFieldScore(tokens, field);
        if (score > bestScore) bestScore = score;
      }
      if (bestScore > 35) {
        const key = `${acc.name}|${acc.address || ""}`;
        if (!seen.has(key)) {
          seen.add(key);
          const distance = (state.lastLat != null && state.lastLon != null && acc.lat != null && acc.lon != null)
            ? distanceMeters(state.lastLat, state.lastLon, acc.lat, acc.lon)
            : null;
          results.push({
            access: acc,
            score: bestScore,
            distance,
            distanceLabel: formatDistanceLabel(distance)
          });
        }
      }
    }
    results.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if (a.distance != null && b.distance != null) return a.distance - b.distance;
      if (a.access.pk != null && b.access.pk != null) return a.access.pk - b.access.pk;
      return a.access.name.localeCompare(b.access.name);
    });
    return results;
  }

  function updatePkLookupSuggestionsList(value) {
    if (!pkLookupSuggestions) return;
    pkLookupSuggestions.innerHTML = "";
    const trimmed = value.trim();
    if (!trimmed) return;
    if (/^[0-9+\s]+$/.test(trimmed)) {
      const option = document.createElement("option");
      option.value = trimmed.replace(/\s+/g, "");
      pkLookupSuggestions.appendChild(option);
      return;
    }
    const suggestions = searchAccessPointsByText(trimmed).slice(0, PK_LOOKUP_SUGGESTION_LIMIT);
    suggestions.forEach(entry => {
      const opt = document.createElement("option");
      opt.value = entry.access.name;
      if (entry.access.address) {
        opt.label = entry.access.address;
      }
      pkLookupSuggestions.appendChild(opt);
    });
  }

  function getBranchLabel(branch) {
    switch (branch) {
      case "boissy":
        return "branche Boissy-Saint-L√©ger";
      case "chessy":
        return "branche Marne-la-Vall√©e ‚Äì Chessy";
      case "central":
      case "both":
        return "tron√ßon central";
      default:
        return "branche inconnue";
    }
  }

  function renderPkLookupSummary({ access, targetPk = null, distanceLabel = null, branchChoice = null }) {
    if (!pkLookupResult || !pkLookupResultField || !access) return;
    const details = [];
    details.push(`<strong>Acc√®s :</strong> ${access.name}`);
    if (Number.isFinite(access.pk)) {
      if (Number.isFinite(targetPk)) {
        const delta = Math.round(Math.abs(access.pk - targetPk));
        const dir = access.pk >= targetPk ? "vers Chessy / Boissy" : "vers St-Germain / Paris";
        details.push(`PK ${formatPk(access.pk)} (ŒîPK ‚âà ${delta} m ${dir})`);
      } else {
        details.push(`PK ${formatPk(access.pk)}`);
      }
    }
    const branchLabel = getBranchLabel(branchChoice || currentBranch);
    details.push(`<span class="muted">${branchLabel}</span>`);
    if (access.address) {
      details.push(`<span class="muted">${access.address}</span>`);
    }
    if (distanceLabel) {
      details.push(`<span class="muted">√Ä ‚âà ${distanceLabel}</span>`);
    }

    pkLookupResult.innerHTML = details.join("<br>");
    pkLookupResultField.style.display = "block";
    lastPkLookupAccess = access;
    try {
      safeSetItem("pkLookupLastAccess", JSON.stringify({
        name: access.name,
        pk: access.pk,
        address: access.address || null
      }));
      if (Number.isFinite(targetPk)) {
        safeSetItem("pkLookupLastTargetPk", String(targetPk));
      } else {
        safeSetItem("pkLookupLastTargetPk", "");
      }
    } catch (error) {
      console.warn("Impossible d'enregistrer le dernier acc√®s recherch√©", error);
    }
  }

  function showPkLookupNoResultMessage() {
    currentPkLookupTextResults = [];
    lastPkLookupAccess = null;
    if (!pkLookupResult || !pkLookupResultField) return;
    pkLookupResult.innerHTML = "<span class='muted'>Aucun acc√®s trouv√©. Essaie un autre PK, une rue ou un nom d'acc√®s.</span>";
    pkLookupResultField.style.display = "block";
  }

  function showPkLookupChoices(results) {
    if (!pkLookupResult || !pkLookupResultField) return;
    currentPkLookupTextResults = results.slice(0, 8);
    if (!currentPkLookupTextResults.length) {
      showPkLookupNoResultMessage();
      return;
    }
    const list = currentPkLookupTextResults.map((entry, index) => {
      const access = entry.access;
      const meta = [];
      if (access.pk != null) {
        meta.push(`PK ${formatPk(access.pk)}`);
      }
      if (access.address) {
        meta.push(access.address);
      }
      if (entry.distanceLabel) {
        meta.push(`‚âà ${entry.distanceLabel}`);
      }
      const metaHtml = meta.map(text => `<span class="muted">${text}</span>`).join(" ");
      return `<button type="button" class="pk-lookup-choice" data-index="${index}">
        <strong>${access.name}</strong>
        ${metaHtml}
      </button>`;
    }).join("");
    pkLookupResult.innerHTML = list;
    pkLookupResultField.style.display = "block";
    lastPkLookupAccess = null;
  }

  async function handlePkLookupChoice(entry) {
    const access = entry.access;
    if (Number.isFinite(access.pk)) {
      ensureBranchForPk(access.pk, BRANCH_SELECTION_CONTEXTS.search);
    }
    const contextBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.search);
    renderPkLookupSummary({
      access,
      distanceLabel: entry.distanceLabel,
      branchChoice: contextBranch !== "auto" ? contextBranch : null
    });
    currentPkLookupTextResults = [];
  }

  async function handlePkLookup() {
    if (!inputPkLookup) return;
    const rawInput = inputPkLookup.value.trim();
    currentPkLookupTextResults = [];
    if (!rawInput) {
      alert("Saisis un PK, une rue ou un nom d'acc√®s.");
      return;
    }

    safeSetItem("pkLookupQuery", rawInput);

    const numericLike = /^[0-9+\s]+$/.test(rawInput);
    // Utiliser la branche choisie dans le menu pour ce contexte
    const searchBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.search);
    const numericCandidate = parsePkInput(rawInput, searchBranch);
    if (numericLike && numericCandidate != null) {
      debugLog("üîç Recherche PK - branche choisie:", searchBranch);
      
      let branchForLookup = searchBranch;
      // Si on est dans la zone commune (7050-22300), demander confirmation si n√©cessaire
      if (numericCandidate >= COMMON_BRANCH_PROMPT_MIN && numericCandidate <= COMMON_BRANCH_PROMPT_MAX) {
        branchForLookup = ensureBranchForPk(numericCandidate, BRANCH_SELECTION_CONTEXTS.search);
      }
      
      const branchChoice = branchForLookup || null;
      debugLog("üîç Recherche de l'acc√®s le plus proche pour PK", numericCandidate, "sur la branche", branchChoice || "auto");
      const access = findNearestAccess(numericCandidate, branchChoice);
      if (!access) {
        console.warn("‚ùå Aucun acc√®s trouv√© pour PK", numericCandidate, "sur la branche", branchChoice || "auto");
        showPkLookupNoResultMessage();
        return;
      }
      debugLog("‚úÖ Acc√®s trouv√©:", access.name, "PK", access.pk, "pour la branche", branchChoice || "auto");
      renderPkLookupSummary({
        access,
        targetPk: numericCandidate,
        branchChoice
      });
      return;
    }

    let textResults;
    try {
      textResults = searchAccessPointsByText(rawInput);
    } catch (error) {
      console.error("‚ùå Erreur lors de la recherche textuelle:", error);
      alert("Erreur lors de la recherche. V√©rifiez la console pour plus de d√©tails.");
      return;
    }
    if (!textResults || !textResults.length) {
      showPkLookupNoResultMessage();
      return;
    }
    if (textResults.length === 1) {
      await handlePkLookupChoice(textResults[0]);
    } else {
      showPkLookupChoices(textResults);
    }
  }

  function openPkLookupInMaps() {
    if (!lastPkLookupAccess) {
      alert("Aucun acc√®s s√©lectionn√©. Lance une recherche par PK d'abord.");
      return;
    }

    let url;
    // Si on a des coordonn√©es GPS pr√©cises ‚Üí on ouvre directement √† cet endroit
    if (
      lastPkLookupAccess.lat != null &&
      lastPkLookupAccess.lon != null
    ) {
      url = "https://maps.google.com/?q=" +
        lastPkLookupAccess.lat + "," + lastPkLookupAccess.lon;
    } else {
      // Sinon on ouvre une recherche sur l'adresse / le nom
      const query = lastPkLookupAccess.address || lastPkLookupAccess.name;
      url = "https://www.google.com/maps/search/?api=1&query=" +
        encodeURIComponent(query);
    }

    window.open(url, "_blank");
  }

  function openPkLookupInWaze() {
    if (!lastPkLookupAccess) {
      alert("Aucun acc√®s s√©lectionn√©. Lance une recherche par PK d'abord.");
      return;
    }
    const lat = lastPkLookupAccess.lat;
    const lon = lastPkLookupAccess.lon;
    if (lat == null || lon == null) {
      alert("Pas de coordonn√©es GPS pour cet acc√®s.");
      return;
    }
    // Lien universel Waze
    const url = "https://waze.com/ul?ll=" + lat + "," + lon + "&navigate=yes";
    window.open(url, "_blank");
  }

  if (selectIncidentType) {
  selectIncidentType.addEventListener("change", () => {
    if (selectIncidentType.value === "Autre") {
        if (incidentOtherField) incidentOtherField.style.display = "block";
    } else {
        if (incidentOtherField) incidentOtherField.style.display = "none";
    }
  });
  }

  if (btnGenerateIncident) {
  btnGenerateIncident.addEventListener("click", () => {
    if (state.lastPk == null || state.lastLat == null) {
      alert("Position GPS non disponible. Lance la g√©oloc avant de signaler.");
      return;
    }
    ensureBranchForPk(state.lastPk, BRANCH_SELECTION_CONTEXTS.incident);
      let type = selectIncidentType ? selectIncidentType.value : "";
    if (!type) {
        alert("Choisis un type d'incident avant de g√©n√©rer le message.");
      return;
    }
    if (type === "Autre") {
        const desc = inputIncidentOther ? inputIncidentOther.value.trim() : "";
      if (!desc) {
          alert("Pr√©cise la nature de l'incident.");
        return;
      }
      type = desc;
    }

    const pkTxt = "PK " + formatPk(state.lastPk);
    const station = state.nearestStation ? state.nearestStation.name : "inconnue";
    const lat = state.lastLat.toFixed(5);
    const lon = state.lastLon.toFixed(5);
    const now = new Date();
    const dateTxt = now.toLocaleDateString("fr-FR");
    const timeTxt = now.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });

    let message =
        "üö® Signalement d'avarie / incident\n" +
      "Type : " + type + "\n" +
      "PK : " + pkTxt + "\n" +
      "Branche : " + (currentBranch === "boissy"
                      ? "Boissy-Saint-L√©ger"
                      : currentBranch === "chessy"
                        ? "Marne-la-Vall√©e ‚Äì Chessy"
                        : "inconnue") + "\n" +
      "Gare la plus proche : " + station + "\n";

    if (state.nearestAccess) {
      message +=
        "Acc√®s le plus proche : " + state.nearestAccess.name +
        " (" + state.nearestAccess.address + ")\n";
    }

    message +=
      "Coordonn√©es : " + lat + ", " + lon + "\n" +
      "Date/heure : " + dateTxt + " ‚Äì " + timeTxt;

    if (incidentPhotoInput && incidentPhotoInput.files && incidentPhotoInput.files.length > 0) {
      const file = incidentPhotoInput.files[0];
      if (file && file.name) {
        message += "\nPhoto jointe : " + file.name;
      }
    }

      if (incidentResultText) incidentResultText.value = message;
      if (incidentResultField) incidentResultField.style.display = "block";
  });
  }

  if (btnCopyIncident) {
  btnCopyIncident.addEventListener("click", () => {
    const text = incidentResultText.value;
    if (!text) {
      alert("Aucun message √† copier.");
      return;
    }
    if (navigator.clipboard && window.isSecureContext) {
      navigator.clipboard.writeText(text).then(() => {
        alert("Message copi√© dans le presse-papiers ‚úÖ");
      }).catch(() => {
        incidentResultText.select();
        document.execCommand("copy");
        alert("Message copi√© dans le presse-papiers ‚úÖ");
      });
    } else {
      incidentResultText.select();
      document.execCommand("copy");
      alert("Message copi√© dans le presse-papiers ‚úÖ");
    }
  });
  }

  if (btnAddIncidentToNote) {
    btnAddIncidentToNote.addEventListener("click", addIncidentToNote);
  }

  if (btnExportIncidentsNote) {
    btnExportIncidentsNote.addEventListener("click", exportIncidentsAsNote);
  }

  if (btnClearIncidents) {
    btnClearIncidents.addEventListener("click", clearIncidents);
  }

  // Attacher l'event listener au bouton de g√©olocalisation (si le bouton existe d√©j√†)
  if (btnToggleGeoloc) {
    btnToggleGeoloc.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log("Bouton g√©oloc cliqu√© (premi√®re tentative)");
      if (geolocActive) {
        stopGeoloc();
      } else {
        startGeoloc();
      }
    });
  }

  // === README / TUTORIEL ===
  function generateReadmeContent() {
    if (!readmeContent) return;

    const content = `
      <div style="max-width: 100%;">
        <h2 style="color: var(--accent); margin-top: 0; margin-bottom: 20px; font-size: 1.3rem;">üìñ Guide d'utilisation - PK Assistant RER A</h2>

        <p><strong>üöÄ Vue d'ensemble</strong></p>
        <p>L'application est d√©sormais structur√©e en <strong>onglets color√©s</strong> en bas d'√©cran&nbsp;: <em>Statut</em>, <em>Plan</em>, <em>Urgence &amp; avaries</em>, <em>Calcul &amp; recherche PK</em>, <em>Fermetures</em> et <em>Param√®tres</em>. Chaque onglet regroupe les outils qui lui correspondent et un appui fait d√©filer automatiquement la page en haut.</p>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üì° Statut</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li><strong>Lancer la g√©oloc</strong> pour afficher PK actuel, sens d√©tect√©, gare la plus proche, prochaine gare et <strong>acc√®s le plus proche</strong>.</li>
          <li>Les puces interactives (gare / acc√®s) ouvrent la carte sur le rep√®re correspondant.</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üó∫Ô∏è Plan</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li>Carte Leaflet sombre avec ta position, les gares et les acc√®s (zoom intelligent).</li>
          <li><strong>PK cible</strong> : saisis un PK puis clique sur ¬´¬†D√©finir¬†¬ª pour tracer une croix rouge et afficher l'√©cart dans le panneau statut.</li>
          <li><strong>Plan de ligne</strong> : 3 cases √† cocher ouvrent les PDF Boissy / Paris-Ouest / Chessy directement dans l'application. <strong>Navigation par pages</strong> : utilise les boutons ‚Äπ ‚Ä∫ ou saisis directement le num√©ro de page pour naviguer dans les PDF (fonctionne sur mobile et desktop).</li>
          <li>La l√©gende pastel liste les feux rouges / p√©tards : un clic centre la carte et ouvre le popup (Waze / Maps inclus).</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üö® Urgence &amp; avaries</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li><strong>SMS d'urgence</strong> : g√©n√®re un message complet (PK, branche, acc√®s, coordonn√©es) pr√™t √† envoyer.</li>
          <li><strong>Couvreur cheminant seul</strong> : surveillance automatique. Apr√®s 1 minute sans mouvement, le SMS part automatiquement (avec alarme au-del√† de 30 s).</li>
          <li><strong>Signalement d'avarie / incident</strong> : formulaire avec photo optionnelle + message pr√©-rempli copiable d'un clic.</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üîç Calcul &amp; recherche PK</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li><strong>Recherche par PK</strong> : propose l'acc√®s le plus proche et des raccourcis Google Maps / Waze.</li>
          <li><strong>Calcul couverture travaux</strong> : saisis PK d√©but/fin. La doctrine (SAM √† 100 m, 3 p√©tards espac√©s 30 m) est rappel√©e dans le mode op√©ratoire, et les rep√®res sont ajout√©s sur la carte.</li>
          <li>Bouton ¬´ Effacer les marqueurs ¬ª pour repartir de z√©ro.</li>
          <li><strong>‚ö†Ô∏è Zone de saut PK (Nanterre)</strong> : entre Nanterre-Universit√© (PK 10 800) et Nanterre-Pr√©fecture (PK 11 300), il existe un saut de +500 m dans la num√©rotation PK alors que la distance physique r√©elle est d'environ 50 m. L'application arrondit automatiquement toute position dans cette zone au PK le plus proche (10 800 ou 11 300). Un message d'avertissement s'affiche : ¬´ Zone de saut PK (10 800‚Üî11 300) ‚Äî position arrondie √† 10 800/11 300 ¬ª. Les distances m√©triques (rouges/p√©tards, proximit√©) restent bas√©es sur la distance physique r√©elle.</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üåô Fermetures</h3>
        <p>Affiche les fermetures nocturnes du jour (extraites de Sytadin) : id√©al pour pr√©parer un d√©placement de nuit.</p>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">‚öôÔ∏è Param√®tres &amp; outils</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li><strong>Sensibilit√© au mouvement</strong> : adapte le seuil pour la d√©tection (Marche lente / Normal / Train).</li>
          <li><strong>Recalage PK</strong> : ajuste l'offset et exporte les recalages JSON.</li>
          <li><strong>Points de carte</strong> : enregistre un point GPS avec description. <strong>Export</strong> : disponible en format JSON (pour GitHub) ou Note (format texte lisible avec toutes les informations).</li>
          <li><strong>Num√©ro SOS</strong> : m√©morise le num√©ro utilis√© par le SMS d'urgence et le mode couvreur.</li>
          <li><strong>Tutoriel</strong> : accessible ici en permanence, avec ce guide √† jour.</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üí° Conseils</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li>La pr√©cision GPS augmente en ext√©rieur. L'animation de fond se met en pause quand l'app est masqu√©e pour √©conomiser la batterie.</li>
          <li>Plus tu enregistres de recalages et de points, plus le calcul PK devient pr√©cis.</li>
          <li>Les onglets restent √©pingl√©s en bas : passe de l'un √† l'autre sans perdre le contexte.</li>
          <li><strong>Zone Nanterre</strong> : si tu travailles entre Nanterre-Universit√© et Nanterre-Pr√©fecture, l'application arrondit automatiquement le PK affich√©. Les calculs de couverture (rouges/p√©tards) respectent √©galement ce d√©coupage strict : aucun marqueur ne sera positionn√© entre PK 10 800 et 11 300.</li>
        </ul>

        <h3 style="color: var(--text); margin-top: 25px; margin-bottom: 12px; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 8px;">üîí S√©curit√© & bonnes pratiques</h3>
        <ul style="margin-left: 20px; margin-top: 8px;">
          <li>Respecte toujours les consignes RATP et la vigilance terrain : l'application reste un outil d'orientation.</li>
          <li>L'utilisation du t√©l√©phone sur la voie est interdite : consulte l'app hors zone de danger.</li>
          <li>Les donn√©es (offset, num√©ros, points) sont stock√©es localement sur ton appareil.</li>
        </ul>

        <p style="margin-top: 24px;">Besoin d'aide ? Contacte l'administrateur depuis le pied de page (¬´¬†KYFUN¬†¬ª ‚Üí pascal.akriche@ratp.fr).</p>
      </div>
    `;

    readmeContent.innerHTML = content;
  }

  // Event listeners pour le README
  if (btnReadme && readmePanel) {
    btnReadme.addEventListener("click", () => {
      generateReadmeContent();
      const isVisible = readmePanel.style.display !== "none";
      readmePanel.style.display = isVisible ? "none" : "block";
    });
  }

  if (btnCloseReadme && readmePanel) {
    btnCloseReadme.addEventListener("click", () => {
      readmePanel.style.display = "none";
    });
  }

  // Fonction pour initialiser les event listeners de la liste de tests
  function initTestListListeners() {
    const btnTestListEl = document.getElementById("btnTestList");
    const testListPanelEl = document.getElementById("testListPanel");
    const btnCloseTestListEl = document.getElementById("btnCloseTestList");
    
    if (btnTestListEl && testListPanelEl) {
      btnTestListEl.addEventListener("click", () => {
        generateTestListContent();
        const isVisible = testListPanelEl.style.display !== "none";
        testListPanelEl.style.display = isVisible ? "none" : "block";
      });
    }

    if (btnCloseTestListEl && testListPanelEl) {
      btnCloseTestListEl.addEventListener("click", () => {
        testListPanelEl.style.display = "none";
      });
    }
  }

  if (btnSetPkTarget && inputPkTarget) {
  btnSetPkTarget.addEventListener("click", () => {
    const targetBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.target);
    const val = parsePkInput(inputPkTarget.value, targetBranch);
    if (val == null) {
      alert("PK cible invalide. Utilise 32400 ou 32+400.");
      return;
    }
    const branchForTarget = ensureBranchForPk(val, BRANCH_SELECTION_CONTEXTS.target);
    pkTargetBranch = branchForTarget && branchForTarget !== "auto" ? branchForTarget : null;
    pkTarget = val;
    updatePkTargetView();
    updateOrientationPanel();
  });
  }

  if (btnSms) {
  btnSms.addEventListener("click", sendSms);
  }

  // === MODE COUVREUR CHEMINANT SEUL ===
  if (btnCouvreurSeul) {
    btnCouvreurSeul.addEventListener("click", () => {
      if (couvreurSeulActive) {
        stopCouvreurSeul();
      } else {
        startCouvreurSeul();
      }
    });
  }
  if (btnResetOffset) {
  btnResetOffset.addEventListener("click", () => {
    hideRecalPreview();
    pendingRecal = null;
    pkOffset = 0;
    safeSetItem("pkOffset", pkOffset);
    updateOffsetInfo();
    if (state.lastRawPk != null) {
      state.lastPk = computePkWithCalibrations(state.lastRawPk, currentBranch);
      state.nearestStation = findNearestStation(state.lastPk, currentBranch);
      state.nearestAccess = (state.lastLat != null && state.lastLon != null)
        ? findNearestAccessGeo(state.lastLat, state.lastLon)
        : findNearestAccess(state.lastPk, currentBranch);
      updateNearestStation(state.lastPk, state.nearestStation);
      updateNextStation(state.lastPk);
      updateNearestAccess(state.lastPk);
      updatePkTargetView();
      updateSmsPreview();
      updateOrientationPanel();
    }
    updatePkEstimateInSettings();
    setRecalMessage("Offset remis √† z√©ro.", "info");
  });
}
if (btnApplyRecal && inputPkRecal) {
  btnApplyRecal.addEventListener("click", () => {
    const recalBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.recal);
    const exactPk = parsePkInput(inputPkRecal.value, recalBranch);
    if (exactPk == null) {
      setRecalMessage("PK invalide. Utilise 52700 ou 52+700.", "error");
      return;
    }
    if (state.lastRawPk == null) {
      setRecalMessage("Pas de position GPS pour recaler. Lance la g√©oloc d'abord.", "error");
      return;
    }
    // exactPk est d√©j√† un PK m√©trique (retourn√© par parsePkInput qui utilise parseUserPkInput)
    // convertDisplayPkToMetricPk g√®re uniquement les discontinuit√©s (sauts PK), pas la conversion relatif/absolu
    const branchForCal = ensureBranchForPk(exactPk, BRANCH_SELECTION_CONTEXTS.recal) || (recalBranch && recalBranch !== "auto" ? recalBranch : currentBranch);
    const metricPk = convertDisplayPkToMetricPk(exactPk, branchForCal);
    const offset = metricPk - state.lastRawPk;
    
    // V√©rifier si on est dans une zone de discontinuit√©
    const disc = findDiscontinuityForDisplayPk(exactPk, branchForCal);
    const hasDiscontinuity = disc != null;
    
    pendingRecal = {
      pkExact: exactPk, // PK m√©trique (d√©j√† converti depuis le PK relatif saisi par l'utilisateur)
      pkExactMetric: metricPk, // PK m√©trique apr√®s gestion des discontinuit√©s (pour le stockage interne)
      pkRaw: state.lastRawPk,
      offset,
      previousOffset: pkOffset,
      branch: branchForCal,
      lat: state.lastLat,
      lon: state.lastLon,
      accuracy: state.lastAccuracy,
      timestamp: new Date().toISOString(),
      hasDiscontinuity: hasDiscontinuity,
      discontinuityJump: hasDiscontinuity ? disc.jump : null
    };
    showRecalPreview(pendingRecal);
    const delta = Math.round(offset);
    const prefix = delta >= 0 ? "+" + delta : String(delta);
    let message = `Pr√©visualisation : offset ${prefix} m. Confirme ou annule.`;
    if (hasDiscontinuity) {
      message += ` (Saut PK de +${disc.jump} m dans cette zone)`;
    }
    setRecalMessage(message, "info");
  });
}
if (btnConfirmRecal) {
  btnConfirmRecal.addEventListener("click", () => {
    if (!pendingRecal) {
      setRecalMessage("Aucun recalage en attente √† confirmer.", "error");
      return;
    }
    applyPendingRecal(pendingRecal);
  });
}
if (btnCancelRecal) {
  btnCancelRecal.addEventListener("click", () => {
    hideRecalPreview();
    setRecalMessage("Recalage annul√©.", "info");
  });
}
if (btnUndoRecal) {
  btnUndoRecal.addEventListener("click", () => {
    undoLastRecal();
  });
}
  if (btnSavePhone) {
    btnSavePhone.addEventListener("click", () => {
      savePhoneNumber();
  updateSmsPreview();
  });
  }

if (selectSensitivity) {
selectSensitivity.addEventListener("change", () => {
  motionSensitivity = selectSensitivity.value;
  safeSetItem("motionSensitivity", motionSensitivity);
});
}
// Fonction pour g√©n√©rer le contenu des fermetures nocturnes
function generateFermeturesNocturnesContent() {
  const today = new Date();
  const days = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'];
  const months = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
  const dayName = days[today.getDay()];
  const day = today.getDate();
  const month = months[today.getMonth()];
  const year = today.getFullYear();
  const dateStr = `${dayName} ${day} ${month} ${year}`;

  const content = `
    <div style="margin-bottom: 20px;">
      <div style="font-weight: 600; margin-bottom: 12px; color: var(--text);">Aujourd'hui (${dateStr})</div>
      
      <div style="font-weight: 600; margin-top: 20px; margin-bottom: 12px; color: var(--text); text-decoration: underline;">Fermetures nocturnes de 21h √† 6h</div>
      
      <div style="margin-top: 15px;">
        <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">Autoroutes et grands axes</div>
        <div style="line-height: 1.6; color: var(--muted);">
          ‚Ä¢ A15 VERS PARIS : Sortie 6 Pierrelaye (24h/24)<br>
          ‚Ä¢ A3 VERS PARIS : Sortie 3 Romainville (24h/24)<br>
          ‚Ä¢ BP INTERIEUR : Sortie Porte de La Chapelle (24h/24)
        </div>
      </div>
      
      <div style="margin-top: 15px;">
        <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">Voies sur berges dans Paris</div>
        <div style="line-height: 1.6; color: var(--muted);">
          Pas de fermeture nocturne pr√©vue sur les Voies sur berges dans Paris
        </div>
      </div>
      
      <div style="margin-top: 15px;">
        <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">Quais, tunnels, viaducs dans Paris</div>
        <div style="line-height: 1.6; color: var(--muted);">
          Pas de fermeture nocturne pr√©vue sur les Quais, tunnels, viaducs dans Paris
        </div>
      </div>
    </div>
  `;
  
  if (fermeturesNocturnesContent) {
    fermeturesNocturnesContent.innerHTML = content;
  }
}

// Gestion de l'affichage du bloc Fermetures nocturnes
// (affichage d√©clench√© via l'onglet d√©di√©)
if (btnPkLookup) {
  btnPkLookup.addEventListener("click", () => {
    handlePkLookup().catch(err => console.error("handlePkLookup error", err));
  });
}
if (inputPkLookup) {
  inputPkLookup.addEventListener("keydown", event => {
    if (event.key === "Enter") {
      event.preventDefault();
      handlePkLookup().catch(err => console.error("handlePkLookup error", err));
    }
  });
  inputPkLookup.addEventListener("input", () => {
    updatePkLookupSuggestionsList(inputPkLookup.value);
  });
}
if (pkLookupResult) {
  pkLookupResult.addEventListener("click", event => {
    const choice = event.target.closest(".pk-lookup-choice");
    if (!choice) return;
    const index = Number(choice.getAttribute("data-index"));
    if (!Number.isFinite(index)) return;
    const entry = currentPkLookupTextResults[index];
    if (!entry) return;
    handlePkLookupChoice(entry).catch(err => console.error("handlePkLookupChoice error", err));
  });
}
if (btnPkLookupOpenMaps) {
  btnPkLookupOpenMaps.addEventListener("click", openPkLookupInMaps);
}
if (btnPkLookupOpenWaze) {
  btnPkLookupOpenWaze.addEventListener("click", openPkLookupInWaze);
}

// AJOUT CALIBRAGE : clic sur "Exporter mes recalages"
if (btnExportCalibrations) {
  btnExportCalibrations.addEventListener("click", exportLocalCalibrationsForGitHub);
}

// Points de carte
if (btnNoteLocation) {
  btnNoteLocation.addEventListener("click", noteLocation);
}

if (btnExportMapPoints) {
  btnExportMapPoints.addEventListener("click", exportMapPointsForGitHub);
}

if (btnExportMapPointsNote) {
  btnExportMapPointsNote.addEventListener("click", exportMapPointsAsNote);
}

// Calcul de couverture travaux (feux rouges et p√©tards)
const inputCoveragePkStart = document.getElementById("inputCoveragePkStart");
const inputCoveragePkEnd = document.getElementById("inputCoveragePkEnd");
const btnComputeCoverage = document.getElementById("btnComputeCoverage");
const btnClearCoverage = document.getElementById("btnClearCoverage");
const coverageResult = document.getElementById("coverageResult");
const coverageResultText = document.getElementById("coverageResultText");
const coverageResultsLine = document.getElementById("coverageResultsLine");
const coverageLegend = document.getElementById("coverageLegend");
const coverageLegendItems = document.getElementById("coverageLegendItems");
const btnLegendCollapse = document.getElementById("btnLegendCollapse");
const legendToggleSam = document.getElementById("legendToggleSam");
const legendTogglePetard = document.getElementById("legendTogglePetard");
const btnLegendBranch = document.getElementById("btnLegendBranch");
const legendBranchLabel = document.getElementById("legendBranchLabel");
const legendBranchMenu = document.getElementById("legendBranchMenu");
const legendBranchControls = document.getElementById("legendBranchControls");
const toggleCoverageGuide = document.getElementById("toggleCoverageGuide");
const coverageGuide = document.getElementById("coverageGuide");
const ARROW_DISTANCE_METERS = 45;

if (toggleCoverageGuide && coverageGuide) {
  toggleCoverageGuide.addEventListener("change", () => {
    coverageGuide.classList.toggle("is-visible", toggleCoverageGuide.checked);
  });
}

if (legendToggleSam) {
  legendToggleSam.addEventListener("change", () => setLegendToggleState("sam", legendToggleSam.checked));
}
if (legendTogglePetard) {
  legendTogglePetard.addEventListener("change", () => setLegendToggleState("petard", legendTogglePetard.checked));
}
if (btnLegendCollapse) {
  btnLegendCollapse.addEventListener("click", () => {
    setCoverageLegendCollapsed(!coverageLegendCollapsed);
  });
}
if (btnLegendBranch) {
  btnLegendBranch.addEventListener("click", () => {
    toggleLegendBranchMenu();
  });
}
if (legendBranchMenu) {
  legendBranchMenu.addEventListener("click", event => {
    const choice = event.target.closest("button[data-branch]");
    if (!choice) return;
    handleLegendBranchChoice(choice.getAttribute("data-branch"));
  });
}

function removeCoverageMarkersFromMap() {
  coverageSamMarkers.forEach(marker => {
    if (orientationMap && orientationMap.hasLayer(marker)) {
      orientationMap.removeLayer(marker);
    }
  });
  coveragePetardMarkers.forEach(marker => {
    if (orientationMap && orientationMap.hasLayer(marker)) {
      orientationMap.removeLayer(marker);
    }
  });
  coverageSamMarkers = [];
  coveragePetardMarkers = [];
}

function clearCoverageMarkers() {
  removeCoverageMarkersFromMap();
  if (coverageResult) coverageResult.style.display = "none";
  if (btnClearCoverage) btnClearCoverage.style.display = "none";
  if (coverageResultText) coverageResultText.innerHTML = "";
  if (coverageResultsLine) {
    coverageResultsLine.innerHTML = '<span style="color: rgba(255, 255, 255, 0.5);">Cliquez sur ¬´ Calculer rouges & p√©tards ¬ª pour voir les r√©sultats</span>';
  }
  renderCoverageLegend([]);
}

function renderCoverageLegend(entries) {
  if (!coverageLegend || !coverageLegendItems) return;
  coverageLegendEntries = Array.isArray(entries) ? entries : [];
  if (!coverageLegendEntries.length) {
    coverageLegend.style.display = "none";
    coverageLegendItems.innerHTML = "";
    closeLegendBranchMenu();
    return;
  }

  const showSam = coverageLegendVisibility.sam !== false;
  const showPetard = coverageLegendVisibility.petard !== false;

  const items = coverageLegendEntries.map((entry, index) => {
    const kind = entry.kind === "petard" ? "petard" : "sam";
    const visible = kind === "petard" ? showPetard : showSam;
    const disabledClass = visible ? "" : " is-disabled";
    const ariaDisabled = visible ? "false" : "true";
    return `<button type="button" class="coverage-legend-item${disabledClass}" data-legend-index="${index}" data-legend-kind="${kind}" aria-disabled="${ariaDisabled}">
      <span class="coverage-legend-swatch coverage-legend-swatch--${kind}"></span>
      <span>${entry.label}</span>
    </button>`;
  });

  coverageLegendItems.innerHTML = items.join("");
  coverageLegend.style.display = "block";
  applyCoverageLegendFilters();
}

function focusLegendEntry(index) {
  const entry = coverageLegendEntries[index];
  if (!entry || !entry.marker) {
    alert("Aucun rep√®re disponible pour cette entr√©e.");
    return;
  }

  ensureOrientationMapReady();
  if (!orientationMap) return;

  const latLng = entry.marker.getLatLng();
  if (!latLng) {
    alert("Coordonn√©es indisponibles pour ce rep√®re.");
    return;
  }

  manualMapFocusUntil = Date.now() + 6000;
  orientationMap.setView(latLng, Math.max(15, orientationMap.getZoom() || 15));
  setTimeout(() => {
    if (entry.marker && typeof entry.marker.openPopup === "function") {
      entry.marker.openPopup();
    }
  }, 200);
}

function focusNearestStation() {
  ensureOrientationMapReady();
  if (!orientationMap || !currentNearestStationData) {
    alert("Aucune gare disponible pour la navigation.");
    return;
  }

  manualMapFocusUntil = Date.now() + 6000;

  if (gareMarker && typeof gareMarker.getLatLng === "function") {
    const latLng = gareMarker.getLatLng();
    orientationMap.setView(latLng, Math.max(15, orientationMap.getZoom() || 15));
    setTimeout(() => {
      if (gareMarker && typeof gareMarker.openPopup === "function") {
        gareMarker.openPopup();
      }
    }, 200);
    return;
  }

  if (currentNearestStationData.lat != null && currentNearestStationData.lon != null) {
    const latLng = L.latLng(currentNearestStationData.lat, currentNearestStationData.lon);
    orientationMap.setView(latLng, Math.max(15, orientationMap.getZoom() || 15));
  } else {
    alert("Coordonn√©es indisponibles pour cette gare.");
  }
}

function focusNearestAccess(index) {
  if (!currentNearestAccessesData.length) {
    alert("Aucun acc√®s √† afficher.");
    return;
  }
  const entry = currentNearestAccessesData[index];
  const marker = currentNearestAccessMarkers[index];
  ensureOrientationMapReady();
  if (!orientationMap || !entry) {
    alert("Acc√®s indisponible.");
    return;
  }

  if (marker && typeof marker.getLatLng === "function") {
    const latLng = marker.getLatLng();
    orientationMap.setView(latLng, Math.max(16, orientationMap.getZoom() || 16));
    manualMapFocusUntil = Date.now() + 6000;
    setTimeout(() => {
      if (marker && typeof marker.openPopup === "function") {
        marker.openPopup();
      }
    }, 200);
    return;
  }

  if (entry.acc && entry.acc.lat != null && entry.acc.lon != null) {
    const latLng = L.latLng(entry.acc.lat, entry.acc.lon);
    orientationMap.setView(latLng, Math.max(16, orientationMap.getZoom() || 16));
    manualMapFocusUntil = Date.now() + 6000;
  } else {
    alert("Coordonn√©es indisponibles pour cet acc√®s.");
  }
}

if (orientGareValueEl) {
  orientGareValueEl.addEventListener("keydown", (event) => {
    if ((event.key === "Enter" || event.key === " ") && orientGareValueEl.getAttribute("data-orient-action") === "station") {
      event.preventDefault();
      focusNearestStation();
    }
  });
}
function addCoverageMarkersToMap(result, branchHint = null) {
  // CRITIQUE : Sauvegarder linePoints AVANT le try pour qu'il soit accessible dans finally
  const savedLinePoints = linePoints;
  
  try {
    ensureOrientationMapReady();

    if (orientationMap) {
      updateOrientationPanel();
    }

    removeCoverageMarkersFromMap();

    // CRITIQUE : Mettre √† jour linePoints selon la branche choisie AVANT d'appeler getGpsFromPk
    if (branchHint === "boissy") {
      linePoints = linePointsBoissy || troncCommun.concat(brancheBoissy);
      debugLog("‚úÖ addCoverageMarkersToMap : utilisation de la branche Boissy pour getGpsFromPk");
    } else if (branchHint === "chessy") {
      linePoints = linePointsChessy || troncCommun.concat(brancheChessy);
      debugLog("‚úÖ addCoverageMarkersToMap : utilisation de la branche Chessy pour getGpsFromPk");
    } else {
      linePoints = troncCommun.slice();
      debugLog("‚úÖ addCoverageMarkersToMap : utilisation du tronc commun pour getGpsFromPk");
    }

    const sideSummaries = result.bySide.map(sideResult => {
      const sideLabel = sideResult.side === "pkStart" ? "D√©but" : "Fin";
      const samGps = getGpsFromPk(sideResult.pkSamRep);
      debugLog("üîç SAM PK:", sideResult.pkSamRep, "GPS:", samGps, "branche:", branchHint);
      const samAccess = samGps ? getNearestAccessDetails(samGps.lat, samGps.lon, sideResult.pkSamRep, branchHint) : null;
      debugLog("üîç SAM acc√®s trouv√©:", samAccess ? samAccess.name : "aucun", "PK:", samAccess ? samAccess.pk : "N/A");
      const samEntry = {
        type: "sam",
        side: sideResult.side,
        sideLabel,
        pk: sideResult.pkSamRep,
        lat: samGps ? samGps.lat : null,
        lon: samGps ? samGps.lon : null,
        nearestAccess: samAccess,
        title: `Feu rouge ‚Äì c√¥t√© ${sideLabel}`
      };
      const petards = sideResult.petards.map(petard => {
        const petardGps = getGpsFromPk(petard.pk);
        const petardAccess = petardGps ? getNearestAccessDetails(petardGps.lat, petardGps.lon, petard.pk, branchHint) : null;
        debugLog("üîç P√©tard PK:", petard.pk, "GPS:", petardGps, "acc√®s:", petardAccess ? petardAccess.name : "aucun");
        return {
          type: "petard",
          order: petard.order,
          railFile: petard.railFile,
          pk: petard.pk,
          lat: petardGps ? petardGps.lat : null,
          lon: petardGps ? petardGps.lon : null,
          nearestAccess: petardAccess,
          title: `P√©tard ${petard.order} (${petard.railFile})`
        };
      });
      return {
        side: sideResult.side,
        sideLabel,
        rationale: sideResult.rationale,
        sam: samEntry,
        petards
      };
    });

    if (coverageResultsLine) {
      const chips = sideSummaries.map(summary => {
        const parts = [`<strong>${summary.sideLabel}</strong> üî¥ PK ${formatPk(summary.sam.pk)}`];
        if (summary.petards.length) {
          const petardList = summary.petards.map(p => formatPk(p.pk)).join(", ");
          parts.push(`üü£ ${petardList}`);
        }
        if (summary.sam.nearestAccess) {
          const access = summary.sam.nearestAccess;
          const accessParts = [];
          accessParts.push(`üö™ ${access.name}`);
          if (access.pk != null) {
            accessParts.push(`PK ${formatPk(access.pk)}`);
          }
          if (access.distanceText) {
            accessParts.push(`<span>${access.distanceText}</span>`);
          }
          parts.push(`<span class="coverage-summary-access">${accessParts.join(" ¬∑ ")}</span>`);
        }
        return `<span class="coverage-summary-chip">${parts.join(" ¬∑ ")}</span>`;
      });
      coverageResultsLine.innerHTML = chips.join("");
    }

    if (coverageResultText) {
      let resultHtml = `<div class="coverage-result-block">`;
      resultHtml += `<div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 12px; color: #ff9f7b;">üìä R√©sultat du calcul</div>`;
      resultHtml += `<div style="margin-bottom: 12px; padding: 10px; background: rgba(255, 255, 255, 0.03); border-radius: 6px;"><strong>Distance r√®gle :</strong> ${result.distanceRule} m</div>`;

      sideSummaries.forEach(summary => {
        const sideColor = summary.side === "pkStart" ? "#ff4b6b" : "#3d7bff";
        let blockHtml = `<div class="coverage-point" style="border-left: 3px solid ${sideColor};">`;
        blockHtml += `<div class="coverage-point-header" style="color: ${sideColor};"><span>üö¶</span><span>C√¥t√© ${summary.sideLabel}</span></div>`;
        blockHtml += `<div class="coverage-point-info"><strong>Feu rouge :</strong> PK ${formatPk(summary.sam.pk)}</div>`;
        if (summary.sam.nearestAccess) {
          const access = summary.sam.nearestAccess;
          blockHtml += `<div class="coverage-point-info"><strong>Acc√®s le plus proche :</strong> ${access.name}`;
          if (access.pk != null) {
            blockHtml += ` ¬∑ PK ${formatPk(access.pk)}`;
          }
          if (access.distanceText) {
            blockHtml += ` ¬∑ ${access.distanceText}`;
          }
          blockHtml += `</div>`;
        }
        if (summary.sam.lat != null && summary.sam.lon != null) {
          blockHtml += createNavigationButtonsHTML(summary.sam.lat, summary.sam.lon);
        }
        if (summary.petards.length) {
          const petardsHtml = summary.petards.map(p => {
            let petardBlock = `<div class="coverage-point coverage-point--nested">`;
            petardBlock += `<div class="coverage-point-header"><span>üü£</span><span>${p.title}</span></div>`;
            petardBlock += `<div class="coverage-point-info"><strong>PK :</strong> ${formatPk(p.pk)}</div>`;
            if (p.nearestAccess) {
              const access = p.nearestAccess;
              petardBlock += `<div class="coverage-point-info"><strong>Acc√®s :</strong> ${access.name}`;
              if (access.pk != null) {
                petardBlock += ` ¬∑ PK ${formatPk(access.pk)}`;
              }
              if (access.distanceText) {
                petardBlock += ` ¬∑ ${access.distanceText}`;
              }
              petardBlock += `</div>`;
            }
            if (p.lat != null && p.lon != null) {
              petardBlock += createNavigationButtonsHTML(p.lat, p.lon, { compact: true });
            }
            petardBlock += `</div>`;
            return petardBlock;
          }).join("");
          blockHtml += `<div class="coverage-petard-list">${petardsHtml}</div>`;
        }
        blockHtml += `<div class="coverage-point-info" style="margin-top: 8px; font-style: italic; color: rgba(226, 231, 255, 0.65);">${summary.rationale}</div>`;
        blockHtml += `</div>`;
        resultHtml += blockHtml;
      });

      resultHtml += `</div>`;
      coverageResultText.innerHTML = resultHtml;
    }

    if (coverageResult) {
      coverageResult.style.display = "block";
    }
    if (btnClearCoverage) {
      btnClearCoverage.style.display = "block";
    }

    if (!orientationMap) {
      return;
    }

    const markerLatLngs = [];
    const legendEntries = [];

    sideSummaries.forEach(summary => {
      if (summary.sam.lat != null && summary.sam.lon != null) {
        const samIcon = L.divIcon({
          className: "leaflet-marker-sam",
          html: "",
          iconSize: [22, 22],
          iconAnchor: [11, 11],
        });
        const samMarker = L.marker([summary.sam.lat, summary.sam.lon], {
          icon: samIcon,
          zIndexOffset: 1200,
        }).addTo(orientationMap);
        samMarker.bindPopup(createCoveragePopupContent(summary.sam));
        coverageSamMarkers.push(samMarker);
        markerLatLngs.push([summary.sam.lat, summary.sam.lon]);
        legendEntries.push({
          kind: "sam",
          label: `Feu rouge ¬∑ c√¥t√© ${summary.sideLabel}`,
          marker: samMarker,
        });
      }

      summary.petards.forEach(p => {
        if (p.lat != null && p.lon != null) {
          const petardIcon = L.divIcon({
            className: "leaflet-marker-petard",
            html: "<span>‚ú∂</span>",
            iconSize: [18, 18],
            iconAnchor: [9, 9],
          });
          const petardMarker = L.marker([p.lat, p.lon], {
            icon: petardIcon,
            zIndexOffset: 1150,
          }).addTo(orientationMap);
          petardMarker.bindPopup(createCoveragePopupContent(p));
          coveragePetardMarkers.push(petardMarker);
          markerLatLngs.push([p.lat, p.lon]);
          legendEntries.push({
            kind: "petard",
            label: `P√©tard ¬∑ c√¥t√© ${summary.sideLabel}`,
            marker: petardMarker,
          });
        }
      });
    });

    renderCoverageLegend(legendEntries);

    if (markerLatLngs.length > 0) {
      const bounds = L.latLngBounds(markerLatLngs);
      orientationMap.fitBounds(bounds.pad(0.25));
      manualMapFocusUntil = Date.now() + 5000;
    }
    
    // Restaurer linePoints
    linePoints = savedLinePoints;
  } catch (error) {
    console.error("Erreur dans addCoverageMarkersToMap :", error);
    alert("Erreur lors de l'affichage des r√©sultats : " + error.message);
  } finally {
    // S'assurer de restaurer linePoints m√™me en cas d'erreur
    if (savedLinePoints) {
      linePoints = savedLinePoints;
    }
  }
}

if (btnComputeCoverage) {
  btnComputeCoverage.addEventListener("click", () => {
    try {
      if (!inputCoveragePkStart || !inputCoveragePkEnd) {
        alert("Champs PK introuvables sur la page.");
        return;
      }

      const rawStart = inputCoveragePkStart.value.trim();
      const rawEnd = inputCoveragePkEnd.value.trim();
      const hasStart = rawStart !== "";
      const hasEnd = rawEnd !== "";

      if (!hasStart && !hasEnd) {
        alert("Saisis au moins un PK (d√©but ou fin) pour lancer le calcul.");
        return;
      }

      // Utiliser la branche choisie dans le menu pour ce contexte
      const coverageBranch = getContextBranch(BRANCH_SELECTION_CONTEXTS.coverage);
      
      const pkStart = hasStart ? parsePkInput(rawStart, coverageBranch) : null;
      const pkEnd = hasEnd ? parsePkInput(rawEnd, coverageBranch) : null;

      if (hasStart && pkStart == null) {
        alert("Le PK d√©but doit √™tre un nombre valide.");
        return;
      }

      if (hasEnd && pkEnd == null) {
        alert("Le PK fin doit √™tre un nombre valide.");
        return;
      }

      if (hasStart && hasEnd && pkStart >= pkEnd) {
        alert("Le PK d√©but doit √™tre inf√©rieur au PK fin.");
        return;
      }
      
      debugLog("üîç Branche choisie pour couverture:", coverageBranch);
      const finalCoverageBranch = coverageBranch || "central";
      
      debugLog("üîç Calcul de couverture - branche choisie:", coverageBranch);
      debugLog("‚úÖ Utilisation de la branche", coverageBranch, "pour le calcul de couverture");
      
      // Forcer l'override pour ce calcul
      const savedOverride = manualBranchOverride;
      manualBranchOverride = coverageBranch;
      currentBranch = coverageBranch;
      debugLog("üîß Override temporairement d√©fini √†", coverageBranch, "pour le calcul");
      
      if (hasStart) {
        ensureBranchForPk(pkStart, BRANCH_SELECTION_CONTEXTS.coverage);
      }
      if (hasEnd) {
        ensureBranchForPk(pkEnd, BRANCH_SELECTION_CONTEXTS.coverage);
      }
      
      const result = computeCoverageMarkers(pkStart, pkEnd);
      
      // Restaurer l'override pr√©c√©dent
      manualBranchOverride = savedOverride;
      if (savedOverride) {
        currentBranch = savedOverride;
      }
      
      if (!result || !result.bySide) {
        console.error("Erreur : computeCoverageMarkers n'a pas retourn√© un r√©sultat valide", result);
        alert("Erreur lors du calcul. Veuillez r√©essayer.");
        return;
      }
      
      addCoverageMarkersToMap(result, coverageBranch);
    } catch (error) {
      console.error("Erreur lors du calcul des rouges et p√©tards :", error);
      alert("Une erreur est survenue : " + error.message);
    }
  });
}

if (btnClearCoverage) {
  btnClearCoverage.addEventListener("click", () => {
    clearCoverageMarkers();
    if (orientationMap) {
      updateOrientationPanel();
    }
  });
}

document.addEventListener("click", (event) => {
  if (legendBranchControls && !legendBranchControls.contains(event.target)) {
    closeLegendBranchMenu();
  }

  const legendTarget = event.target.closest("[data-legend-index]");
  if (legendTarget) {
    const index = parseInt(legendTarget.getAttribute("data-legend-index"), 10);
    if (!Number.isNaN(index)) {
      focusLegendEntry(index);
    }
    return;
  }

  const accessTarget = event.target.closest("[data-access-index]");
  if (accessTarget) {
    const index = parseInt(accessTarget.getAttribute("data-access-index"), 10);
    if (!Number.isNaN(index)) {
      focusNearestAccess(index);
    }
    return;
  }

  const stationTarget = event.target.closest("[data-orient-action='station']");
  if (stationTarget) {
    focusNearestStation();
    return;
  }

  const navTarget = event.target.closest("[data-nav-provider]");
  if (navTarget) {
    const provider = navTarget.getAttribute("data-nav-provider");
    const lat = parseFloat(navTarget.getAttribute("data-lat"));
    const lon = parseFloat(navTarget.getAttribute("data-lon"));
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
      alert("Coordonn√©es indisponibles pour cette navigation.");
      return;
    }
    openNavigationApp(provider, lat, lon);
  }
});

document.addEventListener("keydown", event => {
  if (event.key === "Escape") {
    closeLegendBranchMenu();
  }
});


if (selectIncidentType) {
  selectIncidentType.dispatchEvent(new Event("change"));
}
function initAccessGate() {
  const overlay = document.getElementById("accessOverlay");
  const input = document.getElementById("accessCodeInput");
  const btn = document.getElementById("btnAccessCode");
  const err = document.getElementById("accessError");

  if (!overlay || !input || !btn) return;


  const storedCode = safeGetItem(ACCESS_LAST_USED_CODE_KEY);
  const requiresFreshValidation = !storedCode || storedCode !== ACCESS_CODE;

  if (requiresFreshValidation) {
    try {
      localStorage.clear();
    } catch (error) {
      console.warn("Impossible de r√©initialiser localStorage :", error);
    }
    alert("Code mis √† jour ‚Äî merci de contacter l'administrateur.");
  }

  const already = !requiresFreshValidation && safeGetItem(ACCESS_CODE_KEY);
  if (already === "ok") {
    overlay.style.display = "none";
    return;
  }

  function grantAccess() {
    safeSetItem(ACCESS_CODE_KEY, "ok");
    safeSetItem(ACCESS_LAST_USED_CODE_KEY, ACCESS_CODE);
    err.style.display = "none";
    overlay.style.transition = "opacity 0.2s ease";
    overlay.style.opacity = "0";
    setTimeout(() => {
      overlay.style.display = "none";
    }, 200);
  }

  function tryCode() {
    const v = (input.value || "").trim();
    if (v === ACCESS_CODE) {
      grantAccess();
    } else {
      err.style.display = "block";
    }
  }

  btn.addEventListener("click", tryCode);
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      tryCode();
    }
  });
}

loadSettings();
loadLocalCalibrations();
loadMapPoints();
loadIncidents();
updateSmsPreview();
setGpsStatus("off");

// === TEST getDisplayPk pour Boissy ===
(function testGetDisplayPkBoissy() {
  const testPkMetric = 31000;
  const testBranch = BRANCH_IDS.BOISSY;
  const pkDisplay = getDisplayPk(testBranch, testPkMetric);
  const pkDisplayNumeric = parsePkStringToNumber(pkDisplay.replace(/\s/g, ""));
  
  console.log('TEST_BOISSY_31000 =', {
    pkMetric: testPkMetric,
    branchId: testBranch,
    pkDisplay: pkDisplay,
    pkDisplayNumeric: pkDisplayNumeric,
    offset: BRANCH_OFFSETS[BRANCH_IDS.BOISSY],
    expected: testPkMetric - BRANCH_OFFSETS[BRANCH_IDS.BOISSY],
    isValid: pkDisplayNumeric === (testPkMetric - BRANCH_OFFSETS[BRANCH_IDS.BOISSY])
  });
  
  // Test avec d'autres valeurs Boissy
  const testCases = [
    { pkMetric: 32750, expected: 7750 },  // Fontenay-sous-Bois
    { pkMetric: 34000, expected: 9000 },  // Nogent-sur-Marne
    { pkMetric: 35600, expected: 10600 }, // Joinville-le-Pont
  ];
  
  testCases.forEach(test => {
    const result = getDisplayPk(BRANCH_IDS.BOISSY, test.pkMetric);
    const resultNum = parsePkStringToNumber(result.replace(/\s/g, ""));
    console.log(`TEST_BOISSY_${test.pkMetric} =`, {
      pkMetric: test.pkMetric,
      pkDisplay: result,
      pkDisplayNumeric: resultNum,
      expected: test.expected,
      isValid: resultNum === test.expected
    });
  });
})();

document.addEventListener("DOMContentLoaded", () => {
  initAccessGate();
  // Charger les s√©lections de branche depuis localStorage
  loadBranchSelections();
  // Initialiser les polylignes apr√®s le chargement du DOM
  buildCalibrationPolylines();
  
  // Attacher l'event listener au bouton de g√©olocalisation
  const btnToggleGeolocEl = document.getElementById("btnToggleGeoloc");
  if (btnToggleGeolocEl) {
    // Supprimer tous les event listeners existants pour √©viter les doublons
    const newBtn = btnToggleGeolocEl.cloneNode(true);
    btnToggleGeolocEl.parentNode.replaceChild(newBtn, btnToggleGeolocEl);
    
    // Attacher le nouvel event listener
    newBtn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      console.log("Bouton g√©oloc cliqu√© !");
      
      // V√©rifier que les fonctions existent
      if (typeof startGeoloc !== 'function') {
        console.error("startGeoloc n'est pas une fonction !");
        alert("Erreur : la fonction startGeoloc n'est pas disponible");
        return;
      }
      if (typeof stopGeoloc !== 'function') {
        console.error("stopGeoloc n'est pas une fonction !");
        alert("Erreur : la fonction stopGeoloc n'est pas disponible");
        return;
      }
      
      try {
        if (geolocActive) {
          console.log("Arr√™t de la g√©oloc");
          stopGeoloc();
        } else {
          console.log("D√©marrage de la g√©oloc");
          startGeoloc();
        }
      } catch (error) {
        console.error("Erreur lors du clic sur le bouton g√©oloc:", error);
        alert("Erreur : " + error.message);
      }
    });
    console.log("Event listener attach√© au bouton g√©oloc dans DOMContentLoaded");
  } else {
    console.error("Le bouton btnToggleGeoloc n'a pas √©t√© trouv√© dans DOMContentLoaded !");
  }
});
console.log("PK Assistant RER A ‚Äì script charg√© sans erreur ‚úÖ");

  // Optimisation batterie : pause les animations quand la page n'est pas visible
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      document.body.setAttribute("data-page-hidden", "true");
      // R√©duire la fr√©quence GPS quand la page n'est pas visible
      if (geolocActive && state.watchId) {
        // Augmenter maximumAge quand la page n'est pas visible
        navigator.geolocation.clearWatch(state.watchId);
        state.watchId = navigator.geolocation.watchPosition(
          handlePosition,
          handleGeolocError,
          { 
            // M√™me quand la page est cach√©e, √©viter les timeouts trop courts
            enableHighAccuracy: true,
            maximumAge: 10000,
            timeout: 60000 
          }
        );
    }
  } else {
      document.body.removeAttribute("data-page-hidden");
      // Restaurer la fr√©quence GPS normale quand la page redevient visible
      if (geolocActive && state.watchId) {
        navigator.geolocation.clearWatch(state.watchId);
        state.watchId = navigator.geolocation.watchPosition(
          handlePosition,
          handleGeolocError,
          { 
            enableHighAccuracy: true,
            maximumAge: 10000,
            timeout: 60000
          }
        );
      }
    }
  });

  if (tabButtons.length) {
    tabButtons.forEach(button => {
      button.addEventListener("click", () => {
        const target = button.getAttribute("data-tab-target") || "status";
        activateTab(target);
      });
    });
  }

  // D√©claration des √©l√©ments du DOM pour les plans PDF
  const planBoissyToggle = document.getElementById("planBoissyToggle");
  const planBoissyContainer = document.getElementById("planBoissyContainer");
  const planParisOuestToggle = document.getElementById("planParisOuestToggle");
  const planParisOuestContainer = document.getElementById("planParisOuestContainer");
  const planChessyToggle = document.getElementById("planChessyToggle");
  const planChessyContainer = document.getElementById("planChessyContainer");

  function bindPlanToggle(toggle, container) {
    if (!toggle || !container) return;
    toggle.addEventListener("change", () => {
      container.style.display = toggle.checked ? "block" : "none";
    });
  }

  bindPlanToggle(planBoissyToggle, planBoissyContainer);
  bindPlanToggle(planParisOuestToggle, planParisOuestContainer);
  bindPlanToggle(planChessyToggle, planChessyContainer);

  // Gestion de la navigation des PDF
  const pdfConfig = {
    boissy: {
      iframe: document.getElementById("planBoissyIframe"),
      baseUrl: "docs/Boissy.pdf",
      maxPages: 50 // Valeur par d√©faut, sera mise √† jour si d√©tect√©e
    },
    parisouest: {
      iframe: document.getElementById("planParisOuestIframe"),
      baseUrl: "docs/Paris%20-%20Ouest.pdf",
      maxPages: 50
    },
    chessy: {
      iframe: document.getElementById("planChessyIframe"),
      baseUrl: "docs/Chessy.pdf",
      maxPages: 50
    }
  };

  // Fonction pour mettre √† jour la page du PDF
  function updatePdfPage(pdfId, pageNum) {
    const config = pdfConfig[pdfId];
    if (!config || !config.iframe) return;

    const maxPages = config.maxPages || 50;
    const page = Math.max(1, Math.min(pageNum, maxPages));
    
    // Pour iOS, forcer le rechargement complet de l'iframe
    // En vidant d'abord le src, puis en le remettant avec le nouveau param√®tre
    const iframe = config.iframe;
    // Ajouter zoom=page-fit pour permettre le d√©filement vertical des pages sur mobile
    const newSrc = config.baseUrl + "#page=" + page + "&zoom=page-fit";
    
    // Si c'est la m√™me page, ne rien faire
    if (config.currentPage === page && iframe.src === newSrc) {
      return;
    }
    
    // Forcer le rechargement en vidant puis remettant le src
    iframe.src = "";
    // Petit d√©lai pour s'assurer que le navigateur a bien vid√© l'iframe
    setTimeout(() => {
      iframe.src = newSrc;
      config.currentPage = page;
    }, 50);

    // Mettre √† jour l'interface
    const pageInput = document.querySelector(`.pdf-page-input[data-pdf="${pdfId}"]`);
    const totalSpan = document.querySelector(`.pdf-page-total[data-pdf="${pdfId}"]`);
    const prevBtn = document.querySelector(`.pdf-nav-prev[data-pdf="${pdfId}"]`);
    const nextBtn = document.querySelector(`.pdf-nav-next[data-pdf="${pdfId}"]`);

    if (pageInput) pageInput.value = page;
    if (totalSpan) totalSpan.textContent = "/ " + maxPages;
    if (prevBtn) prevBtn.disabled = page <= 1;
    if (nextBtn) nextBtn.disabled = page >= maxPages;
  }

  // Initialiser la navigation pour chaque PDF
  Object.keys(pdfConfig).forEach(pdfId => {
    const config = pdfConfig[pdfId];
    if (!config.iframe) return;

    // Bouton pr√©c√©dent
    const prevBtn = document.querySelector(`.pdf-nav-prev[data-pdf="${pdfId}"]`);
    if (prevBtn) {
      prevBtn.addEventListener("click", () => {
        const currentPage = config.currentPage || 1;
        updatePdfPage(pdfId, currentPage - 1);
      });
    }

    // Bouton suivant
    const nextBtn = document.querySelector(`.pdf-nav-next[data-pdf="${pdfId}"]`);
    if (nextBtn) {
      nextBtn.addEventListener("click", () => {
        const currentPage = config.currentPage || 1;
        updatePdfPage(pdfId, currentPage + 1);
      });
    }

    // Champ de saisie
    const pageInput = document.querySelector(`.pdf-page-input[data-pdf="${pdfId}"]`);
    if (pageInput) {
      pageInput.addEventListener("change", (e) => {
        const pageNum = parseInt(e.target.value, 10);
        if (!isNaN(pageNum) && pageNum > 0) {
          updatePdfPage(pdfId, pageNum);
        } else {
          e.target.value = config.currentPage || 1;
        }
      });

      pageInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.target.blur();
          const pageNum = parseInt(e.target.value, 10);
          if (!isNaN(pageNum) && pageNum > 0) {
            updatePdfPage(pdfId, pageNum);
          }
        }
      });
    }

    // Initialiser √† la page 1
    updatePdfPage(pdfId, 1);
  });

  // Liste de tests sur la page d'accueil
  const TEST_LIST_KEY = "testListResults";
  let testResults = {};

  function loadTestResults() {
    try {
      const stored = safeGetItem(TEST_LIST_KEY);
      if (stored) {
        testResults = JSON.parse(stored);
      }
    } catch (e) {
      console.warn("Erreur lors du chargement des r√©sultats de tests", e);
      testResults = {};
    }
  }

  function saveTestResults() {
    try {
      safeSetItem(TEST_LIST_KEY, JSON.stringify(testResults));
    } catch (e) {
      console.warn("Erreur lors de la sauvegarde des r√©sultats de tests", e);
    }
  }

  function setTestResult(testId, result) {
    // Si on clique sur le m√™me r√©sultat, on le d√©sactive (toggle)
    if (testResults[testId] === result) {
      delete testResults[testId];
    } else {
      testResults[testId] = result;
    }
    saveTestResults();
    updateTestButtonState(testId);
  }

  // Rendre la fonction accessible globalement pour les onclick
  window.setTestResult = setTestResult;

  function updateTestButtonState(testId) {
    const okBtn = document.getElementById(`test-ok-${testId}`);
    const koBtn = document.getElementById(`test-ko-${testId}`);
    const result = testResults[testId];
    
    if (okBtn) okBtn.classList.toggle("active", result === "ok");
    if (koBtn) koBtn.classList.toggle("active", result === "ko");
  }

  function generateTestListContent() {
    const container = document.getElementById("testListContent");
    if (!container) return;

    const tests = [
      { id: "access-1", text: "Ouvrir l'application dans le navigateur", section: "Acc√®s" },
      { id: "access-2", text: "Saisir le code d'acc√®s (3615)", section: "Acc√®s" },
      { id: "access-3", text: "V√©rifier que l'√©cran d'accueil s'affiche correctement", section: "Acc√®s" },
      { id: "geoloc-1", text: "Cliquer sur \"Lancer la g√©oloc\"", section: "G√©olocalisation" },
      { id: "geoloc-2", text: "Autoriser la g√©olocalisation si demand√©", section: "G√©olocalisation" },
      { id: "geoloc-3", text: "V√©rifier que le PK actuel s'affiche", section: "G√©olocalisation" },
      { id: "geoloc-4", text: "V√©rifier que le sens s'affiche", section: "G√©olocalisation" },
      { id: "geoloc-5", text: "V√©rifier que la gare la plus proche s'affiche", section: "G√©olocalisation" },
      { id: "geoloc-6", text: "V√©rifier que la prochaine gare s'affiche", section: "G√©olocalisation" },
      { id: "geoloc-7", text: "V√©rifier que l'acc√®s le plus proche s'affiche", section: "G√©olocalisation" },
      { id: "geoloc-8", text: "Se positionner dans la zone Nanterre (entre PK 10800 et 11300) : v√©rifier le message d'avertissement", section: "G√©olocalisation" },
      { id: "geoloc-9", text: "V√©rifier que le PK affich√© est arrondi √† 10800 ou 11300 dans la zone Nanterre", section: "G√©olocalisation" },
      { id: "map-1", text: "V√©rifier que la carte s'affiche avec ta position", section: "Carte" },
      { id: "map-2", text: "V√©rifier que les gares apparaissent sur la carte", section: "Carte" },
      { id: "map-3", text: "V√©rifier que les acc√®s apparaissent sur la carte", section: "Carte" },
      { id: "map-4", text: "Zoomer et d√©zoomer sur la carte", section: "Carte" },
      { id: "map-5", text: "D√©finir un PK cible et v√©rifier qu'il appara√Æt", section: "Carte" },
      { id: "pdf-1", text: "Ouvrir le plan de Boissy", section: "Plans PDF" },
      { id: "pdf-2", text: "Naviguer dans les PDF avec les boutons", section: "Plans PDF" },
      { id: "pdf-3", text: "Saisir un num√©ro de page directement", section: "Plans PDF" },
      { id: "pdf-4", text: "Sur mobile : d√©filement vertical fonctionne", section: "Plans PDF" },
      { id: "sms-1", text: "G√©n√©rer le SMS d'urgence", section: "SMS" },
      { id: "sms-2", text: "V√©rifier que le message contient toutes les infos", section: "SMS" },
      { id: "search-1", text: "Rechercher un PK", section: "Recherche" },
      { id: "search-2", text: "V√©rifier que l'acc√®s le plus proche s'affiche", section: "Recherche" },
      { id: "search-3", text: "Ouvrir Google Maps depuis la recherche", section: "Recherche" },
      { id: "search-4", text: "Rechercher un PK entre 10800 et 11300 (zone Nanterre) : doit arrondir au plus proche", section: "Recherche" },
      { id: "search-5", text: "Rechercher PK 11250 : doit pointer vers 11300 (aval)", section: "Recherche" },
      { id: "coverage-1", text: "Calculer une couverture travaux", section: "Couverture" },
      { id: "coverage-2", text: "V√©rifier que les marqueurs apparaissent", section: "Couverture" },
      { id: "coverage-3", text: "Effacer les marqueurs", section: "Couverture" },
      { id: "coverage-4", text: "Calculer une couverture qui traverse la zone Nanterre : v√©rifier qu'aucun marqueur n'est entre 10800 et 11300", section: "Couverture" },
      { id: "coverage-5", text: "V√©rifier que les distances m√©triques (rouges/p√©tards) restent correctes malgr√© le saut PK", section: "Couverture" },
      { id: "points-1", text: "Enregistrer un point de carte", section: "Points" },
      { id: "points-2", text: "Exporter en JSON", section: "Points" },
      { id: "points-3", text: "Exporter en Note", section: "Points" },
      { id: "settings-1", text: "Changer la sensibilit√© au mouvement", section: "Param√®tres" },
      { id: "settings-2", text: "Sauvegarder un num√©ro SOS", section: "Param√®tres" },
      { id: "settings-3", text: "Faire un recalage PK", section: "Param√®tres" },
      { id: "settings-4", text: "Faire un recalage dans la zone Nanterre : v√©rifier l'avertissement \"Zone de saut PK\"", section: "Param√®tres" },
      { id: "mobile-1", text: "Tester sur mobile (Android)", section: "Mobile" },
      { id: "mobile-2", text: "Tester sur mobile (iPhone)", section: "Mobile" },
      { id: "mobile-3", text: "Tous les boutons fonctionnent au toucher", section: "Mobile" }
    ];

    let html = '<p style="margin-bottom: 20px; color: var(--muted); font-size: 0.9rem; line-height: 1.5;">Clique sur <span style="color: #46c8b4;">‚úì</span> pour OK ou <span style="color: #ff6f7a;">‚úó</span> pour pas OK pour chaque test.</p>';
    
    const sections = {};
    tests.forEach(test => {
      if (!sections[test.section]) {
        sections[test.section] = [];
      }
      sections[test.section].push(test);
    });

    Object.keys(sections).forEach(sectionName => {
      html += `<h3 style="color: var(--text); margin-top: 24px; margin-bottom: 14px; font-size: 1.05rem; font-weight: 600; border-bottom: 1px solid var(--border); padding-bottom: 8px;">${sectionName}</h3>`;
      sections[sectionName].forEach(test => {
        html += `
          <div class="test-item">
            <span class="test-item-text">${test.text}</span>
            <div class="test-buttons">
              <button id="test-ok-${test.id}" class="test-btn test-btn-ok" onclick="setTestResult('${test.id}', 'ok')" title="OK" aria-label="Test OK">‚úì</button>
              <button id="test-ko-${test.id}" class="test-btn test-btn-ko" onclick="setTestResult('${test.id}', 'ko')" title="Pas OK" aria-label="Test pas OK">‚úó</button>
            </div>
          </div>
        `;
      });
    });

    container.innerHTML = html;
    
    // Mettre √† jour l'√©tat des boutons
    tests.forEach(test => {
      updateTestButtonState(test.id);
    });
  }

  // Initialiser les r√©sultats de tests au chargement
  loadTestResults();

  // Initialiser les event listeners pour la liste de tests (apr√®s cr√©ation des √©l√©ments HTML)
  setTimeout(() => {
    initTestListListeners();
  }, 100);

  </script>

  <!-- Liste de tests -->
  <div style="margin: 40px auto 20px; max-width: 1080px; padding: 0 24px;">
    <button id="btnTestList" class="btn btn-secondary btn-icon" type="button" style="width: 100%; justify-content: center;">
      <span>‚úÖ</span><span>Liste de tests</span>
    </button>
    
    <div id="testListPanel" class="card" style="display: none; margin-top: 20px;">
      <div class="card-header">
        <div class="card-title">‚úÖ Liste de tests</div>
      </div>
      <div id="testListContent" style="padding: 16px; line-height: 1.8; color: var(--text); max-height: 70vh; overflow-y: auto; -webkit-overflow-scrolling: touch;">
        <!-- Le contenu sera g√©n√©r√© par JavaScript -->
      </div>
      <div class="field" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
        <button id="btnCloseTestList" class="btn btn-secondary" type="button" style="width: 100%;">
          Fermer
        </button>
      </div>
    </div>
  </div>

  <!-- Signature -->
  <div class="app-footer">
    KYFUN
    <div class="app-footer-contact">
      Administrateur&nbsp;: <a href="mailto:pascal.akriche@ratp.fr">pascal.akriche@ratp.fr</a>
    </div>
  </div>
</body>
</html>